[{"title":"2019 我干了些什么","date":"2020-01-04T08:40:47.000Z","path":"2020/01/04/2019-干了些什么/","text":"姗姗来迟的 2019 总结。 图摄于某日加班等公交车时 越到年末事情越多，整个人忙的晕头转向。由于工作的原因，我也已经很久没有更新过博客和公众号了，工作之后没时间这句话说的不是没有道理。同事也说自己弄过一个公众号，后来没时间打理就不了了之。每天下班回家之后，等洗漱完就半夜，只想玩会儿手机赶紧休息，没有心情做其他事情。 有时候想想，大部分时间都给了工作，自己只剩下周末，这种工作方式值不值得。 抱怨归抱怨，2019 这一年时间过得还是挺充实的。 上半年基本忙着毕业，专利、论文和学校的事情。 搞定之后去了一趟女朋友家里，本来想着工作之后再去的，想想工作之后没什么时间，还是安排了一下和她父母见了个面。由于时间原因，也没有待多久，很快就回了学校。然后就是让父母来了一趟西安，带他们出门走了走，也算是完成了一个小小目标。 下半年事情就比较多了。 工作 刚接触工作内容，要完成学习到工作的转换。这个过程其实碰到挺多问题的，一般来说新人得先熟悉业务，但是部门事情太多，所以经常在不熟悉业务的情况下开始写新的需求，时间还很紧张，这样就很容易出现 bug。 这半年过来，经历了一些艰难的时候。有一次临近发版，我要在时间很紧张的情况下独自做决定，手头还没有决策所需要的相关数据，如果决策出错，那么影响面会很大。 这个时候其实挺绝望的，我之前也没有处理过相关事情的经验，也无法求助谁，做了决定就要承担责任，不过还好后来事情解决了。 上班之后有一个好处就是阅读规范的工程代码，虽然这半年压力很大，不过也确实学到了挺多东西，包括工程能力和规范的运作方式。 还有一个要说的就是工作和生活失衡的问题。需求真的是做不完的，不管 PM 怎么催，都要按照自己的节奏来完成，调节好自己的时间。这半年因为刚开始工作的因素，很多时间都花在了工作中，私人生活过得一团糟。 生活 不得不说，一个人住太舒服了。 虽然说还要和别人合租，但是有自己的私人空间，现在养了一株文竹，一盆绿萝还在发芽中，准备再养一盆多肉 ，还在筹划中。 另外这半年开始自己做饭，尝试了很多新菜式，遗憾的是我的时间太少了，而且一个人做饭太尴尬。有一次想做牛肉，结果我要的分量太少，老板不给我切，最后放弃了。 不过一个人生活的话，真的很容易枯燥。我周末经常有孤独的感觉，缺乏精神生活，当然这也和性格有关系。 女朋友这半年来的倒挺勤，但欢乐的时光总是短暂的，每次送她去火车站再回到家里，总会感觉空空荡荡。 如果你马上也要开始这种生活，最好提前做好准备。 理财 过了那股新鲜劲，理财已经很久没有打理了，一直在自动定投基金。 前两天看了一眼支付宝，放在里面的钱整体收益率是 27+%。因为之前贸易战，股票跌惨了，今年回升了一些，我的基金跟着市场也涨了一些。 目前资产分布是 1/2 定投基金，1/2 用来放货基，还有零星的一些现金放银行里应急用。 期望 想起来 2019 年的最后一天依旧加班到 10 点多才回家，但愿新的一年工作之余多出去走走吧，多给自己一点时间。 好好利用空下来的时间，多提升自己。 多和亲人联系，一年都见不了几天。 不管 2019 经历了多少艰难的时刻，总是要怀着希望继续走下去。","tags":[{"name":"总结","slug":"总结","permalink":"https://KingsFish.github.io/tags/总结/"},{"name":"复盘","slug":"复盘","permalink":"https://KingsFish.github.io/tags/复盘/"},{"name":"2019","slug":"2019","permalink":"https://KingsFish.github.io/tags/2019/"}]},{"title":"谈谈Android编译运行过程","date":"2019-10-02T16:01:36.000Z","path":"2019/10/03/谈谈Android编译运行过程/","text":"最近阅读了一下Android编译和运行相关的文章，大概了解了整体运行过程，在这里总结一下。 整篇文章相对而言不涉及到过多的技术细节，没有什么基础的人也能够通过这篇文章了解到Android的相关知识。 这篇文章内容较多，主要内容有： JVM和Android的关系 字节码 Android构建系统 AOT和JIT的含义，以及它们和R8的关系 Android运行系统 在此之前，先要说一下一些基础知识。 一、CPU &amp; JVM每台手机设备都具有CPU，CPU性能强弱是手机流畅性影响因素之一，这里不展开讨论这个问题。目前手机端有名的CPU应当是高通的骁龙系列。当然也有其他架构的CPU，如ARM、ARM64、x86、x86_64、MIPS。针对不同架构的CPU进行开发时，需要对不同的CPU架构生成不同的.so文件，这是一件很麻烦的事情。 不同的CPU架构 这个时候JVM（Java虚拟机）就展示出了它的优势。JVM（Java Virtual Machine）会在硬件层面上增加一层抽象层。也就是说，你开发的app只需要支持Java API构成的”CPU”即可，再也不用被繁多的CPU架构困扰，也不用做额外的适配工作。 JVM原理 Java代码只需要使用javac编译器编译成字节码文件(.class文件)，然后代码就可以跑在JVM上，和操作系统隔离。一次编译，到处运行。这样，开发者无需考虑系统类型、设备类型、内存以及CPU，只要把精力集中在业务逻辑就可以了。 1.1 JVM内部结构 JVM结构 下面来说说JVM，JVM主要由三部分构成： ClassLoader负责加载编译后的Java文件(.class)，验证链接关系，检测字节码是否正确，为静态变量和代码分配内存以及初始化。 运行时数据负责所有的程序数据：stack、方法、变量还有Heap 执行引擎执行编译完成并加载的代码和GC 了解完以上知识之后，就可以开始继续了解解释器(Interpreter)和JIT编译器了。 1.2 Interpreter &amp; JIT这两兄弟是一起工作的。每次跑程序时，Interpreter选取应当执行的.class字节码，然后将其实时翻译成机器码执行。这么做有一个缺点，如果一个方法或者逻辑被多次调用，那么每次调用都要重新翻译一次，效率特别低，实际上翻译出来的机器码可以重复使用。 在这种情况下，JIT（Just In Time）就派上用场了。执行引擎在Interpreter的帮助下将字节码翻译成机器码，如果发现有重复执行的代码，JIT就开始工作，将这部分频繁调用的代码翻译成机器码，当程序再次调用这个部分的逻辑时，执行引擎会直接使用JIT翻译完成的机器码，这样就能够提升系统的性能表现，这部分代码也叫Hot Code。 执行流程 1.3 Dalvik那么上面说的这些和Android有什么关系呢？ JVM设计运行的硬件环境和Android设备不一样，JVM最初是为电视机顶盒设计的，拥有“无限”电量，而一般来说手机设备有4000mah已经是很大的电池了，另外Android设备存储空间比较小（现在其实挺大的）。因此，Google修改了JVM的整体结构，包括Java代码编译过程和字节码结构，以适应手机设备。编译过程的差异将在下一节讲述，字节码结构则下面用代码实例说明一下。 1234public int method(int i1, int i2) &#123; int i3 = i1 + i2; return i3 * 2;&#125; 上面这段代码生成的.class字节码如下： java bytecode 使用Android的Dex编译器编译代码生成的.dex字节码如下： Dex bytecode 两张图对比可以明显看出来，.dex字节码会比.class字节码更简洁。 另外，Java字节码是基于栈结构（所有的变量都存储在栈上）的，而Dex字节码基于寄存器结构（所有变量存储在寄存器中）。 基于栈结构的字节码，在执行操作时需要先将操作数加载到操作栈上，然后计算，最后再将得到的结果从栈上弹出到局部变量表中。 基于栈的计算过程 而基于寄存器的字节码可以直接读取寄存器中存储的数据，然后一步到位将结果存入另外的寄存器。Dex这种字节码相对Java字节码而言更高效，需要的空间也更少。 在Android 5.0以前，Android系统中解析Dex字节码的虚拟机叫做Dalvik。 Dalvik加载和解析执行Dex字节码的方式和JVM使用JIT以及Interpreter一样。 二、Android 构建过程 Gralde Build Process .java和.kt文件由Java/Kotlin编译器编译成.class文件。这些.class文件则通过Dex编译器编译成.dex文件，最终和资源文件等打包成.apk文件。 可以看到，Android构建其实和Java语言有很大关系。Java语言基本每年更新一个新版本，目前最新的是Java 12。而相对于Java的迅速迭代而言，Android虚拟机则慢了很多，很多语言新特性无法直接在虚拟机上使用。因此，Android构建过程中，除了要将class文件转化成dex文件之外，还有一个重要的任务是将新特性转化成老版本Java能够运行的特性，也就是所谓的“脱糖”。 脱糖 2.1 Jack &amp; Jill为了解决这个问题，Google在16年推出了Jack &amp; Jill这套编译机制。具体流程如下： Jack & Jill Google想使用Jack工具直接将Java代码编译成dex文件，至于应用所使用过的第三方库，则使用Jill工具编译成中间文件然后再编译成dex文件。 这样看起来简单明了，没有那么多中间过程。但实际效果没有预期那么好。Google需要重新实现Java生态所有特性支持，如注解，工作量很大；并且有些第三方库依赖于Java字节码神效；另外，经过实际应用，发现这个工具速度慢，耗内存，且不支持instant run。Google在17年废弃了这个编译工具链。 2.2 D8为了改善构建环境，Google在Android Studio 3.2中使用D8(Dope 8)取代了原来的Dex编译器。这个替换操作主要的目的是将脱糖操作和class2dex操作合并，减少构建时间。 D8构建过程 那么D8有多快呢？这得分工程规模来看。小APP的话，100次构建取平均值之后，优化的时间为2s。 D8构建时间对比图 官方描述D8的优点有： 编译更快、时间更短； DEX 编译时占用内容更小； .dex 文件大小更小； D8 编译的 .dex 文件拥有相同或者是更好的运行时性能； 这还没完，Google还有一个大招。 2.3 R8R8是D8的衍生产品，他们使用相同的代码库，但是R8还解决了其他问题。跟D8一样，R8也能将Java新feature提供给开发者使用，但不仅限于此。 R8带来的一个最大改进是优化.dex中的代码，只保留了支持应用所需要的API，删除了没有用上的类和方法。 另外，R8能够替代Proguard。Proguard是一个在构建过程中使用到的混淆工具，在.class转换.dex过程中，R8会替代Proguard的工作，比如优化、混淆代码，移除无用的类。 用Java 8的lambda表达式做测试： 1234567891011121314class MathLambda &#123; interface NumericTest &#123; boolean computeTest(int n); &#125; void doSomething(NumericTest numericTest) &#123; numericTest.computeTest(10); &#125;&#125;private void java8ShowCase() &#123; MathLambda math = new MathLambda(); math.doSomething((n) -&gt; (n % 2) == 0);&#125; 使用R8能够减少生成的字节码行数。 Dex vs R8 R8在Android Studio 3.4被引入并默认开启，官方宣称能够优化逻辑代码，混淆代码和清除无用的类和方法。 同一个APP，分别使用Dex+Proguard和R8构建100次，取平均值，结果如下： Dex-Proguard vs R8 如上图，在构建过程中，使用R8减少了13s构建时间，同时减少了112个方法，生成的apk也小了348kb。整体而言，结果很不错。 举一个R8优化字符串操作的例子，如下代码： 直接编译成字节码如下： 从字节码可以看到，每次都先计算字符串WILDCARD的长度，然后取子字符串。其实字符串常量WILDCARD长度为固定的，所以没有必要一次次重新计算，编译期计算出来就可以。优化之后的字节码如下： 可以看到0008行直接将一个固定值赋给了变量v0，然后在获取子字符串进行之后的操作。 三、Android运行过程3.1 Dalvik虚拟机从应用商店下载一个apk文件，安装后，点击图标icon，然后就可以看到APP运行在了手机上。那么中间发生了哪些事情？ APK安装文件一般包含了所有的资源文件（图片，图标和布局等）和代码文件，安装时系统会把这些资源存储到内存中。当用户点击应用图标时，手机会启动一个Dalvik进程，然后将该app的dex文件加载到内存，同时Dalvik虚拟机将会把dex字节码通过Interpreter或JIT翻译成机器码，最终这款app运行在了你手机上。 APP 运行过程 当应用要使用到某部分代码（字节码）时，Dalvik会通过Interpreter将字节码实时翻译成机器码运行，经过一段时间后，如果有部分代码被经常调用（比如刷抖音时调用的请求视频数据逻辑），那么这部分代码会被定义成hotcode，随后被JIT翻译成机器码存储在内存中。当这部分代码再次被调用时，就不需要实时翻译，直接使用翻译好的机器码即可，这样就提高了运行效率。 这个过程和餐厅接待客人的一些现象很相似。Interpreter就是客人来了之后现场点现场做，JIT则是根据之前的经验，将这个客人常点的菜提前先做好，这样就能提高上菜速度。 JIT机制是Android 2.2引入的，之前全靠Interpreter实时翻译，可想而知之前卡顿有多严重。 3.2 ARTDalvik对于手机设备来说是一个很好的解决方案，但是它。因此Google对JVM进行了改进，推出了一种新的JVM，称为ART虚拟机。Dalvik和ART最大的区别在于ART不会在运行时对字节码进行翻译执行，而是把这个过程提前到了安装过程中。ART使用AOT（Ahead of Time）编译器来将字节码翻译成.oat文件。 AOT 运行过程 APP被安装时，ART将Dex字节码预编译成.oat文件，每次启动APP时系统直接读取.oat文件运行即可，不再使用JIT以及Interpreter这种即时翻译的工具，大大提升了运行流畅度。 这样看起来好像AOT好像没什么毛病，Google当初也觉得自己找到了终极解决方式，但实际上AOT还是会有一些问题： AOT在安装过程中进行预编译行为，这样安装和更新APP时间相比原来就会大大增加。另外，升级Android系统时，系统会把所有程序重新安装一次，想想那么多APP要重新安装编译成.oat文件，头都大了。 空间大小。AOT将整个.dex文件都翻译为.oat文件，包括那种很少使用或者根本不会被使用到的代码（比如第一次打开APP的设置向导或者开屏界面）。根据Google相关的数据，常用的代码大概占所有代码的15~20%左右，这样就浪费了很大一部分空间，在一些小存储容量的低端机上这个问题尤其明显。 既然这也不好，那也不好，那就集中两种方式的优点就好了。Google工程师想出了一个新点子：Interpreter + JIT + AOT混合编译，具体方案如下： 安装的时候不进行预编译，也即不生成.oat文件。app第一次启动时，ART使用Interpreter来实时翻译.dex文件。 当出现Hot Code时，使用JIT进行翻译，并将翻译后的机器码存入缓存（内存）中，之后调用Hot Code时直接从缓存中取。 当设备空闲时，比如锁屏，Hot Code会被AOT编译器编译成oat文件存入本地存储空间。 app再次启动时，如果存在.oat文件，那么直接使用.oat文件，否则从步骤1开始。 AOT 运行过程 国内的厂商会有“基于用户操作习惯进行学习，APP打开速度不断提高”的说法，有一部分是这个混合编译方案的功劳。 根据官方数据，平均来看，app运行8次之后，这个机制能够优化80%的空间。 这个混合机制为Android N(5.0)引入的，也正是这个时候开始用户对Android的运行效率看法有了改观。 3.3 PGO经过上面这些动作，Android的运行速度其实已经有很大的改观。但还是有可以改进的地方。 在说AOT混合编译的时候系统会生成一个profile，这个profile记录了hotcode的信息，哪些类和哪些方法会被经常调用。而对于大多数人来说，同一个APP的hotcode区别不大，其实可以共用，因此Google在2018 Google I/O大会上提出了Cloud Profiles的方案。具体原理如下： 共享 这个方案依赖Google Play来完成。当一个设备为空闲状态并且连接到WiFi时，Google Play Service会将编译后的文件共享，之后如果有一样的手机从Googole Play中下载这个APP时，终端会收到其他人的hotcode信息，这样用户在第一次使用时就能获得良好的体验。 但实际上，一个人的hotcode无法代表所有人的hotcode信息，那么需要多少个样本才能拿到一个比较稳定的hotcode profile呢？根据官方的数据，这个数字还挺小的。 平均而言，30个profile已经能达到一个比较稳定的水平，而且效果也不差。 启动时间 然而这些方案对于国内来说都没什么用…因为没法使用Google Play。但Android 9开始，Google提供了一个内置hotcode的方案，也就是说，可以在构建期间往APP中放置hotcode信息，这样系统在安装APP时直接将这部分代码编译成机器码，速度会有很大的提升。 不过这部分内容在国内资料很少，Google搜索了之后也才发现官方给了这一篇文章，Build With PGO，有兴趣的可以自己继续了解一下。 3.4 鸿蒙系统 &amp; 方舟编译器说到了编译器和Android的运行机制，不得不说一下最近大热的华为鸿蒙系统和方舟编译器。这里先放一张官网给的架构图： 在网上搜集了一些信息之后，不得不说华为的愿景很大。想把Java/Kotlin、C++直接编译成能够运行的机器码，据了解的信息，普通的APP经过华为的编译器之后，包体积会增大一些。另外，对于语言的动态特性，比如Java的多态，直接在编译期处理成静态特性。这些都是华为官方宣称的优点，不知道华为具体是怎么做的，拭目以待吧。 参考文档 https://proandroiddev.com/android-cpu-compilers-d8-r8-a3aa2bfbc109 https://source.android.google.cn/devices/tech/perf/pgo#case-study-pgo-for-art https://juejin.im/post/5ca480b66fb9a05e1d26bb7a https://www.infoq.com/news/2019/04/play-cloud-art-profiling-android/ https://juejin.im/post/5d4bdb23e51d453c2577b747 https://zhuanlan.zhihu.com/p/62794593 https://juejin.im/post/5cbe60796fb9a0324d43ab97#heading-5 https://blog.csdn.net/Mr_dsw/article/details/90141647 https://zhuanlan.zhihu.com/p/65307730","tags":[{"name":"虚拟机","slug":"虚拟机","permalink":"https://KingsFish.github.io/tags/虚拟机/"},{"name":"编译","slug":"编译","permalink":"https://KingsFish.github.io/tags/编译/"}]},{"title":"我的微信公众号开通了~","date":"2019-09-21T14:56:40.000Z","path":"2019/09/21/葫芦籽的碎碎念/","text":"犹豫了很久，终于还是开通了微信公众号，名为「葫芦籽的碎碎念」，前几天刚刚开通的，准备长期运营。 为什么要开通这个微信公众号开通微信公众号所考虑的因素比较多： 目前博客所有的文件保存在本地以及Github仓库中，有无法访问和数据丢失的风险。 博客评论系统比较麻烦，目前用过Disqus，Gitment，valine。Disqus由于不可抗力因素国内无法访问；Gitment太乱，依托于Github的issue系统，并且需要登录Github；valine用了一段时间，感觉还不错，评论不需要注册账号，也不需要后端，不过valine依托于LeanCloud作为后端存储系统，而最近LeanCloud需要实名注册备案，不想把自己的隐私信息交出去。 使用博客的话，目前只提供了一个邮箱联系方式，与粉丝的连接性较差。使用公众号则可以随时与粉丝联系（其实博客并没有多少粉丝T_T）。 博客和公众号的共存性目前精力主要放在微信公众号中，但是会将微信公众号的部分内容（目前计划是技术相关，后期看精力会再增加）同步到博客。微信公众号会多一些其他内容，如自己除了技术其他方面的学习，读书笔记等等。 最近刚入职，精力主要放在了熟悉业务相关内容上，因此更新频率下降了很多，最近一次更新已经是2个多月之前了。另外，自己的学习计划也有很多没有时间完成，之后会慢慢把这些都捡起来。 最后，附上我的微信公众号，欢迎各位读者关注 葫芦籽的碎碎念","tags":[]},{"title":"2019上半年复盘","date":"2019-07-11T15:44:42.000Z","path":"2019/07/11/2019上半年复盘/","text":"不知不觉2019过去了一半，学生生涯的最后一个学期。 一 上半年的首要任务是毕业，写论文之前最好写一篇专利，这样的话被抽中盲审几率较小。 写专利是件简单的事情，然而在学校专利办老师的加持下，变成了一件非常痛苦的事情。大家能不在学校专利办改，就不在那改。原因无他，专利办老师态度实在太差，去过的人都不想再去第二次。 跌跌撞撞把专利改完，开始着手论文的事情。从构思到完工大概花了一个月的时间，DeadLine果然是第一生产力。其实也不想自己能写得有多好，毕竟时间摆在那里，只要能顺利毕业就行。 托专利的福，最终盲审没有抽中，明审也安心通过。答辩的时候也比较顺利，听到答辩委员会说恭喜你们获得硕士学位的时候，心里石头落下了地。 二 一月份的时候逛星球，无意中发现有人推荐了一下蜗牛读书，说是体验还不错，几千万的用户量。但是我从来都没有听过，于是下载体验了一下。结果一发不可收拾。 蜗牛的阅读体验很不错。读书是免费时长制，每天可以免费阅读1小时，看广告的话是2小时。虽然看起来时间比较短，但实际上已经基本能够满足需求。阅读时间会换算成蜗牛读书的内部货币——蜗牛壳。蜗牛壳可以用来换书，换过的书不消耗阅读时长。另外，可以约人共读书籍，这样的话能一起交流，同时蜗牛壳翻倍。 总的来说，感觉没有kindle的情况下，蜗牛读书是个不错的替代品。上半年在这上面阅读了不少书籍。目前在蜗牛上已经阅读了10多本书，总字数约300W+，也算是个不错的成果。 三 学生生涯的最后半年，毕业之前，终于把父母来西安的计划实现了。趁着学士服发到了手里，把他们两叫来了西安，也算是了了老妈的心愿。毕竟这么多年了，她还没有出去旅游过。 来的那几天带他们去逛了逛陕西历史博物馆，看了兵马俑，在兵马俑那里还给老妈买了一个玉手镯。据讲解员说，那家卖玉手镯的商店是国营商店，所以质量方面不用担心。其实不管真和假，给老妈一个心理寄托。玉的功效这种东西，信则有，不信则无。 除此之外，终于在工作之前去了婷婷家，完成了这件必须完成的事情，顺便当作出去旅游了一次。东北的景色果然跟西安和家里不大一样，看不到边的平原。只可惜五一时间太紧，没有多待几天，只是在路过哈尔滨的时候逛了一下中央大街，拍了一张到此一游的照片。 以后怕是没有这么长的时间可以用来旅游了。 四 因为租房子要用到公司的自如服务费折扣，所以提前确定了公司的入职时间。第一次租房子，直接在自如上租的，好像没有被社会敲打。婷婷说房子地理位置还不错，附近的配套设施还挺齐全的。离公司近，旁边有个城中村，买菜买水果都很方便。 最终赶在6月末入职，成为了一名社畜。Leader和mentor人都不错，挺好沟通的，同事也很nice。大概大家都是程序员，相处起来比较容易。总的来说，入职这两周体验还不错。 新的环境，新的人，自己依旧要加油~","tags":[{"name":"总结","slug":"总结","permalink":"https://KingsFish.github.io/tags/总结/"},{"name":"2019","slug":"2019","permalink":"https://KingsFish.github.io/tags/2019/"}]},{"title":"Leetcode 507 Perfect Number","date":"2019-07-11T15:44:35.000Z","path":"2019/07/11/Leetcode-507-Perfect-Number/","text":"晚上赶在睡觉之前AC的，好久没有刷过题目了。题目描述如下： We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself.Now, given an integer n, write a function that returns true when it is a perfect number and false when it is not.Example:Input: 28Output: TrueExplanation: 28 = 1 + 2 + 4 + 7 + 14 题目大意是，给定一个数字，判断该数字是否是完美数字，完美数字的定义是，该数字等于所有约数的和。 题目不是很难，可以直接暴力搜索，遍历找到该数字的约数，求和再比较即可。但是如果直接暴力搜索，我推测一般会超时。所以最好进行一定的优化。 假定给定数字为num，遍历的数字为i。明显可知，[num / i, num]这个范围内的数字不可能是num的约数了，因此，每次i增加时，可以同时更新中止条件，这样能省下来很大一部分时间，具体代码如下： 1234567891011121314151617181920class Solution &#123; public boolean checkPerfectNumber(int num) &#123; // 1为特例，需要额外处理 if (num == 1) &#123; return false; &#125; int sum = 1, i = 2, j = num; while(i &lt; j) &#123; // 更新j j = num / i; if (num % i == 0) &#123; // i是num的公约数，那么j也是公约数 sum += i; sum += j; &#125; i++; &#125; return num == sum; &#125;&#125; 最终提交结果AC，超过了96.47%的提交，但是占用内存较多，不知道是什么原因（也不知道内存占用这项数据什么时候上线的）。","tags":[{"name":"Brute Force","slug":"Brute-Force","permalink":"https://KingsFish.github.io/tags/Brute-Force/"}]},{"title":"Android中的框架模式：MVC&MVP&MVVM","date":"2019-05-13T14:48:03.000Z","path":"2019/05/13/Android中的框架模式：MVC-MVP-MVVM/","text":"最近在实验室内部做了一次分享，主要内容是Android开发中常使用的三种软件框架模式，MVC、MVP和MVVM，另外写了一个小Demo来演示这几种模式的实际写法，在此一并发到博客上。 要声明的是，对于软件框架模式，每个人有自己的理解，另外模式也有多种变形，可能会与本文中的不完全一致，因此本文阐述的是我自己对这几个模式的理解。 软件框架模式什么是软件框架模式 软件框架模式是软件架构的设计理念，一个通用的、可重用的解决方案，用于解决在给定上下文中的软件体系结构问题 软件框架模式即为软件的结构设计，对于一个特定场景下的问题，如何组织和编写软件解决这个问题。就像人类要组织一场活动，如何安排场地和人员以完成活动就是活动的结构设计。 良好的软件框架模式意味着优秀的软件架构，一般具有以下几个优点： 框架中各部分模块关系清晰，职责和功能划分明确，功能模块易于复用，降低开发难度 每个模块和其他模块之间关联度低，便于单元测试 耦合度低，程序灵活，应对新变化如新增需求或者修改需求时便于软件维护 很多人会把软件框架模式和软件设计模式混淆，个人认为，这两者都是软件从业人员经验的总结。但相对而言，软件设计模式更像是编程过程中局部使用的编程技巧，而框架模式则负责整个软件框架，处于全局的视角位置。 常见的软件框架模式分层模式 分层模式示意图 「分层模式」是最常见的软件框架模式，很多组织架构和这种模式十分相似。该模式将软件分成若干个水平层，每一层都有特定的角色和职能，代表着应用的某一些功能，不需要知道其他层的细节，层与层之间通过接口通信，OSI的七层和TCP/IP的5层协议都应用了这种模式。 事件总线模式 事件总线模式示意图 「事件总线模式」主要用于处理事件，包括4个主要组件：事件源、事件监听器、通道和事件总线。对于不同事件源，产生的事件不同，这些事件都会发布到事件总线上的特定通道上。事件监听器器订阅特定的通道，每当有新事件发生时，订阅了该事件的监听器就可以通过订阅的通道得知该事件，从而做一定处理，每个监听器也可以对多个不同的事件进行监听。事件总线模式和设计模式里的发布订阅模式有一定相似之处。 微核架构 微核架构示意图 「微核架构」也称为插件化应用模式，由薄核心和多个功能插件组成。这种模式可以通过插件的形式添加额外的特性到核心系统中，提供了很好的扩展性，也使得新特性与核心系统隔离开。 一般来说，核心提供了特定场景下的通用业务逻辑流程，而插件模块则根据这些规则实现具体的业务逻辑，一个例子是FreeSwitch。FreeSwitch是一个软电话交换系统，提供了软电话的通用逻辑，如话机两端先进行信令的沟通然后通过这个流程，详细的信令协议则由各插件实现，如SIP协议，H323协议等等，还有语音编解码的具体过程，都是由各语音编码插件完成，FreeSwitch只是提供了整体处理流程。 微服务架构「微服务架构」提倡将大而全的应用功能拆分成以服务组件为单位的小模块，每个服务组件的服务能力粒度有大有小，小到一个单一的字符串提取，大到一个完整的计费系统。5G目前使用的就是微服务架构，将运营商的多种功能拆分成小功能单元，每一个新的应用都可以调用不同能力的服务组件以实现自身的功能。通信也在往互联网软件的方向发展。 模型-视图-控制器模式 MVC模式示意图 「模型-视图-控制器模式」也即「MVC模式」。这个模式多用于GUI程序的开发，如前端、iOS和Android。MVC模式将软件分成三个层级，模型（Model）、视图（View）和控制层（Controller）。模型包含核心功能和数据，视图展示信息，控制器处理用户输入。这个模式也是本篇文章的主要内容。 MVC模式MVC模式介绍MVC模式主要分为三个部分，Model、View和Controller。 模型持有所有的数据、状态和程序逻辑，一个模型可以有不同的多个视图表现形式，复用性高。 视图是用户看到并与之交互的页面，通常直接从模型中取得它需要显示的状态与数据，一个视图往往有一个相应的控制器，理论上也可以同不同的模型相关联 控制器位于视图和模型中间，负责接受用户的输入，将输入进行解析并反馈给模型 下图是MVC模式的一个流程示例。View层有用户点击，Controller层接收到点击事件，做简单处理之后向Model层发送请求，Model层中主要的程序逻辑对接收到的数据进行计算等操作，得到结果后再通知View层进行视图更新。 MVC流程 以一个计算器为例，如果要用MVC模式设计软件，则View层负责设计和绘制界面上的数字和运算符号按钮，Controller层响应点击事件，处理视图层传递的数据，并将数据传递给Model层，Model层通过控制层得到输入的数字和运算符，并对数据进行计算，最终将计算结果传递给View层进行视图更新。 计算器 当用户点击7 * 9这三个按钮时，Controller层接收到这三个按钮的点击事件，然后将这三个按钮对应的数字和运算符传递给Model层进行计算，Model层计算得到最终结果为63，随之将63这个数字传递给View层进行展示。 这就是MVC模式在计算器这个软件中的应用。这样分离之后，整个软件耦合度大大降低，软件修改和功能复用方便了很多。如果对计算器界面不满意，那么只需要修改View重新设计界面；如果想在其他平台如Android平台复用，Model包含了主要的程序逻辑，直接将Model层复用即可，Android端只需要重写View层和Controller层即可，整个软件灵活性大大增强。 在Android开发中的应用Android开发其实天生就是MVC模式，如下图所示： Android开发对应各层 其中，XML层作为View层，定义视图的层级；Activity作为Controller层，接收视图的点击等效果，然后将数据请求等发送给Model层；Model层负责从网络或者数据库中获取数据。以实现下图的效果为例，界面上有一个按钮，点击按钮显示一条Toast，具体显示的消息从远端获取。 示意图 整个流程过程如下图所示，View层控制页面布局，Controller层收到点击事件，处理之后向Model层获取数据，Model层获取数据，获取成功通知View层更新视图。 流程图 具体实现中，涉及到通知方式的问题，Android中有很多方法可以解决这个问题，这里使用接口回调。 首先定义回调接口StringCallback，里面有一个回调方法。 回调接口代码 XML定义按钮等页面布局。 XML布局代码 Activity实现了回调接口StringCallbcak，显示Toast消息，同时监听按钮的点击事件，当按钮被点击的时候，向Model层获取数据，同时将回调对象传入。 Activity布局代码 Model层向远端获取数据，这里为了方便起见，直接使用固定的字符串。数据获取获取成功后，通知View层更新视图，使用传入的回调对象进行操作。 Model层代码 MVC模式在Android中实现大概就是这个框架。不过实现中存在一个问题，Model层实际应该向View通知更新视图，但在这里，通知的接受者实际上是Activity，也就是Controller。这么做的原因在于，XML对视图的控制能力是在太弱，只能写一些静态的视图布局，动态的添加和修改等操作还得Activity完成。因此，这里的框架更像是下图所展示的模式： 实际的模式 这样的话，业务逻辑都放到了Model层，Model层已经解耦，但是Controller层承包了View层的很多工作，耦合性依然存在。因此，出现了MVC模式的演化版本，MVP模式。 MVP模式MVP模式介绍与MVC类似，MVP模式也主要分为三个部分，Model、View和Presenter。 模型持有所有的数据、状态和程序逻辑，一个模型可以有不同的多个视图表现形式，复用性高。 视图是用户看到并与之交互的页面，一个视图往往有一个相应的表示层，理论上也可以同不同的模型相关联 表示层位于视图和模型中间，负责接受用户的输入，将输入进行解析并反馈给模型 下图是MVC模式的一个流程示例。View层有用户点击，Presenter层接收到点击事件，做简单处理之后向Model层发送请求，Model层中主要的程序逻辑对接收到的数据进行计算等操作，得到结果后再通知Presenter层，随后Presenter再通知View层进行视图更新。 MVP模式 以一个计算器为例，如果要用MVP模式设计软件，则View层负责设计和绘制界面上的数字和运算符号按钮，Presenter层响应点击事件，处理视图层传递的数据，并将数据传递给Model层，Model层通过控制层得到输入的数字和运算符，并对数据进行计算，最终将计算结果传递给Presenter层，Presenter层接收到数据后，再通知View层进行视图更新。在某种意义上来说，MVP和代理模式有些类似。 计算器 当用户点击7 * 9这三个按钮时，Presenter层接收到这三个按钮的点击事件，然后将这三个按钮对应的数字和运算符传递给Model层进行计算，Model层计算得到最终结果为63，随之将63这个数字传递给Presenter层，Presenter层接收到结果，通知View层进行展示。 这就是MVP模式在计算器这个软件中的应用，这个模式和MVC模式最大的区别在于，Model层和View层不能直接通信，传递数据等操作都需要Presenter层介入才能完成。 在Android开发中的应用以实现和MVC模式中相同的界面布局为例，界面上有一个按钮，点击按钮显示一条Toast，具体显示的消息从远端获取。 示意图 整个流程过程如下图所示，View层控制页面布局，Controller层收到点击事件，处理之后向Model层获取数据，Model层获取数据，获取成功通知View层更新视图。 流程图 具体实现中，涉及到通知方式的问题，Android中有很多方法可以解决这个问题，这里使用接口回调。在MVP模式的实现中，一共有两次回调用以通知，分别是Model层通知Presenter层和Presenter层通知View层。因此，一共需要定义两个回调接口，分别由Presenter层和View层来实现。 首先定义两个回调接口，里面有两个方法。 View层接口](17.jpg) ![Presenter层接口 XML部分代码与MVC中一致，在这个实现中，Activity和XML共称为View层，XML负责静态，Activity负责动态，同时需要实现View层接口，并在接收到按钮点击事件时调用Presenter层的功能。 Activity代码 Presenter层实现了一个通过Model层获取数据的方法，同时需要实现Presenter层接口，供Model层回调。 Presenter代码 Model层向远端获取数据，这里为了方便起见，直接使用固定的字符串。数据获取获取成功后，通知Presenter层更新数据，使用传入的回调对象进行操作。Presenter层接收到通知后，也通过传入的View层回调对象进行操作。 Model层代码 示例所实现的功能太少，所以现在看来代码略显繁琐，但是代码层次分明，便于扩展。 其实，无论是MVC还是MVP模式，都有一个很重要的功能实现是将新的数据（Presenter或Controller层）更新到视图（View层）上。如果有框架能够自动完成这个工作，那么能节省很大一部分工作，开发者可以专注于数据更新和逻辑处理。因此，出现了MVVM模式。 MVVM模式MVVM模式介绍MVVM模式则是将MVP模式中的Presenter改成了ViewModel层，负责的功能类似，区别在于与View层的双向绑定。 下图是MVVM模式的一个流程示例。View层有用户点击，VM层通过双向绑定得知，做简单处理之后向Model层发送请求，Model层中主要的程序逻辑对接收到的数据进行计算等操作，得到结果后再通知VM层。VM数据更改之后，View层通过双向绑定，从而得知数据更新，并进行视图更新。 MVVM模式 MVVM模式一般很少会自己实现，有现成的框架。前端有Vue.js，是一个提供了MVVM模式中数据双向绑定的Javascript库。Android方面，Google提供了Databinding库。 DataBindingDataBinding是谷歌官方发布的一个框架，顾名思义即为数据绑定，是MVVM模式在Android上的一种实现，用于降低布局和逻辑的耦合性，使代码逻辑更加清晰。 DataBinding其实并没有实现新的API来完成双向绑定，只是对原有API的封装，如findViewById()和setText()，亦或是click事件，这些都被框架隐藏起来了。 至于这些事件的触发，例如View层接收到点击事件并通知ViewModel层，则是使用发布订阅模式实现的，如下图： DataBinding实现 每当View层更改时，ViewModel层通过订阅收到通知；每当ViewModel层更改时，View层也会通过订阅收到通知，这样就实现了双向绑定。 这里可能会出现一个循环问题，假设其中某一层A改变，那么另外一层B得到通知随之改变，这会导致A层得到通知，A层也改变，循环往复出现问题。 DataBinding通过前后数据对比来决定是否更新，假设View层需要更新文本信息（如TextView），则DataBinding会对比当前的文本和更新的文本，如果不一致则进行更新操作；如果相同，则不做任何操作。其他的控件也有类似的判定操作，这样就解决了数据双向绑定中的循环问题。 在Android开发中的应用以实现和MVP模式中相同的界面布局为例，界面上有一个按钮，点击按钮显示一条Toast，具体显示的消息从远端获取。 示意图 整个流程过程如下图所示。 流程图 DataBinding因为有现成的框架，因此这里就不贴具体实现的代码了。 总结安卓开发中MVC模式存在的耦合问题在其他开发中可能不存在，各个模式之间也没有什么优劣之分，只有适合与否的问题。整体而言，在不考虑框架的前提下，安卓开发中个人使用MVP模式较多。","tags":[{"name":"Android","slug":"Android","permalink":"https://KingsFish.github.io/tags/Android/"},{"name":"MVC","slug":"MVC","permalink":"https://KingsFish.github.io/tags/MVC/"},{"name":"MVP","slug":"MVP","permalink":"https://KingsFish.github.io/tags/MVP/"},{"name":"MVVM","slug":"MVVM","permalink":"https://KingsFish.github.io/tags/MVVM/"}]},{"title":"近况","date":"2019-01-23T09:22:13.000Z","path":"2019/01/23/近况/","text":"距离上一篇博客更新已经一个月了，聊聊最近做了些什么，也算是个一月总结吧。 如果没有在印象笔记里记录每天的生活，我现在怕是又会觉得自己荒废了这个月。 一 离交论文的时候越来越近，一月份终于下定决心开始写专利。跟老师讨论了大的框架，没想到他的想法和我的有一些类似的地方，都是分成了两个部分。可能他也觉得直接一步到位难度太大，根本没法做出来，因为训练集的数据也不好采集。 花了大概一个礼拜写完，包括大框架和具体的细节，包括网络的结构和特征的选取，当然这两个都不是什么很难的问题。改完老师给了我一些修改意见，明年还得去专利办「挨骂」。 有点想不明白的是，明明是自己掏钱去专利办改专利，到了那里却要被改专利的老师说这说那。怪不得现在越来越多的实验室选择走校外代理改专利，写好之后直接发给代理，自己就不用操心了。 二 闲着没事处理了一下vps对外开放的端口，之前基本所有端口都是对外开放的，我很惊讶自己居然没有受攻击。其实之前给北京那边做项目的时候就已经意识到vps大部分端口是对外开放的，只是自己比较懒没动。 当然这件事情的起因是赵乐需要一个扩展视野的工具。最近资金紧张，没想到合租的哥们经济比我更紧张。这几个月一直都是我自己一个人在承担费用，有点扛不住。有人帮忙负担轻松了很多，不过还是遏制住了自己想要大力推广多找人合租的想法，还是找信得过的人比较好，不然出事了那才是真麻烦。 在运维的道路上又进了一步。 三 在星球看见别人推荐了「网易蜗牛读书」这个app，下载试用了一下，发现还不错。 「网易蜗牛读书」每天只有一个小时的免费读书时长，看起来很短，但是正如他的slogan所述，「时间出新知」，只要坚持下去，你会发现阅读量会越来越多。 另外，对于大多数人来说，每天一个小时的阅读时间已经足够。就我自己的体验而言，这两周每天的 1 小时基本足够，中间也有几天没用完的情况。 「网易蜗牛读书」里面的很多书都是免费的，排版也不错，比起之前需要自己到处搜索mobi电子书然后放到手机用kindle看体验好太多。不过还是有一些书需要开通会员才能看，当然这也有免费的方法。 阅读时长每增加一个小时能得到一个蜗牛壳，每本书都可以用一定的蜗牛壳换，包括会员才能看的书，不过这方法对于我这种阅读速度较快的人来说就有点亏了。 最近在读「明朝那些事儿」。这本书之前看过一点，但是后来没时间看就放弃了。不得不说感觉在蜗牛阅读要比在kindle上看书要好，目前已经看到了第三册。历史还是挺有趣的，并不是流水账一般某年某月某日，某人于某地打败某人，或者说某年某月某日某皇帝登位，称眀某宗，年号某某，历史上的人和现在的人没有什么区别，他们也有喜怒哀乐，他们的生活也过得多姿多彩。 四 临近过年，最后这一周无心学习，忙着收拾东西回家，看到「网易蜗牛读书」上推了一本书叫「斯通纳」，说是适合回家路上或者春节期间阅读。这本书在豆瓣上超过两万个人评分，却依然拿到了8.8分。 这本书主要内容是作者「斯通纳」的一生经历，可以理解为自传。「斯通纳」初次出版的时间是1965年，但直到近50年后，它才登上多国图书畅销榜榜首。 他的经历和现在很多人相似，讲述的关于「寒门贵子」的故事。斯通纳是一个从农村进入大学，从而逃脱了祖辈世代务农命运的人。巨大的身份转变，给他带来了深刻的孤独——他接受的教育让他逐渐疏远土地和父母，他的出身又使他无法与娇贵的妻子达成真正的关于生活的共识，孤独以及阶级鸿沟。 不过斯通纳很幸运，最后还是找到了自己生活的意义，坚持自己的原则，并为之付出了一生。 但愿自己也能找自己的方向。","tags":[]},{"title":"2018 这一年","date":"2018-12-31T02:42:56.000Z","path":"2018/12/31/2018-这一年/","text":"公历和农历的差别总是让我很困惑。春节这个仪式还没有过去，农历总让我以为还有一阵子才是新的一年。公历却用冷冰冰的数字告诉我2019年的余额已经不足一个礼拜了，忙忙碌碌又一年。 不知道是什么时候开始养成的写总结的习惯，可能是不再写日记的时候。没有了每天对生活的记录，时间的概念变得很模糊，总得有个总结，才能让自己的记忆不显得那么空白。 一 年中曾写过一篇总结，现在看来当时的展望唯一完成的只有找到好工作这一项，其他诸如“坚持健身计划”、“学习经济学知识”的目标都消失在了我的记忆里。 为了找工作做的准备还挺多的，参加华为的大赛，刷算法题，做项目等等。找工作其实没什么，回报取决于你付出的多少，我也很惊讶自己今年能找到的工作。可能之前的基础太差了，打实基础之后更容易获得更大的成就，当然更大的因素还是今年客户端岗位的供求状况。 一个人的命运啊，当然要靠自我奋斗，但是也要考虑到历史的行程。 明年是工作的第一年，希望自己能够一如既往继续加油。 二 目前为止，博客运营已经一年半了。大部分内容是为了工作准备的算法，比如Leetcode以及”剑指offer“，剩下的就是自己的生活琐事和总结类的文章。整体来说，感觉博客内容有些偏。其实可以把这个博客当作一个产品来运营。考虑“竞品”也即别人的博客相对于自己的博客有哪些更能吸引用户的地方，想想自己博客有什么特色，而不是普普通通的一个个人博客。 之前建立博客的本意是为了自己有一个记录的地方，并不考虑浏览量以及知名度类似的数据，而现在却觉得这可能会是一个提升自己“名气”、积攒流量的地方。就像别人运营微信公众号一样，有了关注用户之后就可以做一些导流，再之后变现或者其他的动作才会有基础，另外也可以实践如何去运营一个产品，拓宽知识面的广度。 说到博客，本来在博客添加收钱码只是为了好玩，没想到却收到了打赏。虽然金额不多，但是非常高兴。 三 今年互联网寒冬严重，招聘冻结，很多公司都传出了裁员的新闻。了解的越多就越会发现光有技术远远不够。也需要懂业务，懂产品。有之前实习的同事说身边有人砍掉了，其实他们技术都还不错，只是业务做的不好。除非自己在公司的技术地位到了不可或缺的地步，否则都有可能被裁。 这阵子在知识星球看了“钱钰”写的一篇文章，大概说程序员有四种出路： 技术专家，技术有深有广 转管理，坑位不多 转产品，结合技术和业务 创业，难度大，所需能力非常多 考虑到现在的大环境以及以上四种出路所需的知识面和技能，自己最适合的是“技术专家”和“产品”，有时间的时候需要了解一下相关的知识。 四 这一年基本忙于工作准备以及找工作，中间因为实验室项目的事情出差了几次。期间有差补，出去长长见识。回了趟家，看了看装修的老房子。去了趟杭州，没怎么逛就回来了。杭州、南京和北京都是第一次去，相比于往年，出去的机会多了很多。 遗憾的是之前想找完工作要带父母去趟北京，到现在也还没实现。不过以后在北京工作，应该会方便很多。对于很多上一辈的人来说，去一趟天安门是他们一生的夙愿。但是不管自己父母是不是这么想，带他们来北京旅游一次也是应该的。 五 老校区附近吉祥村新开了一个大商场——MOMOPARK，这里成了我和婷婷今年最青睐的地方。吃的很丰富，以往在老城根的“甘食记肥肠粉”，凯德的“阿甘锅盔”还有益田的“守艺人”都在这里开了新店。另外，这里离“博纳影城”很近，这家电影院也是刚成为新欢，价格合适，离的也近，在MOMOPARK 吃完饭之后溜达一下就过去了。 临近年末，前几天西安下了场大雪。市区没有什么感觉，郊区比南二环冷很多，雪积的很厚。下雪那天正好给老师办事情，要去一趟新校区。顺便和一个刚考完研的学弟吃了顿饭，学弟考完研在图书馆自学office。记忆里熟的饭店不多，去了川湘会馆。 吃饭的时候谈到了女朋友这类话题，学弟说最近有点失落。考完研好不容易鼓起勇气跟妹子要了联系方式，却发现妹子对他不感兴趣。与此同时却有一两个妹子跟学弟要了联系方式，我一时不知道该恭喜他还是安慰他。 毕业之后学校变化很大，即将盖起来的网信院大楼，以往的工训中心几根大柱子也被围起来修整了一番，更不用说东门已经拆完，北门也只剩一点点。以前和婷婷经常去吃的北门鸡王爷，小店还在，老板也还是那个人，但是味道不复以前，只能说声可惜，新校区最后想念的滋味也没了。 热腾腾和下雪最为搭伴。去年的这几天正是节气“大雪”，飘着一层辣椒油的粉汤羊血和外面的大雪相得益彰。不过婷婷对粉汤羊血好像不怎么感兴趣，新校区回来就叫上婷婷去了另外一家店，澄城水盆羊肉。 婷婷很喜欢他家的月牙饼，刚烤出来，冒着热气，咬一口齿唇留香，配上熬烂的的羊肉，再喝上一口汤，简直是享受。店里坐的很满，熙熙攘攘的，大概都是些下雪天溜出来享受生活的人。 六 口红效应是一种经济学理论，即当面对金融危机时，消费者将更愿意购买成本较低的奢侈品，而不是皮毛大衣。例如，人们会购买昂贵的口红。 根据相关数据显示，2018年口红销售额增长了97%。 经济形势不好，连累股市，今年亏损有点惨。作为非经济学专业的人不会去深究根本原因是什么，但是股市大跌是从中美贸易站开始的，打了大半年也不见好，很多人把这次大跌看成人生中大赚一笔的少数机会。明年会怎么样谁也不知道，低头捡点便宜的筹码，保持好现金流，耐心等待反弹的时候。 七 年中的时候被婷婷强行凑单养了一盆文竹，寄过来的是懒人浇水盆，也就是自吸水的那种。后来花店老板告诉我才发现这样对文竹不好，文竹喜湿但根不能长期放在湿润的土壤里，容易烂根。另外，文竹需要散射光，但不能直射。文竹一直被我放在实验室没有晒过太阳，缺少光合作用的文竹一直保持嫩绿色。 趁着刚汇报完有时间，搞了点土改装了一下花盆，买了个底座。晒了两天太阳之后文竹迅速长出了新叶子，虽然老的叶子还是有一些黄，但是新生的力量已经成长起来了。 愿我的 2019 也能像文竹一样向上生长。","tags":[{"name":"总结","slug":"总结","permalink":"https://KingsFish.github.io/tags/总结/"},{"name":"2018","slug":"2018","permalink":"https://KingsFish.github.io/tags/2018/"},{"name":"复盘","slug":"复盘","permalink":"https://KingsFish.github.io/tags/复盘/"}]},{"title":"Leetcode 962 Maximum Width Ramp","date":"2018-12-23T03:31:52.000Z","path":"2018/12/23/Leetcode-962-Maximum-Width-Ramp/","text":"今天有时间参加了一下Leetcode Weekly Contest 116，参加的比较晚，完成两题之后没时间做其他的了，在这里写一下完成的两题中的一题。题目如下： Given an array A of integers, a ramp is a tuple (i, j) for which i &lt; j and A[i] &lt;= A[j]. The width of such a ramp is j - i. Find the maximum width of a ramp in A. If one doesn’t exist, return 0. 题目意思是这样，给定一个数组A，将符合如下条件数字对(i, j)定义为ramp： i, j 是数组A中的下标 A[i] &lt;= A[j] 并定义ramp的距离是j - i，求数组中最大的ramp距离，如果不存在则返回 0。 这题思路其实很简单，直接遍历即可。对于每一个固定的下标i，从数组的右边开始遍历，直到找到一个比A[i]大的数字A[j]即可，同时记录距离j - i。另外，如果最大距离已经超过了下标i可能的最大距离，也即n - 1 - i，则直接退出循环，因为这个时候不可能找到比当前距离更大的数字了。 举例：给定数组[6,0,8,2,1,5]，当i = 2时，之前记录的最大距离是5 - 1（i = 1的时候），而i &gt;=2的情况下，可能出现的最大ramp也不会超过4，所以这个时候可以直接退出循环，4即为最大ramp距离。 具体实现的代码如下： 1234567891011121314151617class Solution &#123; public int maxWidthRamp(int[] A) &#123; int n = A.length; int max = 0; for (int i = 0; i &lt; n; i ++) &#123; if(max &gt;= n - 1 - i)&#123; break; &#125; for (int j = n - 1; j &gt; i; j --) &#123; if (A[j] &gt;= A[i]) &#123; max = Math.max(max, j - i); &#125; &#125; &#125; return max; &#125;&#125; 这种思路的最差时间复杂度是O(n^2)，最优时间复杂度是O(1)，空间复杂度是O(1)。","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"}]},{"title":"剑指offer 11 数值的整数次方","date":"2018-12-21T03:34:48.000Z","path":"2018/12/21/剑指offer-11-数值的整数次方/","text":"题目： 实现函数double power(double base, int exponent)，求 base 的 exponent 次方。不得使用库函数，同时不需要考虑大数问题。 这个问题最简单的方法是暴力求解，循环exponent次，每次乘于base，最终结果即为所求。注意负数，代码如下 123456789101112131415161718public class Solution &#123; public double Power(double base, int exponent) &#123; if (base == 0.0) &#123; return 0; &#125; if (exponent == 0) &#123; return 1; &#125; double res = 1; int minus = exponent &gt; 0 ? 1 : -1; exponent = exponent &gt; 0 ? exponent : -exponent; while (exponent &gt; 0) &#123; res *= base; exponent --; &#125; return minus &gt; 0 ? res : 1 / res; &#125;&#125; 时间复杂度是O(n)。当然这种思路并不高效，做了很多重复工作。比如a^32完全可以由a^16平方得到，a^16可以由a^8平方得到，以此类推直到a^1；而奇数情况下则只需要再乘一次a即可。而由这个思路则可以得到如下打码： 123456789101112131415161718192021public class Solution &#123; public double Power(double base, int exponent) &#123; if (base == 0.0) &#123; return 0; &#125; if (exponent == 0) &#123; return 1; &#125; double res = base; int minus = exponent &gt; 0 ? 1 : -1; exponent = exponent &gt; 0 ? exponent : -exponent; int ex = exponent; while (ex = ex &gt;&gt; 1) &#123; res *= res &#125; if(exponent &amp; 1 == 1) &#123; res *= base; &#125; return minus &gt; 0 ? res : 1 / res; &#125;&#125; 这种思路的时间复杂度是O(logn)，相比第一种解法简单了很多。","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"}]},{"title":"剑指offer 10 二进制中1的个数","date":"2018-12-09T02:33:53.000Z","path":"2018/12/09/剑指offer-10-二进制中1的个数/","text":"题目： 请实现一个函数，输入一个整数，输出该数字二进制表示中 1 的个数。例如把 9 表示成二进制是 1001，有 2 位 是1。因此如果输入 9，该函数输出 2。 常规思路很清晰，将该数字和 1 按位与，如果结果是 1 则表明该数字最右一位是 1，如果结果是 0 则表明该数字最右一位是 0。不断将该数字右移，最终即可得到结果。代码如下： 123456789101112public class Solution &#123; public int NumberOf1(int n) &#123; int res = 0; while (n != 0) &#123; if ((n &amp; 1) == 1)&#123; res ++; &#125; n &gt;&gt;&gt;= 1; &#125; return res; &#125;&#125; 按照Java的结构，一个int型数字最长32位，所以只需要循环32次即可求得结果。 当然有一个更简单的解法，把一个整数减去 1，再和原整数做按位与运算，会把该整数最右边一个 1 变成 0。那么一个整数的二进制表示中有多少个 1，就可以进行多少次这样的操作。 例如数字 9（1001）： 1001 &amp; (1001 - 1) = 1000 1000 &amp; (1000 - 1) = 0 一共进行两次，运算进行的次数就是最后的结果，代码实现如下： 12345678910public class Solution &#123; public int NumberOf1(int n) &#123; int res = 0; while (n != 0) &#123; res ++; n = (n - 1) &amp; n； &#125; return res; &#125;&#125;","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"}]},{"title":"剑指offer 09 斐波那契数列","date":"2018-11-26T14:16:01.000Z","path":"2018/11/26/剑指offer-09-斐波那契数列/","text":"题目： 写出一个函数，输入 n，求斐波那契数列的第 n 项。斐波那契数列的定义如下：f(n) = 0, n = 0 1, n = 1 f(n - 1) + f(n - 2), n &gt; １ 斐波那契数列相对来说是比较熟悉的一个概念，主要思路是当前项的值为前两项的值之和，所以只需要一步一步保存并计算之前的值即可，代码如下： 1234567891011public class Solution &#123; public int Fibonacci(int n) &#123; int first = 0, second = 1, i = 0; while (i &lt; n)&#123; second = first + second; first = second - first; i ++; &#125; return first; &#125;&#125; 时间复杂度为O(n)，空间复杂度为O(1) 问题扩展 一只青蛙一次可以跳上一级台阶，也可以跳上两级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。 这个问题可以逐步分解，考察第 i 级台阶，明显第 i 级台阶有两种跳法，分别是从第 i - 1 和 i - 2 级台阶跳上来，所以跳上 i 级台阶的跳法应该是 i - 1 级和 i - 2 级台阶跳法的总和，于是有f(i) = f(i - 1) + f(i - 2），其实就是斐波那契数列。代码如下 1234567891011public class Solution &#123; public int JumpFloor(int target) &#123; int first = 1, second = 1, i = 0; while (i &lt; target)&#123; second = first + second; first = second - first; i ++; &#125; return first; &#125;&#125; 其实这个题目有一点动态规划的意思，不过是简化的版本，不需要存储所有状态，只需要前两个即可。动态规划则可能需要存储所有状态的数据，用以计算之后的状态。","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"},{"name":"递归","slug":"递归","permalink":"https://KingsFish.github.io/tags/递归/"}]},{"title":"剑指offer 08 旋转数组的最小数字","date":"2018-11-06T04:21:04.000Z","path":"2018/11/06/剑指offer-08-旋转数组的最小数字/","text":"题目： 把一个数组最开始的若干个元素搬到数组的末尾，我们称之外数组的旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组｛3,4,5,1,2｝为｛1,2,3,4,5｝的一个旋转，该数组的最小值为1。 这道题最简单的方法当然是直接遍历，然后找出最小的即可，时间复杂度是O(n)。但是这种方法并没有利用到旋转数组的特性，更好的方法是用类似于“二分查找”的方法。 旋转数组是有原先的有序数组做一定处理得到的，所以旋转数组以最小元素分割，两边都具有有序性，根据这个特性可以不断缩小查找的范围。 类似于二分查找，不断比较中间的值mid和最右边的值hi，如果mid大于hi，说明最小元素肯定在这两个数之间，也即右边；如果mid等于hi，那么我们无法判断最小元素在哪一边，只能按照顺序查找，将hi减一；如果mid小于hi，说明最小元素肯定在另外一边，也即左边，这个时候只需要更新一下hi即可。 1234567891011121314151617181920import java.util.ArrayList;public class Solution &#123; public int minNumberInRotateArray(int [] array) &#123; if(array.length == 0) &#123; return 0; &#125; int lo = 0, hi= array.length - 1; while(lo &lt; hi) &#123; int mid = lo + (hi - lo) / 2; if (array[mid] &gt; array[hi]) &#123; lo = mid + 1; &#125; else if(array[mid] == array[hi]) &#123; hi = hi - 1; &#125; else &#123; hi = mid; &#125; &#125; return array[lo]; &#125;&#125; 上述思路最佳的时间复杂度是O(logn)，最坏复杂度是O(n)，这道题算是二分查找的一个变形。","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"},{"name":"数组","slug":"数组","permalink":"https://KingsFish.github.io/tags/数组/"}]},{"title":"Leetcode-146-LRUCache","date":"2018-10-16T07:13:57.000Z","path":"2018/10/16/Leetcode-146-LRUCache/","text":"题目： Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.Follow up:Could you do both operations in O(1) time complexity? Example:LRUCache cache = new LRUCache( 2 /* capacity */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // returns 1cache.put(3, 3); // evicts key 2cache.get(2); // returns -1 (not found)cache.put(4, 4); // evicts key 1cache.get(1); // returns -1 (not found)cache.get(3); // returns 3cache.get(4); // returns 4 题目大意这是一个经典的题目，设计一个LRUCache。LRU 是一个缓存算法， 在实际编程中使用的很广泛，比如页面置换算法和图片缓存。 思路思路其实就是理解LRU这个算法，然后按照思路去实现就好。 Java其实已经实现了这个算法，重写LinkedHashMap的removeEldestEntry方法，给定删除元素的触发条件即可。至于LinkedHashMap内部是如何实现的这里不再赘述，有兴趣的可以去看看源码。这里我使用了另外一种实现方式，HashMap加双向链表。 对外的API主要有两个，put和get，其实应该还有一个clear方法，用于清空整个缓存，这个方法实现较为简单，只需要把双向链表首尾置空，然后初始化HashMap即可。 其实LRUCache里还有两个很重要的内部方法moveToFirst和trimToSize，moveToFirst主要完成将元素放到队首的操作，trimToSize则将缓存数量恢复到额定大小。 get按照LRU的原理，每次执行get方法先检查缓存里是否存在，不存在则直接返回空，存在则将该元素放到双向链表的队首并返回。 如果没有HashMap的话，检查缓存是否存在是一个比较消耗时间的操作，需要从队首开始遍历一直到队尾，用HashMap能加速访问。 putput方法比较复杂，要做的操作很多。 首先检查缓存里是否存在，如果存在则更新value值将其放到队首；如果不存在则新建一个key-value对象，将这个新建的对象放到HashMap和双向链表的队首，之后还需要检查当前数据数量是否超过缓存大小，如果超过了则需要去除队尾的数据。 代码实现这里按照Leetcode上的要求完成，key和value都是Integer类型，但实际使用编写的时候最好使用泛型。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102class LRUCache &#123; private HashMap&lt;Integer, Node&gt; map; private int capacity = 0; private int size = 0; Node head, tail; public LRUCache(int capacity) &#123; this.capacity = capacity; map = new HashMap&lt;&gt;(capacity); &#125; public int get(int key) &#123; Node tmp = map.get(key); if(tmp == null) &#123; // 该元素不存在 return -1; &#125; else &#123; // 该元素存在，放到队首并返回 addToHead(key); return tmp.val; &#125; &#125; public void put(int key, int value) &#123; Node tmp = map.get(key); if(tmp == null) &#123; // 元素不存在，新建键值对，并更新缓存数量 tmp = new Node(key, value); map.put(key, tmp); size ++; &#125; else &#123; tmp.val = value; &#125; // 无论元素是否存在，都需要将其放到队首 addToHead(key); // 检查缓存数量是否超过容量 if(size &gt; capacity) &#123; trimToSize(); &#125; &#125; // 将元素放入队首操作，情况较多 private void addToHead(int key) &#123; Node tmp = map.get(key); // 元素本来就在队首 if(tmp == head) &#123; return; &#125; // 元素在队尾，更新队尾指针 if (tmp == tail) &#123; tail = tail.pre; &#125; // 重新建立双向链接 if(tmp.pre != null) &#123; tmp.pre.next = tmp.next; &#125; if(tmp.next != null) &#123; tmp.next.pre = tmp.pre; &#125; // 放队首操作 tmp.pre = null; tmp.next = head; if(head != null) &#123; head.pre = tmp; &#125; head = tmp; // 特殊情况，第一次添加数据，需要更新队尾 if(tail == null) &#123; tail = tmp; &#125; &#125; private void trimToSize() &#123; // 删除队尾数据 size --; map.remove(tail.key); tail = tail.pre; tail.next = null; &#125; class Node&#123; // 数据实体 int val = 0; int key = 0; Node next; Node pre; public Node(int key, int val) &#123; this.val = val; this.key = key; next = null; pre = null; &#125; &#125;&#125;/** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ Leetcode运行时间不稳定，一样的代码两次提交运行时间一样，这里放一张时间更短的。 运行时间","tags":[{"name":"LRU","slug":"LRU","permalink":"https://KingsFish.github.io/tags/LRU/"},{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"},{"name":"HashMap","slug":"HashMap","permalink":"https://KingsFish.github.io/tags/HashMap/"}]},{"title":"剑指offer-07-用两个栈实现队列","date":"2018-10-13T02:28:26.000Z","path":"2018/10/13/剑指offer-07-用两个栈实现队列/","text":"题目： 用两个栈实现一个队列，队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入结点和队列头部删除结点的功能。 栈和队列相信大家都用得很熟了。栈是一种FILO的数据结构，而队列则是一种FIFO的数据结构，这个题目要求使用两个FILO的数据结构来实现FIFO。 思路其实并不难，主要需要实现两个API，一个是入队，一个是出队。主要思路是用栈 A 保存倒序的数据，而栈 B 保存正序的数据。入队时将数据放入栈 A 中，出队时将栈 B 弹栈即可。那么问题就在于如何将倒序的数据转换成正序的数据，其实只需要将栈 A 中的数据不断弹栈并压入栈 B 即可。入队时将数据不断压入栈 A，此时栈 A 存储的是倒序，当碰到出队请求时，先检查栈 B 是否为空，不为空则直接输出栈 B 的栈顶。若为空则将栈 A 里面的数据不断弹栈，然后在压入栈 B，这个时候栈 B 里面的顺序就是正确的了，这个时候只需要将栈 B 的栈顶输出即可，如下图所示。 入队和出队 有了思路之后代码实现就比较简单了。 12345678910111213141516171819202122232425262728293031import java.util.Stack;public class Queue&lt;T&gt;&#123; Stack&lt;T&gt; a; Stack&lt;T&gt; b; public Queue()&#123; a = new Stack&lt;&gt;(); b = new Stack&lt;&gt;(); &#125; // 入队操作 public void appendTail(T t)&#123; a.push(t); &#125; // 出队操作 public T deleteHead()&#123; if(b.empty()) &#123; // 栈 B 为空，将 A 中的数据都放入 B中 while(!a.empty())&#123; b.push(a.pop()); &#125; &#125; if(b.empty()) &#123; // 这个时候如果 B 仍为空，说明队列里没有任何数据，此时出队是错误操作 throw new IllegalStateException(\"队列无数据\"); &#125; // 返回 B 的栈顶数据 return b.pop(); &#125;&#125; 这道题其实可以拓展延伸，比如如何用两个队列实现栈，思路都差不多，有兴趣可以自己去实现一下。","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"},{"name":"栈","slug":"栈","permalink":"https://KingsFish.github.io/tags/栈/"},{"name":"队列","slug":"队列","permalink":"https://KingsFish.github.io/tags/队列/"}]},{"title":"剑指offer-06-重建二叉树","date":"2018-10-12T07:19:02.000Z","path":"2018/10/12/剑指offer-06-重建二叉树/","text":"题目： 输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果都不含重复的数字。 前序遍历指的是先遍历根节点再分别遍历左右子节点；中序遍历指的是先遍历左子结点，其次根节点，最后右子节点。 思路很简单，先根据前序遍历的结果确定根节点，再在中序遍历的结果中查找到该节点，这样就可以切分出左右子树序列，在得到的左右子树序列中递归使用上面的方法即可构建出原来的树。 遍历序列 代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; return build(pre, in);&#125;private TreeNode build(int [] pre, int [] in) &#123; if (pre.length == 0 || in.length == 0) &#123; return null; &#125; TreeNode root = new TreeNode(pre[0]); // 寻找根节点 int pos = findRoot(in, root.val); int [] pre_tmp = copy(pre, 1, pos); int [] in_tmp = copy(in, 0, pos - 1); // 递归完成左子树的建立 root.left = build(pre_tmp, in_tmp); pre_tmp = copy(pre, pos + 1, pre.length - 1); in_tmp = copy(in, pos + 1, in.length - 1); // 递归完成右子树的建立 root.right = build(pre_tmp, in_tmp); return root;&#125;// 遍历中序遍历序列寻找根节点private int findRoot(int [] in, int val) &#123; for (int i = 0; i &lt; in.length; i ++) &#123; if (in[i] == val) &#123; return i; &#125; &#125; return 0;&#125;// 复制数组用于下一步操作private int[] copy(int [] array, int start, int end)&#123; int length = end - start + 1; int [] res = new int[length]; for (int i = 0; i &lt; length; i ++)&#123; res[i] = array[i + start]; &#125; return res;&#125; 整体而言，算法使用了O(nlogn)的辅助空间，时间复杂度是O(nlogn)。其实空间复杂度可以进一步优化，没必要使用新的数组来保存子树，只需要传递子树序列的开始和结束位置即可，不过这里我就不写了。 本来说话秋招准备之前写完大部分剑指 offer 题目的，结果发现 9 月份忙得很，现在找完了工作来填坑。","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"},{"name":"链表","slug":"链表","permalink":"https://KingsFish.github.io/tags/链表/"}]},{"title":"我的 2019 Android 秋招经历","date":"2018-10-10T02:20:03.000Z","path":"2018/10/10/我的 2019 Android 秋招经历/","text":"前言经过几个月的努力，基本上拿到了满意的offer，一直奔波在求职路上，现在终于能好好的停下来总结这段经历。 找工作确实很累，无论从生理上还是心理上，我一天最多的时候赶了 3 场面试，分布在西安的各个地方，当天回来根本不想学习；面试被虐的时候会各种怀疑自己，怀疑人生。无论如何，保持好心态最重要。 求职期间其实看了很多前人的经历，现在总结也算是给后来秋招的师弟师妹一点参考和建议，希望师弟师妹早作准备，未来拿到心仪的offer。 以下均为个人经验，可能不适用与所有人，另外鉴于个人水平有限，难免出现失误的地方，如果有欢迎提出，非常感谢。 秋招战绩先总结一下秋招战绩，岗位都是安卓开发。大部分拒笔试和面试的原因都是自己手里头已经有了更好的offer，就不去浪费人家的时间和精力了。 公司 地点 批次 结果 备注 vivo 深圳 提前批 offer 第一个 offer 老虎证券 北京 正常批 offer 个人很看好的公司 大疆 深圳 正常批 offer 土豪公司 华为 西安 优招 offer 薪资给了个惊喜 招银网络 杭州 正常批 offer 百度 北京 正常批 offer 中国银联 上海 提前批 offer 薪资今年大爆发 字节跳动 北京 正常批 offer 准备签 美团 北京 正常批 offer 薪资略失望 罗辑思维 北京 正常批 offer 个人很看好的公司，薪资也给力，以后会考虑 360 北京 正常批 offer 池 京东 北京 正常批 笔试挂 网易互娱 深圳 正常批 笔试挂 拼多多 上海 提前批 笔试挂 阿里巴巴 杭州 正常批 笔试挂 凑齐 4 个已回绝 深信服 深圳 提前批 笔试挂 英语流利说 北京 提前批 拒笔试 已有其他offer 海康威视 杭州 正常批 拒笔试 已有其他offer 去哪儿 北京 正常批 拒笔试 已有其他offer 爱奇艺 北京 提前批 拒面试 已有其他offer 好未来 成都 正常批 拒面试 面试地点是成都，已有其他offer 微众银行 广州 正常批 拒面试 面试地点是广州，已有其他offer oppo 深圳 正常批 拒面试 已有其他offer 百词斩 成都 正常批 拒面试 已有其他offer 腾讯 深圳 正常批 拒面试 与华为签约冲突，已有其他offer 科大讯飞 杭州 正常批 拒面试 已有其他offer 网易 杭州 正常批 拒面试 来了西安没叫我去面试，结果要去杭州面试 keep 北京 正常批 没消息 现场投递简历，后来没消息 搜狗 北京 提前批 没消息 贝壳 北京 正常批 一面挂 霸面 百度 北京 提前批 一面挂 手机百度，难度很大 oppo 深圳 提前批 一面挂 第一个挂的公司 阿里巴巴 杭州 提前批 一面挂 国际事业部 百度 深圳 提前批 一面挂 系统部，完全不是一个方向 网易 杭州 提前批 三面挂 去杭州面试 今年秋招提前了很多，基本上 8 月份很多大公司已经开始了，但其实最早的是大疆，4 月份有“技术分享会”，就是所谓的提前批，但是那时候基本没有人关注，也没有消息，之后就是vivo提前批，5 月底截止投递简历，然后 6 月份就面试完发了offer。我有幸参加了这个面试，拿到第一个offer，对我之后的求职信心有了很大的帮助。 我的个人情况先说一下我的个人情况，双西电通信工程专业硕士，个人感觉跟以往不一样的事是，现在找工作很多都是硕士，3 年前很多都是本科生。大三的时候，也就是 15 年移动客户端最火的时候学的安卓开发，信心满满准备找工作，被两家公司虐了之后发现自己技术是个渣，然后放弃找工作准备考研，研究生好好学技术， 3 年后再战。当然实际研究生阶段也没有按照自己当初的方向走，杂七杂八的学了很多其他的知识，比如深度学习和后端相关知识，最后还是决定选择最为熟悉的安卓开发作为求职的方向。 就业形势的个人看法今年延续去年人工智能大潮，很多人涌向了算法岗位，人多竞争也激烈，因此今年算法算是一个小年。而开发学的人相对少了人多，尤其移动客户端。 以字节跳动（今日头条）为例，官方出了一个公告，说算法相关岗位投递简历特别多，而移动客户端方向很少，因此针对这个形势出了一个政策，每个移动客户端岗位的人工作满一年之后能拿到三个月的签字费，并且不要求有移动客户端开发经验，移动客户端今年应该算是个大年。 另外我听到过小道消息说美团也很缺，基本上没得挑，面试差不多的就给offer，后来跟我谈offer的HR感觉也基本证实了这个消息，她问我能不能提前去实习，一般回答了之后就不会再往下问了，但是她问得很细，能去几个月，大概什么时候，老师态度如何等等。 总之，今年移动客户端就业形势感觉还不错，另外今年互联网企业大部分都涨了工资，不过就业形势这个东西每一年都不一样，去年是算法大年，今年就是移动客户端大年，明年谁也说不好，不过万变不离其宗，只要基础扎实，并有一两个自己非常熟悉的项目找工作肯定没问题，无需害怕竞争。 我的工作准备前文提到了我上研究生的目的，自己计划在研究生阶段好好夯实基础学习技术，因此我准备的比较早。主要分几个方面： 数据结构和算法 Java 基础，包括虚拟机相关 Android 基础和进阶 操作系统、网络等其他知识 实际项目 其他准备 数据结构和算法我升研一的暑假开始系统性的学习数据结构和算法，刚开始花了很多时间看清华大学“邓俊辉”教授的《数据结构和算法》视频课程。这里推荐一下这个视频课程，给了我很大的帮助，讲的通俗易懂，学习期间我认真的做了笔记，同时看完视频之后还会自己用Java实现（视频课程是用C++实现的），不过对于一些很难的知识点理解起来较难，我就跳过了，比如“红黑树”、KMP和BM字符串搜索算法等，不过还是建议不要丢弃这些知识，因为这些坑在我笔试的时候就出现了。 看完这个视频之后数据结构算法的基础框架搭建起来了，后来买了一本《算法（第四版）》，这本书是《算法导论》作者的弟子Robert Sedgewick写的，浅显易懂，对于基础知识而言完全足够了，并且这本书是用Java实现的，这是我买这本书的一个很重要原因。 其实数据结构和算法无论怎么看书都是不够的，因为这些知识本来就是人类在实践中不断总结出来的经验，因此仍然需要在实践中去不断使用。 大体看完了《算法（第四版）》之后我就开始刷题。我选择的OJ平台是Leetcode，这上面的题目实践性较强，很多都是Google、Facebook和Apple等大公司的题目，更适合于找工作的方向。另外，这上面discuss系统做的很不错，除了题目的典型解法之外还可以在上面找到很多很tricky的解题方法，我每次看完别人的解法都会萌生出“还有这种操作？”的想法。 另外《剑指offer》这本书也是面试必备，里面有很多经典的题目，在秋招面试的时候碰到了好几次原题。这本书大概是 4 月底去北京出差的时候开始看，之后在牛客上在线刷题做完了大概40+题，后面的题目就是看了但是没有自己写过。不得不说vivo提前批offer真的给了我很大的动力，逼着我好好复习。 还有要提一下的地方是面试常有的手撕代码环节。为了解决这个大问题，我后期刷OJ的时候开始尝试不借助IDE而在网页上直接编程。写得多了会发现其实手撕代码并不是一个难以攻克的难关，之前多刷一些题，其实手撕代码和普通在线编程差不多。 Java &amp; AndroidJava基础知识主要是一些语言特性和内置的数据结构，比如List、Map、Set和反射等，相对而言这些比较简单，大概挑重点看了一下《Java 编程思想》这本书，其他的还看了一下线程池和并发相关，因为之后的项目用到了，所以着重看了一点。 Java虚拟机部分主要看的是周志明的《深入 Java 虚拟机》这本书，不得不说这是市面上为数不多讲Java虚拟机讲的不错的书，我本科的时候大概浏览了一次，但是隔的时间久了很多知识都不记得了。另外本科的时候对于这本书的知识点并没有相关涉及，只是知道面试的时候会用上所以学一学。现在编程经验多了才知道这是个重点，现在很多技术都需要用到这些底层知识，比如“插件化”和“热修复”就需要对双亲加载模型有一定了解。 Android基础相关主要回顾了一下郭霖大神的《第一行代码（第二版）》这本书，这本书很适合入门，第一版是我的安卓入门书。 当然Android只靠这些基础肯定是不够的，我另外也看了徐宜生的《Android 群英传》，这本书里有很多实际开发中使用的技巧，很适合于面试中的场景题，另外也有一些进阶的知识如“事件分发机制”和“View 的绘制过程”等。我大概花了 3 周的时间看完，当然只实践了其中少部分的内容，因为实践起来需要大量时间，而我还需要对其他的知识查缺补漏。另外，我后来发现任玉刚的《Android 开发艺术探索》简直是面试宝典，面试时候碰上的很多进阶问题都可以在这本书里看到相关阐述，可惜这个发现有点晚，面试晚期才开始读这本书，直到现在还没有看完。 操作系统和网络这部分知识准备如果要算的话得追溯到本科了，那时候特意选了“操作系统”这门课，至于网络方面则基本没怎么担心过，因为我是通信工程专业出身的，本身学科就是网络相关。不过准备肯定还是要有的，主要是看别人的总结，这里要感谢一下一本Gitbook的几个作者，链接在此Android 校招面试指南 。这本书主要是面试问题集合，除了上述的操作系统知识之外还有很多设计模式和数据库相关，靠这本书我扛过了秋招，再次对几位作者表示感谢。 实际项目对于研究生而言，项目是一个非常重要的因素。本科生接触项目的机会较少可以理解，但研究生就实验室而言就有项目可以做。但是我的情况很尴尬，实验室的项目和我的工作方向并不对口，因此我只能想想其他的项目。 其实手里头对口的项目不多，4 月份在校时期和别人一起做了一个App，好好复习了一下项目里用的东西，也大概看了一下另外一个同伴的代码，理出项目的大体框架还有大概的实现流程等。另外项目里用的知识点一定要熟悉，不然面试会被问的很惨。 其他准备简历我的简历前前后后修改了六七个版本，综合我自己的想法和很多人的建议。个人更喜欢简洁风，所以最后做出来的简历纯黑白，连照片都没有放上去。主要分为 5 各部分，包括个人信息、教育经历、技能清单、项目经历和获得奖励，我没有把我本科的实习经历放上去所以没有实习经历那一项。 但是简洁 ≠ 简单，我简历上一些着重点如获得的奖励会加粗，标题和内容大小等都有区别，校招简历该有的内容也没少，比如教育经历、技能清单、获得奖励等，当然大头还得是项目经历。项目经历使用STAR法则来描述 S - situation，事情在什么情况下发生的，也即项目背景 T - task，有哪些任务，也即项目所承担的内容 A - action，有哪些行动，也即如何完成任务的，碰到了什么困难，如何解决的 R - result，结果如何，也即项目最终取得了什么成果 我的简历项目经历部分一共写了三个项目，包括实验室的项目、比赛和校内App。其实我之前也很犹豫要不要放不相关的项目，咨询了一些前辈之后觉得这些项目其实也可以展示你的编程和学习能力，所以我也把他们写上去了。 简历建议的话不超过一页纸，贵精不在多，写上去的东西自己一定要熟悉，很多公司都是对着简历问的，另外简历一定要有粗有细，对于重点内容可以加粗，比如App的下载量或者拿到的奖项，对于自己很熟悉的东西也可以加粗以引导面试官进入对我们有利的情景中。这个技巧其实是女朋友教我的，在此感谢她一直的陪伴。 个人独立博客个人独立博客算是我误打误撞做的准备。以前都觉得有博客的都是大神，会往上写一些高深的技术文章，现在想想其实是当时的眼界不够开放，把自己限制的很死，很多未知的事情不敢去尝试，后来在一位博士好友的催促下做了一个简陋的首页。万事开头难，做好了第一个页面之后就一直在弄博客的事情，到现在一年多时间一共有 45篇原创文章，平均一周多发一篇，数量不多，还需要继续加油。 个人认为独立博客内容是学习能力的一个体现，I hear and I forget. I see and I remember. I do and I understand.，只有输入没有输出的话很容易淡忘，多写写文章，无论是知识总结还是自己的新想法，这些都可以帮助对知识的进一步理解。同时博客也算是一个“日记”，可以记录平时开发中碰到的困难以及解决方法，以后职业生涯帮助也很大。 面试经历个人觉得，面试这个东西就是要多练，多去面试两家就不会怕了。看别人的面经用处最大在于了解这个岗位会问什么样的问题，别人碰到的面试官和面试体验给不了多大的参考价值。不如话虽如此，我还是写一点面试相关的经历，给自己留做纪念也好。 其实对于面经方面我也做了准备，秋招开始之前自己写了一个markdown文档用来记录各家公司的相关面试情况，包括投递进度和面试问题等等。另外我也自己在日历上会写计划好的日程，有序的整理给我省下了不少功夫。下面我大概写一下印象深刻的几家公司面试经历，至于面试问题我会在最后整理。 vivo 提前批这是我秋招参加的第一场面试，6 月 1 号笔试，6 月 8 号vivo就有人来了西安面试。一共两面，一轮技术 + 一轮 HR 面。第一次面试很紧张，不过vivo提前批居然出奇的简单，我身边的人基本都拿到了offer。 一面技术面没有怎么具体问基础，大概问了问项目。感觉面试官应该是leader级别的人，以项目为入口，先是问了Android网络相关知识，比如有哪些网络请求库，各有什么优缺点，然后问了一些场景题，比如图片加载优化，网络请求优化。印象最深刻的一个问题是，假如App需要定时更新某一个文件，你会如何设计具体的实现？我最初给出的方法是选择半夜服务器压力较小的时候如凌晨 1 点进行更新，但是这样带来了一个新问题， 如果大量的客户端向服务器端发送网络请求，服务器必然会宕机，相当于一次DDOS攻击，针对这个新问题我给出的解决方法是某一个时间短随机某一个时间点发送请求，感觉这个回答面试官也不是很满意。总之vivo第一面考察的重点不是理论基础，而是项目经验和实际的解决问题能力。 本来觉得自己一面答的很烂，因为之前从来没有考虑过那种问题，都是临场想出来的解决方法，没想到居然通过了一面。面试完之后有个小姐姐把我带到了一个房间里等二面，房间里有一些人已经在等了，过了不到 10 分钟刚才那个小姐姐就带我去了二面。 二面二面是HR面，第一次经历这种面试，不过问的问题都是很常规的问题，比如家庭情况，意向城市，爱好等等。提问环节我大概问了一下岗位和业务相关情况，一共聊了不到 20 分钟就结束了这次面试。 8 号现场面试，10 号去了线下答疑会，vivo提前批很有效率，给的薪资对于校招初期还没有见过世面的我来说还是挺多的，不过拒掉这个offer就是后话了。 vivo提前批的offer对于我来说帮助确实很大，一方面提升了我秋招的自信心，另外一方面也逼迫我尽早复习和投递简历，因为它一开始要求我 8 月 15 号（后来改成了 8 月 30 号）之前要给答复，违约金 5000，大小周，我不是特别想签，而当时来看，只有疯狂投各大公司的提前批才能给自己留条后路。 华为华为面试一般为两面，如果是sp的话会有三面以上不等。我今年参加了华为今年的软件精英挑战赛拿了奖，所以免去了笔试和第一轮技术面试，直接就是第二轮综合面试。 二面面试官是一个有点岁数的大佬，年龄目测 40+，一上来就给我巨大压力，这个岁数还呆在华为的，绝对是真·大佬级别的人，说不定一眼就看出来我是个渣。面试的问题基本没有基础，想来这种大佬应该很久没有做过一线了，整体而言有一点偏HR面，问的问题大概以下这些。 家庭情况，经济情况 有没有碰到压力很大的时候，如何排解 有没有什么有趣或者难忘的经历 有什么技术方面的东西想跟我说一下 工作地点，实习经历，论文以及专利情况 谈了一下华为工作相关的东西 感觉华为真的是玄学面试，就没怎么问过技术上的东西，都是让我自己介绍项目的东西，然后就是谈人生。面试完我估计offer应该没问题，因为我参加了华为的比赛还得了奖，另外宣讲会的时候华为说了今年会扩招，这都拿不到offer有点说不过去。但鉴于二面面试官给我很大压力，我的评分应该不会很高，没想到最后居然拿到了华为的sp，果然是玄学面试。 字节跳动头条今年简直秀，每周无间断的笔试和面试，任何时间参加都可以，笔试不过一直都有笔试的机会。投递头条的时间比较早，8 月 13 号我就在官网搞定了，不过笔试被安排在了 8 月 25 号。头条的笔试是真的很难，一共 5 道题，我才 A 了 0.7 道，可能是因为客户端比较缺，所以幸运的进入了面试。 之后面试被安排在了 9 月份，第一次面试的时候和网易的笔试冲突了，推到了下一周也就是 15 号。现在想想头条的面试其实中规中矩，没有问到特别难的东西，当然也有可能是面试官看出来我技术水平不高，没有问我很难的东西。 一面因为我把面试日期推到了 15 号，而上一次的笔试相对于以前简单了很多，很多人都进入了面试，因此等了挺长的时间，约定的时间是 3 点，但实际上到 3 点半才开始一面。 一面相对而言问的很基础，但是因为忘了记录，所以问题很多都不记得了。一开始先问的一些Java基础，然后看我有安卓开发经验，所以也问了一下安卓相关的技术知识点，都不是很深。我本以为这样就完了，但毕竟是宇宙条，算法还是少不了的。面试官出的问题不难，实现两个字符串表示的大数相加。很快就写完了，但是我写太急出了点bug，把除数和余数弄反了，不过问题不是特别大，一面大概 30 分钟结束了。几分钟后收到 HR电话说一面过了等待二面。 二面二面前面排了两个人，等了一个小时才轮到我面试。二面面试官看起来挺年轻的，技术实力感觉也挺强。问了以下这些问题： 什么时候开始学 Android TCP 三次握手和四次挥手，拥塞控制，校验 Linux 进程间通信方式有哪些，哪种最快 Https 流程相关 线程状态 抽象类和接口区别 深拷贝和浅拷贝区别 图片优化 RecyclerView 和 ListView 优化 电量优化，布局优化 图片加载库用的什么？如果自己设计图片加载库会考虑哪些东西？ LRU 原理 设计一个类微信首页的界面，如何实现（ViewPager + Fragement） 算法：剑指 offer 原题，每一行每一列都是升序，找数字 最后算法题写的有点久，我一上来直接把剑指offer上的解法写出来了，面试官觉得还可以在优化，让我想想有什么其他的方法，最后在面试官提示下才想出来的方法，时间复杂度大概是O(nlogm)，也就是先找到目标所在行或者列，然后二分查找，最后面试了一个多小时才结束，面试官跟我说休息一下准备接下来的第三面。 面试完之后仔细想想才觉得面试官提供的方法好像有问题，貌似是面试官套路我？瞬间感觉自己要凉，但是面试官又说让我准备三面，迷迷糊糊的过了二面，面试完已经是晚上 6 点了。 等了几分钟HR打电话跟我说二面通过，我问她能不能先去吃个饭，帮我把面试时间推到 7 点。结果我刚到食堂买好晚饭就接到了另外一个HR的电话说让回去面试，面试官在线上等我，跟他说我已经出来吃饭了，约了 6 点 40 面试，但是考虑到面试官已经在线上了，我也就打包了饭菜回了宿舍，结果发现面试官也去吃晚饭了。。。 三面7 点左右三面面试官终于出现，感觉是个leader级别的人，也很年轻。三面总体而言也是综合面，不怎么问技术细节，说个大概就可以。面试问题记录如下：睿思项目分工 网络，HTTP 相关 网络库区别 数据库（开源）有没有了解过 项目crash率有没有检测过 项目如何实现登陆 RecyclerView ListView 优化 华为比赛项目相关 FreeSwitch项目相关 专业偏嵌入式，为什么选择安卓 JNI了解么 Binder机制` Android各版本特性 最近有了解过什么新开源库 MVP和MVC模式的区别 项目如何使用MVP模式优化 权力反转环节大概问了一下头条的部门大概情况，聊天还算愉快。之后HR给我打电话说两周内给结果。成功结束头条面试，一下午怼了三面，头昏脑胀。 头条拿到offer确实是意外，毕竟宇宙条那么难进，给的钱又多。 大疆大疆应该算是最让我纠结的公司了，给钱多，平台还行，未来发展也不错，大疆确实是一个不错的选择，唯一的缺点就是一个非互联网公司，有点可惜，以后有机会可以再试试。言归正传，大疆整体面试偏重于基础一些，会从项目里某一个知识点不断深入。大疆的HR和面试官给我的印象都很不错，一面和二面都是远程面试，三面是现场面。 一面大疆的笔试难度太大了，整个实验室只有我收到了面试机会。一面是电话面试，听声音应该是两个面试官一起面试，问的东西特别广，从Java``Android到网络再到数据结构算法，甚至还问了未来三年的规划，面试完感觉大脑被掏空了。问题有这些： View 事件分发，三个方法，onIntercept方法true 和 false 返回的结果(true拦截，false继续传递) 自定义 View，获取自定义属性在哪里(构造方法里)，onLayout，onMeasure，onDraw作用 Looper和Handler关系(1:N) 图片不同目录下(drawble-hdpi,drawble-dpi)的区别 Activity 启动方式(standard,singleTask,singleTop,singleInstance) Activity onStart和onResume方法区别，什么时候会出现onResume()-&gt;onPause()-&gt;onResume()（可见但不可交互，如有一个对话框），弹Toast会不会，切换到任务管理器是否会执行onStop() 单例模式有几种方式（饿汉式，懒汉式(多线程情况下需要注意双重判定加锁)） synchronized修饰对象和方法有什么区别（锁不同） Java里Map有哪些(HashTable，LinkedHashMap，ConcurrentHashMap，HashMap，TreeMap)，哪些是线程安全(concurreentHashMap,HashTable)，那些不是，HashMap底层实现（数组+链表，链表过长-&gt;红黑树） IP和掩码关系 网络滑动窗口概念(TCP) 单向链表判环（双指针），如何找环入口，如果不用双指针该怎么判定（HashSet） 是否了解B+树 内存调度和换页算法概念，调度方式有哪些（FIFO,LRU,最佳替换OPT，时钟替换算法） http了解么 项目如何实现登陆功能，具体细节等 深拷贝和浅拷贝，如何实现深拷贝(clone(),序列化等) 最近再看什么书，有什么收获，哪些方面短缺？ 是否碰到OOM问题？哪些情况会出现OOM（图片和泄漏之外） 未来三年规划 其他offer 是否出来实习 大疆有了解么 二面对于一面而言还是比较有信心的，虽然有一些问题回答的很惨，但是大体应该还可以。大概等了一个多礼拜收到了二面通知，二面是视频面试，依旧是两个面试官，二面我就比较虚了，被问了很多不熟悉的地方，视频面试所以记录的问题不是很清楚了。 数据库设计，比如书城，如何设计订单，图书，作者等 设计模式，在 Android 代码里应用 智力题，1001个人比赛，决出最终获胜者，需要比赛多少次（1000次） 给定两个排序数组，如何选出相等的 ID 画一个正方形，在每个手机上用尺子量长度一样，怎么设计。 了解大疆么，有哪些飞机，那些产品等等 智力题居然没有答上来，明明很简单的。。。二面感觉答的不好，一上来怼了一题数据库的设计题，一脸蒙，数据库是我的弱项，基本没怎么看过，最后还是面试官放过了我，跳了这一题。另外对大疆的了解部分确实了解的不多，只知道大概的产品线。总体而言面试感觉很差，感觉应该挂了，没想到最后还是收到了三面的面试通知。 三面三面面试在一个咖啡馆里，HR小姐姐还给面试者点了饮料，面试体验很棒。三面面试官应该是大佬级别的人，感觉一般三面这种技术面都不会问很深，更注重于综合能力。现场面试，问题都不是很记得了。 自我介绍 手撕代码环节，一个无序数组，要求找出其中的最大或者最小 k 个数字。其实就是top k问题，可以用大顶堆或者小顶堆来实现，具体可以看堆排序问题 项目大概的模块划分，大体的实现方式等等，这个聊了很久 未来的职业规划，想做的方向等 手撕代码侥幸过关，回学校的时候跟别人讨论发现自己刚好把大顶堆和小顶堆弄反了，貌似面试官也没有在意，有这种思路就可以。 校招面试每个人体验都会不一样，不同的面试官，不同的HR都会是不一样的感受，这部分参考价值不大，重要的还是面试问题总结，这部分这本书Android 校招面试指南总结的已经很全面了，在此我不再赘述。 书单在此也跟风列一下书单吧，里面大部分书我看过，有一部分是经典书籍，值得一看。 Java基础 Head First Java Java 核心技术（卷 1 / 卷 2） 阿里巴巴 Java 开发手册（电子书，2017 年 2 月 9 号发布，主要内容是 Java 开发规范） 进阶 Java 编程思想 Effective Java 深入理解 Java 虚拟机 码出高效：Java 开发手册（2018 年 9 月 22 号阿里巴巴云栖大会正式发布） Android基础 第一行代码（第二版） 进阶 Android 群英传 Android 开发艺术探索 Android 系统源代码情景分析（这本我还没看） 高性能 Android 应用开发（很多优化的知识点和实践，值得一看） 打造高质量 Android 应用（内容主要是优化和实用技巧，不过有点老了） 数据结构和算法 数据结构 475 讲（清华大学邓俊辉） 算法（第 4 版） Leetcode 剑指 offer 牛客网 设计模式 大话设计模式 其他 编程珠玑 重构 - 改善既有代码的设计 编程之美 Android 校招面试指南（一本非常全的面经，在我求职过程中发挥了巨大作用，再次感谢几位作者） 总结个人感想秋招如果从vivo提前批开始算起进行了几个月，现在终于落下了帷幕。现在看来其实自己已经很幸运了，前期拿了offer稳定心态，后期几个有意向的offer都差不多同一时间出来薪资，并且offer给的薪资都很不错，虽然最后选择的时候很苦恼，尤其是大疆的offer，找了我好几次，但是没办法，只能优中选合适，最后还是选择了头条。 秋招其实有点像备考，基础知识点就那些，好好复习肯定面试不会差，感觉大厂很多都重视基础。项目部分如果没有项目的话可以看看网上的项目实战课程，比如慕课网，把项目吃透也可以。其实在面试官看来如果不是大厂项目都差不多，主要看你在项目中体现的综合能力，比如碰到了难题如何解决，整体框架等等。 秋招的时候心态最重要，保持一个好心态，无论面试成功或者失败。比如贝壳面试面试的时候，当时已经有大疆的offer了，然而一面直接挂，搞得我差点怀疑人生，瞬间想签了大疆完事，下午的百度一面不去了。但是最后还是好好想了想，面试除了实力之外也有运气，运气不好的时候挂了也很正常，所幸没有放弃，最后百度还拿到了offer。另外一定要放松心态，9 月份电话不断，我差点都有电话恐惧症了，一震动就神经紧张。 面试其实也是一个查缺补漏的过程，在面试中不断发现之前没有了解的知识，总结经验迎接下一次面试。美团曾经问过我某一个项目里的不足点如何改进，我当时没有什么特别好的想法，最后面试官给了他的建议，我自己面试完也好好思考了一下，后来头条面试的时候也问到了同样的问题，我就能自信满满的给出答案。 秋招是一个艰难抉择的过程，笔试冲突了、面试冲突了、offer如何选择都会让人很痛苦。所以个人建议一开始就想好自己的方向，能不海投尽量不要海投，海投非常消耗精力，另外万一拿到offer，选择更是一个艰难的问题。我就纠结于是否选择大疆 10 多天，期间HR小姐姐几次找我，我未来的大疆导师跟我也聊了很久，大疆的平台和薪资都很不错，让我不忍心拒绝，但是最终还是放弃了大疆，做选择的时候实在是太痛苦了。 总的来说，秋招还是很充实的，每天面试笔试，经过秋招也学到了挺多东西，不枉花了那么多时间，很特别的一段经历。 建议这里根据我个人的经历给一点建议吧，一家之言，大家看看就好。 早作准备，优势很大。很多提前批免笔试，直接面试能省很多力气，另外提前批hc数量较多，岗位和部门选择空间也更大。同时也要关注各大公司校招网申笔试等时间点，提前批次挂的话一般还会有正式批次，不过也要注意，提前批次肯定会有面试记录，因此会对正式批次有一定参考价值。 如果有时间实习一定要去实习，大厂的最好。其实这也是早作准备的原因之一，实习生招聘一般研二或者大三下学期开始，这就意味着这个时候就需要有一定的基础实力，有实习经历能给秋招非常大的助力。 投简历之前好好想想自己想要从事的行业，不要乱投，到时候不仅浪费自己时间也浪费别人时间。不过面试经验还是要攒的，可以先投一些小公司试试，之后再来面大厂，千万不要把自己的第一次献给大厂。 面试一定做好规划，做好总结。我用markdown文件记录了我整个秋招的经历，每次面试回来都会回顾一下没有回答上来的问题或者是自己不是很理解的地方，每一次面试都是为下一次做准备。 祝师弟师妹们未来拿到好offer。 秋招终于结束，接下来就是好好写专利和论文了。不过offer不是结束只是一个新的开始，新的征程即将拉开帷幕，还是要继续加油。","tags":[{"name":"面经","slug":"面经","permalink":"https://KingsFish.github.io/tags/面经/"},{"name":"Android","slug":"Android","permalink":"https://KingsFish.github.io/tags/Android/"},{"name":"秋招","slug":"秋招","permalink":"https://KingsFish.github.io/tags/秋招/"}]},{"title":"堆排序问题","date":"2018-09-24T01:20:03.000Z","path":"2018/09/24/堆排序问题/","text":"中秋了也要发博客，写完我就出去浪，祝大家中秋快乐~ 堆排序问题算是面试中的高频问题了，这个知识点作为基础排序算法会被问，另外还可以继续延伸，比如Top K问题和实现优先队列。百度面试的时候就让实现优先队列，然而当时紧张没有写出来，其实还是很简单的。 堆的定义堆是一种数据结构，类似于完全二叉树，但一般使用数组作为堆的实现。堆分为大顶堆和小顶堆，大顶堆指父节点的值大于两个孩子节点的值，这样根节点的值必定为整个堆的最大值，因此称为大顶堆；与此相反，小顶堆指父节点的值小于两个孩子节点的值，这样根节点的值必定为整个堆的最小值，因此称为小顶堆。 大顶堆和小顶堆 主要操作 方法 作用 时间复杂度 get 取得堆顶值 O(1) sink 将元素下沉，恢复堆有序性 O(logn) delete 删除并取得顶堆值 O(logn) build 建堆 O(n) 具体实现这里以大顶堆作为例子，小顶堆其实类似，只不过下沉操作的时候比较大小时更换一下即可。 下沉操作这是堆排序中最重要的操作，它保证了堆的有序性，建堆和删除堆顶值的时候都需要调用这个操作。 下沉操作主要是让当前节点和两个子节点进行比较，如果父节点比子节点小，则将这两个节点互换，重复这个操作直至父节点比子节点大。代码如下： 123456789101112131415161718192021222324252627282930313233// 下沉操作private void sink(int [] nums, int i, int end) &#123; while (i &lt; end) &#123; // 得到子节点位置 int child = child(i); if (child &lt; end) &#123; // 如果左节点的值小于有节点，则替换右节点的值 if ((child + 1 &lt; end) &amp;&amp; nums[child] &lt; nums[child + 1]) &#123; child ++; &#125; if (nums[i] &lt; nums[child]) &#123; swap(nums, i, child); i = child; &#125; else &#123; break; &#125; &#125; else &#123; break; &#125; &#125;&#125;// 获取子节点private int child(int i) &#123; return i * 2 + 1;&#125;// 交换两个节点值private void swap(int [] nums, int i, int j)&#123; int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp;&#125; 建堆过程建堆其实就是不断调用sink下沉的过程，给定初始的数组，只需要从最后一个数字开始往前不断进行下沉操作即可，类似于一个递推的过程，不断的将新元素插入到原先已经建好堆的后方数组中。代码如下 123456public void heapSort(int [] nums) &#123; for(int i = nums.length - 1; i &gt;= 0; i --) &#123; // 从后面开始不断进行下沉操作 sink(nums, i, nums.length); &#125;&#125; 获取堆顶值此时数组第一位为堆顶值，最大，直接返回即可 1234public int getMax()&#123; // 堆顶值最大 return nums[0];&#125; 移除堆顶值移除数组第一位，并将数组最后一个数移到堆顶，并执行下沉操作即可保持堆有序性。 123456public int delMax(int [] nums, int len)&#123; int tmp = nums[0]; swap(nums, 0, len - 1); sink(nums, 0, len - 1); return tmp;&#125; 问题扩展Top K 问题Top K问题是堆排序的扩展，一般问题描述如下： 给定一个数组，求出最小/最大的 K 个数 这个问题最简单的解决方法就是排序，时间复杂度最优是O(nlogn)，此法不是本文重点，不在此详细说明。这个问题用堆可以很容易的解决，最小 K 个数可以使用大顶堆，最大 K 个数可以使用小顶堆，本文示例使用大顶堆解决最小 K 个数问题。 解法思路如下 ： 创建一个大小为 K 的数组 B，并初始化数值为Integer.MAX_VALUE（小顶堆则初始化为Integer.MIN_VALUE） 遍历给定的数组 A，对于每一个数 C，将其跟 B 的堆顶进行比较，如果比堆顶小，则将 B 的堆顶值替换成 C，然后执行下沉操作。遍历完成之后 B 数组即为所求的数字。 代码如下 12345678910111213141516171819public int [] topK(int [] nums, int k) &#123; if (k &gt; nums.length) &#123; throw new IllegalArgumentException(\"k:\" + k + \", length:\" + nums.length); &#125; // min k int [] top = new int[k]; for (int i = 0; i &lt; top.length; i++) &#123; // 初始化值 top[i] = Integer.MAX_VALUE; &#125; for (int i = 0; i &lt; nums.length; i ++) &#123; if (nums[i] &lt; top[0]) &#123; // 如果比堆顶值小，则替换堆顶并执行下沉操作 top[0] = nums[i]; sink(top, 0, top.length); &#125; &#125; return top;&#125; 优先队列优先队列在队列调度的时候用的很多，主要实现一个需求，往优先队列中无序放入优先级不同的任务，要求随时能取出优先级最高的任务。使用大顶堆堆可以很好的满足这个要求。大顶堆能维持顶堆的优先级最高，随时能够取出该任务。 主要API如下： 方法 作用 时间复杂度 poll 取出优先级最高的任务 O(logn) offer 增加一个任务 O(logn) isEmpty 查询队列是否为空 O(1) getSize 查询队列大小 O(1) clear 清空队列 O(1) 与上述Top K问题不同的是，优先队列需要增加一个上浮操作。对于新加入的任务，需要执行该操作来维持堆的有序性。 解决思路如下： poll的实现堆已经实现过了，参考上文 offer的实现需要使用上浮操作，将新元素增加到队尾，然后执行上浮操作即可保持堆有序性 isEmpty的实现可以通过保存队列当前元素数量来实现 具体代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class PriorityQueue&lt;T implements Comparable&gt;&#123; private final int DEFAULT_COMPACITY = 10; private int size = 0; private int compacity = 0; private T [] ts; public PriorityQueue()&#123; // 默认容量10 this(DEFAULT_COMPACITY); &#125; public PriorityQueue(int com)&#123; compacity = com; ts = new T[compacity]; &#125; // 取数据 public T poll()&#123; // 交换队首以及最后的数据，然后执行下沉操作保证堆有序 T t = ts[0]; swap(ts, 0, size - 1); size --; sink(ts, 0, size + 1); return t; &#125; // 增加数据 public boolean offer(T t)&#123; if(size &gt;= compacity) &#123; return false; &#125; // 将新数据添加到队尾，并执行上浮操作保证堆有序 size ++; ts[size - 1] = t; up(size - 1); return true; &#125; public boolean isEmpty()&#123; return size == 0; &#125; public int getSize()&#123; return size; &#125; private void sink(int i)&#123; // 见上方 &#125; private void up(int i) &#123; while(i &gt; 0) &#123; // 不断将当前节点与父节点对比直到比父节点小 int parent = i / 2; if(ts[i].compareTo(ts[parent] &gt; 0)) &#123; swap(ts, i, parent); i = i / 2; &#125; else &#123; break; &#125; &#125; &#125; public void clear()&#123; size = 0; ts = new T[compacity]; &#125;&#125; 堆排序问题终于写完，该出去浪了~","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"},{"name":"Heap","slug":"Heap","permalink":"https://KingsFish.github.io/tags/Heap/"}]},{"title":"大疆Android面经","date":"2018-08-17T01:20:03.000Z","path":"2018/08/17/大疆Android面经/","text":"大疆是我正儿八经面试的第二家公司，第一家是 oppo 提前批，一面就被刷了，惨不忍睹。。。 大疆今年实在是太早了，6 月末截至投递简历，战线拉得很长，这一个多月都在忙活面试和笔试。笔试是 7 月 5 号做的，之后一直等消息，等了 20 多天，7 月 24 号收到了一面通知。 一面是个电话面试，悄悄的录了音，问了这些问题： View 事件分发，三个方法，onIntercept方法true 和 false 返回的结果(true拦截，false继续传递) 自定义 View，获取自定义属性在哪里(构造方法里)，onLayout，onMeasure，onDraw作用 Looper和Handler关系(1:N) 图片不同目录下(drawble-hdpi,drawble-ldpi)的区别 Activity 启动方式(standard,singleTask,singleTop,singleInstance) Activity 中onStart和onResume方法区别，什么时候会出现onResume()-&gt;onPause()-&gt;onResume()（可见但不可交互，如有一个对话框），弹Toast会不会，切换到任务管理器是否会执行onStop() 单例模式有几种方式（饿汉式，懒汉式(多线程情况下需要注意双重判定加锁)） synchronized修饰对象和方法有什么区别（锁不同） Java里Map有哪些(HashTable，LinkedHashMap，ConcurrentHashMap，HashMap，TreeMap)，哪些是线程安全(ConcurrentHashMap,HashTable)，那些不是，HashMap底层实现（数组+链表，链表过长-&gt;红黑树） IP和掩码关系 网络滑动窗口概念(TCP) 单向链表判环（双指针），如何找环入口，如果不用双指针该怎么判定（HashSet） 是否了解B+树 内存调度和换页算法概念，调度方式有哪些（FIFO,LRU,最佳替换OPT，时钟替换算法） http了解么 论坛项目登陆保存的 formhash，有效期等 深拷贝和浅拷贝，如何实现深拷贝(clone(),序列化等) 最近再看什么书，有什么收获，哪些方面短缺？ 是否碰到OOM问题？哪些情况会出现OOM（图片和泄漏之外） 未来三年规划 其他offer 是否出来实习 大疆有了解么 有什么想问我的么 一面问的实在是太广了，Java，Android，TCP/IP，算法，操作系统、网络等都有涉猎。听声音大概有两个面试官一起面试，车轮战，问的很多都是基础，考察广度比较多一些。 侥幸通过一面，7 月 31 号约了视频二面，发现二面又是两个面试官轮番上阵，大疆这么流行压力面的么？主要问了这些问题： 数据库设计，比如书城，如何设计订单，图书，作者等 设计模式，在Android 代码里有哪些应用 智力题，1001个人比赛，决出最终获胜者，需要比赛多少次（1000次） 给定两个排序数组，如何选出相等的 ID 画一个正方形，在每个手机上用尺子量长度一样，怎么设计。 了解大疆么，有哪些无人机，那些产品，等等 有什么想问我的么 二面面试官有一个应该是做后台的，一上来直接怼我数据库，给定场景问我数据库设计的问题，一下子问到了我知识的盲点。。。 总的来说，二面还是问的基础，感觉对项目并不感兴趣，有一些细节的东西还需要注意。 本来感觉二面已凉，很多问题都没回答上来，结果居然给了终面通知，去某一个交流群里问了一下发现二面通过率很高，捡了个便宜，尽管这也意味着终面竞争压力很大。 终面是个现场面，8 月 16 号约在一个咖啡馆里面试，HR 小姐姐还给每一个面试者点了喝的，面了 30 分钟左右，体验良好。大概问了这些问题： 一堆无序数组，求最大10个数，用小顶堆蒙混过关了 项目有哪些模块，具体怎么做。问的不深 大概问了一下以后想要做的方向 有什么想问我的么 面试官感觉是个主管 leader 之类的，性子很急，一上来就让我手撕代码，最后蒙混过关，面试基本都是技术问题，没有谈人生，也没有谈理想。中途居然看见两个做 Android 的妹子来面试，少见的很。 终面除了手撕代码有难度之外，其他的都还好。 大疆的面试终于告一段落，战线拉了两个月，耗时耗心力，但愿能有个好结果。秋招之路刚刚开始，继续加油！","tags":[{"name":"面经","slug":"面经","permalink":"https://KingsFish.github.io/tags/面经/"},{"name":"Android","slug":"Android","permalink":"https://KingsFish.github.io/tags/Android/"},{"name":"大疆","slug":"大疆","permalink":"https://KingsFish.github.io/tags/大疆/"}]},{"title":"Android 事件分发机制","date":"2018-07-28T10:14:04.000Z","path":"2018/07/28/Android-事件分发机制/","text":"Android 事件分发机制一直来说都是一个比较难理解的知识内容，恰逢秋招，花了几天时间学习了一下，终于弄懂了是怎么回事，总结如下： 核心方法事件分发机制主要有三个方法： dispatchTouchEvent()，主要用于事件分发给子控件 onIntercptTouchEvent()，主要用于是否拦截事件，ViewGroup 独有 onTouchEvent()方法，主要用于处理触摸事件 分发机制当屏幕某一个控件被点击时，首先触发顶层布局的dispatchTouchEvent()方法，将事件进行向下传递，如果该布局是ViewGroup，则会先调用onInterceptTouchEvent()方法确定是否拦截该事件，如果返回true，则表示拦截该事件，不再往下传递，并调用自己的onTouch()方法进行事件处理，否则分发给子控件如此循环。直至有子控件消费此事件。流程图如下，假设目前有三层布局，Activity -&gt; LinearLayout -&gt; Button 下图是分发业务流程图 代码分析上图我刚开始看的时候也看不懂，下面从代码层面分析，根据具体情况分为多种情况，整个调用过程存在递归，先由上层往下分发事件，然后根据上层根据下层返回的数据进行处理，直至分发过程结束： Activity 接收到点击事件，首先进行分发，调用dispatchTouchEvent()，在这个函数里面，会进行事件的分发，调用子控件也即LinearLayout的dispatchTouchEvent()方法，根据LinearLayout的dispatchTouchEvent()的返回值进行判定，会有两种结果: 如果返回true，则表示子控件已经把事件消费掉了，则Activity的 dispatchTouchEvent 方法也返回 true，代表已经处理了这个点击事件，事件分发过程结束。 如果返回false，则表示子控件并没有把事件消费掉，则 Activity会调用自己的 onTouchEvent()方法进行时间处理，一般来说我们不会覆写修改Activity 的 onTouchEvent() 方法，该方法默认返回false，事件分发结束。 那么在 LinearLayout 的dispatchTouchEvent() 方法里什么时候会返回true，什么时候会返回 false 呢？与 Activity 有所不同的的是，LinearLayout 是一个 ViewGroup，多了一个 onInterceptTouchEvent() 方法，LinearLayout 会先调用 onInterceptTouchEvent() 方法决定是否直接拦截事件，会有两种情况： onInterceptTouchEvent() 返回 true。那么 LinearLayout不会像Activity 一样无条件向下传递事件，而是直接拦截触摸事件，然后调用自己的 onTouchEvent() 方法，LinearLayout 的dispatchTouchEvent() 方法返回值取决于 onTouchEvent() 的返回值 onInterceptTouchEvent() 返回false，表示 LinearLayout 不拦截事件，会正常往下传递事件，在此例子中将会调用 Button 的 dispatchTouchEvent() 方法。Button 的 dispatchTouchEvent() 方法返回值也有两种： 返回true。那么 LinearLayout 的 dispatchTouchEvent() 将直接结束，返回true，继续走Acticty 的 1.1 流程。 返回false。那么LinearLayout 会调用自己的onTouchEvent() 方法。和 Activity 类似，一般我们不会覆写这个方法，这个方法默认返回 false，那么接下来继续走 Activity 的1.2流程。 那么Button 的dispatchTouchEvent() 方法里什么时候会返回true，什么时候会返回false 呢？与LinearLayout 不同，Button 不是ViewGroup 而是 View，只有dispatchTouchEvent() 和 onTouchEvent 方法，但是Button 作为 View 比较特殊，还拥有一个方法onTouch()，Button 的dispatchTouchEvent()方法流程如下。首先检查Button 是否设定了触摸事件，也即onTouchListener 是否为空，结果有两种： 设定了触摸事件，则执行 onToucheListener 的onTouch 方法，Button 的 dispatchTouchEvent 方法直接返回 true，走LinearLayout 的2.2.1 流程 未设定触摸事件，则执行Button的onTouchEvent 方法，根据 onTouch 方法返回值返回，如果是true，则 Button 的 dispatchTouchEvent 方法结束，走 LinearLayout 的 2.2.2 流程 使用伪代码的流程图如下： 当然，这个伪代码只是一个非常简略的版本，在实际的源码中，还有很多判定等条件和函数的具体实现，但是大体的流程就这以上这些。 额外知识此外还有一些其他的知识： onTouch方法调用时间先于onTouchEvent 如果子 View不想让父控件拦截事件怎么办？可以在子类中调用requestDisallowInterceptTouchEvent方法来请求事件的直接下发 如果某控件onTouchEvent方法对DOWN事件返回了 false，也即不对DOWN事件进行处理，那么之后的UP和MOVE事件都不会下发给该控件。这也符合一般常识，如果一个控件对于手指触摸屏幕事件没有反应，那么对于接下来的手指移动和手指抬起的事件也应当无反应。 从 3 的另一个方向思考，如果某控件的onTouchEvent对于DOWN事件返回了true，也即消费了该事件，那么接下来的事件都会自己处理，不会下发给子控件。 如果上一次 Button 消费了DOWN事件，而之后来了一个MOVE事件被LinearLayout拦截了，那么会给Button传递一个CANCEL事件 最近秋招大潮来临，各种公司内推电话面，每一次都感觉自己还是个渣，被问了很多不知道的东西，每一次面试都是查缺补漏，加油！预祝自己能找个好工作。","tags":[{"name":"事件分发","slug":"事件分发","permalink":"https://KingsFish.github.io/tags/事件分发/"}]},{"title":"一周年生日快乐","date":"2018-07-13T02:41:07.000Z","path":"2018/07/13/一周年生日快乐/","text":"兜兜转转又是一年，去年这个时候看到糊涂博士在骑行群里分享他的博客，觉得很高大上，于是夸下海口，跟糊涂博士说等我期末考试完了也搞个自己的博客，互设友链。 结果还是自己懒，考完试根本没动静，那时候觉得有个自己的博客是一个技术水平特别高的事情，自己做不来。最后在糊涂博士的催促下才用 Github Pages 匆忙做了个博客，刚开始只有一个页面，还是抄袭别人的，什么内容都没有，大笔一书，网站建设中，留下了一个联系方式和友链。不过好歹也有了个样子，万事开头难，开头做好了，剩下的只剩坚持了。 其实之前还想自己做个站，刚好手里有一个 vps，但后来一看搭 LNMP 环境太麻烦了，自己懂的前端后端知识又不是很多，只是想安安静静写博客而已，最后选择了 Github Pages，省心省力。 我记得「宽带无线通信」老师说过这么一句话，*I hear and I forget. I see and I remember. I do and I understand. *没有输出，学的容易忘。多写博客，多总结，知识理解的更深，以后找工作复习的时候也能用上。 这一年来虽然不怎么勤奋，也写了不少博客，没有荒废自己的学习。虽然一年前定的目标现在没有实现多少，但做了总比不做好。马上就要研三了，现在已经拿到了 vivo 的 offer。虽然不是 sp，但是画的大饼还是不错的（大雾）。秋招也才刚刚开始，还有大把机会。 最近出差两次，已经很久没去健身了，也许找到工作之后会继续天天去吧。 逝者如斯夫，不舍昼夜。时间过得飞快，且看明年会变成什么样。","tags":[{"name":"生日","slug":"生日","permalink":"https://KingsFish.github.io/tags/生日/"}]},{"title":"如何网页启动 Android 程序","date":"2018-07-10T14:21:02.000Z","path":"2018/07/10/如何网页启动-Android-程序/","text":"最近更新了「知乎」手机客户端，发现了知乎的一个新 feature，在浏览器打开知乎的网页的时候会弹出程序选择窗口，选择在「知乎」程序里或者继续在网页端浏览。 不得不说这是一个很棒的主意，因为「知乎」自己程序里的搜索功能实在是太差了（据说是搜狗提供的），很多时候搜索不到自己想要的答案，而在网页端直接浏览的体验没有手机客户端好，这样倒是完美的结合了两种方式的优点。 刚好自己做的「手机睿思」其实也有类似的毛病，当你在手机上收到一个别人发过来的论坛帖子链接，有时候不在校内就无法打开，有时在校外，而网页端「手机睿思」体验又比较差，如果能实现「知乎」类似的结果就方便很多了。 理论网页直接启动 Android 程序主要是通过 intent-filter 来实现的，intent-filter 包含很多属性，这里需要用到 &lt;action&gt;、&lt;category&gt;和&lt;data&gt;这三个，详细的配置是通过 &lt;data&gt; 标签来完成的。 要添加的这要是这三个标签： action_VIEW：浏览网页使用的就是这个 action，不然无法接收浏览网页请求 category.BROWSABLE：目标 Activity 中必须有这个，否则点击超链接后无法成功跳转 category.DEFAULT：没有这个的 Activity 不接受隐式启动 以上三个标签负责接收网页跳转，剩下的URL匹配就需要用 &lt;data&gt; 标签了。 URL主要有四个部分组成，scheme、authority、path、queryString，其中authority有分为host和path两部分，格式如下 1scheme://host:port/path?queryString 根据URL的格式，&lt;data&gt; 标签对应有以下属性： 1234567891011&lt;data android:scheme=\"\" android:host=\"\" android:port=\"\" android:path=\"\" android:pathPattern=\"\" android:pathPrefix=\"\" android:mimeType=\"\" android:ssp=\"\" android:sspPattern=\"\" android:sspPrefix=\"\"/&gt; 以 https://www.zhihu.com/question/28629301/answer/432294682 为例子，其中 scheme: 协议类型，如 http、https、ftp等，也可以是自定义的数据 host： 主机地址，如 www.zhihu.com port： 端口，比如常见的 80、8080端口，默认的 80 端口一般不写 path： 路径，比如 /question/28629301/answer/432294682 pathPrefix： 路径前缀，只有路径前缀是这个的才可以匹配，用于精确匹配条件 pathPattern： 和 pathPrefix 类似，使用正则表达式来精确匹配路径 其他的属性这里用不上，因此不再详细解释，有兴趣可以自行了解。我需要匹配的URL是这样的。 1http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=952631 在我的需求下用到了以下属性： scheme，设置为 http host，设置为 rs.xidian.edu.cn path，设置为 /forum.php 实践下面说一下具体现实步骤 创建两个Activity，MainActivity和HttpActivity，MainActivity有一个按钮，用来发送浏览网页请求，HttpActivity用于接收请求。HttpActivity的配置如下 1234567891011&lt;activity android:name=\".HttpActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\"/&gt; &lt;category android:name=\"android.intent.category.BROWSABLE\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;data android:scheme=\"http\" android:host=\"rs.xidian.edu.cn\" android:pathPrefix=\"/forum.php\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 在MainActivity里做好发送请求的代码 1234567891011121314151617181920public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private Button btn; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btn = findViewById(R.id.btn); btn.setOnClickListener(this); &#125; @Override public void onClick(View view) &#123; Uri uri = Uri.parse(\"http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=952475\"); Intent i = new Intent(Intent.ACTION_VIEW); i.setData(uri); MainActivity.this.startActivity(i); &#125;&#125; 在HttpActivity里进行数据接收，可以通过uri.getQueryParameter()方法获取URL携带的参数信息。 12345678910111213141516171819public class HttpActivity extends AppCompatActivity &#123; public static final String TAG = \"HttpActivity\"; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_http); Intent i = getIntent(); Uri uri = i.getData(); Log.i(TAG, \"link：\" + i.getDataString()); Log.i(TAG, \"scheme: \" + uri.getScheme()); Log.i(TAG, \"host：\" + uri.getHost()); Log.i(TAG, \"path: \" + uri.getPath()); Log.i(TAG, \"mod: \" + uri.getQueryParameter(\"mod\")); Log.i(TAG, \"tid: \" + uri.getQueryParameter(\"tid\")); &#125;｝ 查看结果 123456I/HttpActivity: link：http://rs.xidian.edu.cn/forum.php?mod=viewthread&amp;tid=952475I/HttpActivity: scheme: httpI/HttpActivity: host：rs.xidian.edu.cnI/HttpActivity: path: /forum.phpI/HttpActivity: mod: viewthreadI/HttpActivity: tid: 952475 成功获取得到了参数，「知乎」用的是类似的方法，不过把host换成了它自己的，另外根据path和其他参数进行不同Activity的跳转。 据我测试发现，以Chrome为例，每新开一个标签页的时候会发送一次action_VIEW的Intent，这样就可以触发打开app，不过「睿思」基本没有被搜索网站所收录，网页直接跳转这个基本用不上，现在能解决的痛点大概是聊天的时候直接发链接访问的问题了。","tags":[{"name":"html","slug":"html","permalink":"https://KingsFish.github.io/tags/html/"},{"name":"scheme","slug":"scheme","permalink":"https://KingsFish.github.io/tags/scheme/"},{"name":"intent-filter","slug":"intent-filter","permalink":"https://KingsFish.github.io/tags/intent-filter/"}]},{"title":"2018上半年复盘","date":"2018-07-07T03:06:00.000Z","path":"2018/07/07/2018上半年复盘/","text":"一直觉得上半年过得更快，过了年就是 3 月份，还没来得及做什么，上半年就只剩下 4 个月。正好星球里布置了复盘的作业，顺便也发在博客上。 成果: 拿到了华为一个大赛的奖 拿到了 vivo 的 offer。第一个 offer，很开心 完成老师给的项目 不断更新迭代「手机睿思」 完善博客功能(新的评论系统)，并一直在更新技术博客 学习了一些 Android 进阶的内容 刷了很多算法题 每天背单词 遗憾: 健身计划未能完整执行，时去时不去 年初指定的很多技术学习内容没有完成 理财亏了好多钱😭😭 展望: 暑假继续深入学习 Android 知识，秋招找一份满意的工作 坚决执行健身计划 找完工作陪家人出去旅游一次 继续探寻美食 坚持更新博客，提升博客内容深度 了解更多和技术无关的事情😏 毕业论文，开始！ 总的来说，上半年有一定收获，但还是没有全身心投入，很多时间其实可以用来深入学习的，结果被用在了玩上面。中间出差两次，加起来接近一个月的时间都在外地，天天把自己当猪养，还有老师给的项目。其实出差的时候相对学校更有空闲时间，但是没有用来学习，基本都在玩手机。还是自己效率不高，经常学习的时候不专注。下半年继续加油，就是干！","tags":[{"name":"总结","slug":"总结","permalink":"https://KingsFish.github.io/tags/总结/"},{"name":"2018","slug":"2018","permalink":"https://KingsFish.github.io/tags/2018/"}]},{"title":"剑指offer 05-从尾到头打印链表","date":"2018-06-14T04:09:49.000Z","path":"2018/06/14/剑指offer-05-从尾到头打印链表/","text":"题目 输入一个链表的头结点，从尾到头反过来打印每个节点的值 看到题目第一反应是用栈，将节点一个一个压入栈中，然后弹栈打印节点即可，难度不大，代码如下： 123456789101112public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode)&#123; Stack&lt;ListNode&gt; stack = new Stack&lt;&gt;(); while (listNode != null) &#123; stack.push(listNode); listNode = listNode.next; &#125; ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;(); while(!stack.empty())&#123; res.add(stack.pop().val); &#125; return res;&#125; 上面的算法借助了栈，使用了 O(n) 的空间。有没有更好的解法呢？其实能用栈做的事情，用递归都可以做。递归其实也使用了函数栈。 递归的算法只需要先递归下一个节点，等函数执行完之后再打印节点即可。代码如下： 123456789101112public ArrayList&lt;Integer&gt; printListFromTailToHead(ListNode listNode) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); search(listNode, list); return list;&#125;private void search(ListNode node, ArrayList&lt;Integer&gt; list) &#123; if (node != null) &#123; search(node.next, list); list.add(node.val); &#125;&#125; 这个算法时间复杂度为 O(n)，空间复杂度不算函数栈的话（一般不计算函数栈）是 O(1)。","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://KingsFish.github.io/tags/Binary-Tree/"}]},{"title":"剑指offer 04 - 替换空格","date":"2018-06-14T03:49:49.000Z","path":"2018/06/14/剑指offer-04-替换空格/","text":"题目 请实现一个函数，把字符串中的每个空格替换成”%20”。例如输入 “We are happy.”，输出”We%20are%20happy.”。 这道题是针对 C++ 出的，对于 Java来说相对简单，用一个 StringBuiler 或者 StringBuffer 就可以了。不过这两个之间有略微的差别，StringBuiler是非线程安全的，多线程环境下会出现问题，但效率更高，StringBuffer则是线程安全的，但是效率相对较低。这题不涉及多线程编程，因此用 StringBuiler 就可以了。代码如下： 12345678910111213public String replaceSpace(StringBuffer str) &#123; StringBuilder sb = new StringBuilder(); int i = 0; while (i &lt; str.length()) &#123; if (str.charAt(i) == ' ')&#123; sb.append(\"%20\"); &#125; else &#123; sb.append(str.charAt(i)); &#125; i++; &#125; return sb.toString();&#125;","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"}]},{"title":"Leetcode-237 Delete Node in a Linked List","date":"2018-06-08T02:00:36.000Z","path":"2018/06/08/Leetcode-237-Delete-Node-in-a-Linked-List/","text":"刷Leetcode刷到一个很有意思的题目，解题思路很新颖，题目如下： Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.Given linked list – head = [4,5,1,9], which looks like following: 14 -&gt; 5 -&gt; 1 -&gt; 9 Definition for singly-linked list. 12345public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; The linked list will have at least two elements. All of the nodes’ values will be unique. The given node will not be the tail and it will always be a valid node of the linked list. Do not return anything from your function. 题目大意是，给定一个要删除的节点，要求在这个节点所在的链表中删除该节点 假设要删除的节点是 a ，常规做法是从链表头开始遍历找到 a 的前一个节点，假设为 b，将 b 的 next 指针指向 a 的 next就可以了。但是题目只给定了待删除的节点，没有给链表的头结点，似乎束手无策了。 其实稍加思索可以发现，我们要删除的不是节点本身，而是节点的内容，以此题为例，节点里面的内容只有两个东西，val和next指针。如果我们要删除该节点，只需要把b的后一个节点的内容复制到b节点，然后跳过b节点的下一个节点即可。如图 删除节点 b 实现代码也比较简单 1234public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next;&#125; 解题思路确实很新颖，之前没有想过可以这么做，其实这题完全可以出的更具迷惑性，把链表首结点也给出，大多数人可能都会遍历整个链表来删除节点。 多刷题果然是有好处的。","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"},{"name":"链表","slug":"链表","permalink":"https://KingsFish.github.io/tags/链表/"}]},{"title":"剑指offer 03-二维数组中的查找","date":"2018-06-07T02:23:25.000Z","path":"2018/06/07/剑指offer-03-二维数组中的查找/","text":"题目 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请实现一个函数，输入这样的二维数组和一个整数，判断数组中是否含有该整数。例如下面的数组 12341 2 8 92 4 9 124 7 10 136 8 11 15 如果查找 10 ，则返回 true，如果查找 5 ，则返回 false 这个题目之前在leetcode上做过，不过没有做出来，刚开始的思路类似于二分查找，选取当前矩形最中间的数字，如果小于要寻找的整数，则除去左上角的矩形，如果大于要寻找的整数，则去除右下角的矩形，但是之后就没法做了，也没法写成递归的形式。 参考leetcode和「剑指offer」，正确的解法应该是按照左上角或者右下角的数字来逐步缩小搜索范围。以右上角为例，如果查找数字大于右上角数字，则可删除所在行，如果查找的数字小于右上角数字，那么可以删去所在列，重复操作直至找到数字或者矩阵为空。 以上面的矩阵为例，假设我们要查找的数字是 10 ，先从右上角 9 开始，发现 10 &gt; 9，那么删去 9 所在的第一行，得到新矩阵 1232 4 9 124 7 10 136 8 11 15 再看新矩阵右上角数字 12，发现 10 &lt; 12，所以删除 12 所在的列，得到新矩阵 1232 4 94 7 106 8 11 再看新矩阵右上角数字 9，10 &gt; 9 ，删除 9 所在行，得到新矩阵 124 7 106 8 11 再看新矩阵右上角数字 10，发现刚好是我们所要查找的数字。 这样我们就找到了所要查找的数字。同样，如果以左下角开始查找也是类似的步骤，如果左下角的数字大于目标数字，那么删除最后一行，如果小于目标数字，则删除第一列，重复操作直至找到数字或者矩阵为空。 Java实现代码如下 12345678910111213141516171819public boolean searchMatrix(int[][] matrix, int target) &#123; if (matrix.length == 0) &#123; return false; &#125; int i = 0, j = matrix[0].length - 1; // 右上角开始查找 while (i &lt; matrix.length &amp;&amp; j &gt;= 0) &#123; if (matrix[i][j] &gt; target) &#123; // 删除所在列 j --; &#125; else if (matrix[i][j] &lt; target) &#123; // 删除所在行 i ++; &#125; else &#123; return true; &#125; &#125; return false;&#125; 左下角开始查找的代码类似，在这里就不写了。 这个算法用上了辅助空间，空间复杂度是 O(1)，时间复杂度是 O(m*n)，m``n分别是矩阵的长宽。","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"}]},{"title":"剑指 offer 02 - 单例模式","date":"2018-06-04T13:36:58.000Z","path":"2018/06/04/剑指offer-02-单例模式/","text":"题目 设计一个类，只能生成这个类的一个实例 单例模式是 GOF 23 种设计模式当中的一种，实现起来较为简单，只需要将构造方法设置为私有 priavte，并提供一个静态方法获取该类实例即可。代码如下： 1234567891011121314151617public class Singleton&#123; private static Singleton singleton = null; // 私有构造方法 private Singleton()&#123; &#125; // 懒汉式单例模式 public static Singleton getInstance()&#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; return singleton; &#125;&#125; 想要获取 Singleton 这个类的实例的话只需如下代码即可 1Singleton singleton = Singleton.getInstance(); 但是这种写法有一个问题，多线程情况下调用 getInstance() 方法时可能会被其他线程抢占执行权，最终生成多个实例。 因此，在多线程情况下，为保证单实例，需要加锁。代码如下： 1234567891011121314151617181920public class Singleton&#123; private static Singleton singleton = null; // 私有构造方法 private Singleton()&#123; &#125; // 懒汉式线程安全单例模式 public static Singleton getInstance()&#123; synchronized(Singleton.class)&#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; return singleton; &#125;&#125; 这样写已经没什么大问题了，每一个线程获取 Singleton 实例的时候都需要去拿锁，拿到锁之后生成实例，最终生成的实例只有一个。 但是如果考虑到性能的因素，那么还有更好的写法。 123456789101112131415161718192021public class Singleton&#123; private static Singleton singleton = null; // 私有构造方法 private Singleton()&#123; &#125; // 懒汉式双锁单例模式 public static Singleton getInstance()&#123; if (singleton == null) &#123; synchronized(Singleton.class)&#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125;&#125; 加锁会影响方法调用的效率，如果在拿锁之前进行判定是否实例化的话可以节省很多时间，这种写法能在保证多线程安全的前提下保持性能。 当然上面这种双锁的方式较为复杂，如果不在乎内存的话，可以采用饿汉式，类加载就初始化实例，这样的话也能保证线程安全和高性能。 1234567891011121314public class Singleton&#123; private static Singleton singleton = new Singleton(); // 私有构造方法 private Singleton()&#123; &#125; // 饿汉式 public static Singleton getInstance()&#123; return singleton; &#125;&#125; Effctive Java的作者则提倡使用enum来实现单例模式，保证线程安全并且还支持序列化，不过Java在1.5之后才加入enum机制，在兼容性上可能有些问题。 我还没来得及拜读Effctive Java，因此这种写法不是很了解，有兴趣可以自己去看看。","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"}]},{"title":"剑指 offer 00 - 总纲","date":"2018-06-04T13:02:58.000Z","path":"2018/06/04/剑指offer-00-总纲/","text":"临近招聘季，最近开始刷「剑指 offer」，现在已经刷到了 30+ 题。 之前野心勃勃的想写一个系列的文章，然而之前出差，项目还要验收，刷了题还没来得及写思路。现在稍稍闲下来一些，看看找到工作之前能刷到多少题吧，个人语言主Java，所以都使用Java实现。 在此设立一个总目录，立个 flag，督促一下自己的进度。 剑指 offer 01 - 赋值运算符函数剑指 offer 02 - 单例模式剑指 offer 03 - 二维数组中的查找剑指 offer 04 - 替换空格剑指 offer 05 - 从尾到头打印链表剑指 offer 06 - 重建二叉树剑指 offer 07 - 用两个栈实现队列剑指offer-08-旋转数组的最小数字剑指offer-09-斐波那契数列剑指offer-10-二进制中 1 的个数剑指offer-11-数值的整数次方 特殊情况说明 剑指 offer 01 内容是「赋值运算符函数」，这是 C++ 才有的内容，因此本序列不包含此题 另外，这系列文章偏实现为主，因为思路方面「剑指 offer」已经写的很详细了。","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"}]},{"title":"2018华为软件精英挑战赛","date":"2018-04-28T15:44:17.000Z","path":"2018/04/28/2018华为软件精英挑战赛/","text":"复赛已经结束了，决赛是不可能的，这辈子都不可能的，只能去复赛打个酱油混个绿卡这个样子 趁着机器学习的风，看到了华为的软件精英挑战赛，试了试水，要找工作了，简历上多点东西也好看一些。 毕竟华为说绿卡直接免笔试和面试，这岂不是美滋滋 华为的软件经营挑战赛每年都会有，不过最近机器学习实在太火，华为一改之前的网络和算法内容，直接换成了机器学习。 还想从去年的网络题目里学点东西来应付今年的比赛呢 题目描述详细的题目描述如下 智能世界 · 云动 题目的主要内容是预测。现在云服务器已经被业界普遍使用，用户可以灵活的根据不同需求申请不同规格的虚拟服务器，但这给云服务器带来了新问题，用户到底什么时候会申请什么规格的机器以及如何在物理机器上合理分配虚拟机以求得最大的物理资源使用率，这次大赛的主题就是围绕这两个问题的解决方法进行的。 大赛会提供一定的虚拟服务器历史申请数据，要求参赛者从这些数据中训练出一定的模型用于预测未来某一个时间段内一些类型的虚拟机的申请数量，再根据这些虚拟机申请数量在物理服务器中分配虚拟服务器。 也就是说，大赛主要分为两个阶段，预测阶段和放置阶段。 赛题思路和队友商量了一下，我先做预测部分，他做放置阶段，放置阶段相对而言简单一些，等他做好放置阶段再来和我一起讨论预测的事情。 「Andrew NG」大佬说过，机器学习这种事情，先别管那么多，撸个 basemodel 再来说话。 线性回归首先我选择了线性回归模型作为最初的预测方式，选取一个月内每一天的数量作为输入特征，也即 31 维的输入。通过梯度下降法求得 W 和 b，最终预测出结果。 通俗一点讲，就是求得一个月内每一天虚拟器出现的数量，然后根据所要预测时间的每个月的日期 （ 1 - 31 号）出现次数来预测最终的数量。 模型非常简单，但是完成这个模型我还是花了一点时间，因为在训练模型之前还有一件事情需要做，原始数据还没有处理。大赛给的数据都是虚拟机出现的时间和类型，需要把这些数据处理成用于训练的规格。 为什么这里会花一些时间，因为华为不让用第三方库， numpy pandas 之类的全部不让用，矩阵运算都得自己手写，花时间不说，写完了性能还特别差 写完结合队友的放置模型，第一次提交得了 53 分，根据得分调节了一下 学习速率 α ，最终拿到了 72 分，这个成绩在当时能进前 10 的样子。调参把当天的 100 次提交次数全用完了哈哈哈 和队友讨论了一下，发现官方居然给了初步的赛题思路，也是线性回归，但是输入特征维数是 7 而不是我写的 31 。官方给的放置阶段的思路是贪心，先放置规格大的虚拟机，放不下了再考虑规格小的。另外听闻官方给的思路得分好像还不错，这个时候队友也完成了放置阶段的代码，决定一起试一下官方的解题思路。 磨了一两天才开始写新的线性回归模型，但是最终的结果并不好，分数还有没之前的高，但是队友写的得分就很高，初赛快结束的时候才发现代码有 bug，当然那个时候也已经不用线性回归模型了。 LSTM实践最能磨砺人，模型到用时方恨少。 basemodel 的效果，降噪之后分数提升也不大，商量之后我打算试一试 「LSTM」。当然，这是在没有任何第三方库辅助下做种的艰难决定，我已经做好做不出来的准备了，不过大赛时间那么长，也足够用来试很多模型了。 这里说一下自己的感受，对于那种长时间的比赛，一定中途不能放弃，很多人都是开始那几天或者一周精力满满，排名变得很快，但是过了这阵子之后很多人就放弃了这个比赛，当然也有很多人是看书补充新的相关知识去了。 写 LSTM 的时候当然很无聊，上知乎搜了一下，发现一个很有意思的事情。如何评价2018年华为软件精英挑战赛赛题？ - 倪可塑的回答 - 知乎 期间排行榜刷的特别疯狂，我们名次很快降到了 30+，排行榜最高分达到了 96 ，之后华为修复了评分系统的 bug ，集体降了 8 分左右。 队友也尝试了 ARIMA 模型，最终能拿到83+的分数，再往上就上不去了。 LSTM 最终还是写出来了，但是跟之前写的线性回归一样，分数依旧上不去，怀疑之前切分数据等其他部分有 bug，花时间 review 了一下代码，果然有 bug 。。。 修复好 bug 之后先本地测试，发现预测率还不错，提交之后分数却一直上不了 80。 手写 LSTM 虽然超级麻烦，分数也不高，但的确对我理解 RNN 帮助很大，比起参赛之前只会直接调用第三方库好太多。 指数平滑调试完 LSTM 之后比赛已经到了后期，还没有一个特别好的模型，最高分数还是队友线性模型拿的 79。跟别的队交流了一下，我和队友又瞄上了指数平滑，开始疯狂的写代码。 这次用的是二次指数平滑，再加上去噪，去噪主要用的是正态分布的 μ + 3σ 法则，现将数据正态化，之后根据数据 μ + 3σ 范围进行去噪 。结果出来还不错，调一调参数最高能拿到接近 83 的分数。 当然，在指数平滑模型之外我们还有一些 trick，比如填充物理服务器以增加放置阶段的分数，还有将预测结果进行一定比例放大等等。这些都是取巧的手段，并不建议使用 初赛正式用例跑出来的分数还不错，244.6 ，感觉64强应该没什么问题，就看看能不能冲一下进个 36 强。不过正式用例提交次数一天只有 5 次，一共也就 2 天。这次运气还不错，调整了一下指数平滑里面的 α 之后分数提升了 2 分，最后进了 36 强。 初赛成绩 做到这里我和队友基本已经满足，毕竟 4 强并不是我等菜鸡的目标，能拿个华为的绿卡免技术笔试和面试已经很满足了。 复赛我和队友都没怎么搞，只是简单的根据复赛赛题修改了一下输入输出还有中间的一些处理，最终有了个分数不至于难看。 参赛感受 决赛是不可能的，这辈子都不可能的，只能去复赛打个酱油混个绿卡这个样子 一个人走得快，两个人走得远。整个比赛得好好感谢我的队友，方向基本以他为主，我在旁边打辅助。 参加竞赛做个项目果然是提升能力的好法子，之前学习的时候都是纸上谈兵，到实际用的时候就一脸懵逼了，感谢自己和队友这一个月的努力。 这次赛题给的特征过于稀疏，没有什么规律性，维度也只有一个，感觉能下手的地方不多，不知道大佬们用的是什么模型，特征又是怎么提取的，等赛后可以学习一波。 顺便吐槽一下西北赛区的地狱模式，西北赛区的 64 强在其他赛区基本都可以进 36 强了。 还剩几个月就要找工作了，感觉时间特别紧张。每年的招聘时间越来越靠前，以前都是 9 月份开始校招，暑假会开始有内推，现在 6 月份就有一些公司开始内推，算法和数据结构这些基础内容复习的时间越挤越少，还要应付实验室的项目，只能说自己好好加油了。","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://KingsFish.github.io/tags/机器学习/"},{"name":"软件精英挑战赛","slug":"软件精英挑战赛","permalink":"https://KingsFish.github.io/tags/软件精英挑战赛/"}]},{"title":"一双布洛克引发的思考","date":"2018-04-14T09:06:09.000Z","path":"2018/04/14/一双布洛克引发的思考/","text":"最近婷婷在网易严选剁手了一双布洛克雕花的女子皮鞋，作为一个 正事不干 爱钻研 稀奇古怪的事情 的人，她对皮鞋款式进行了深入的研究，最终写出了此文。 常见的皮鞋款式常见的皮鞋主要有牛津鞋、德比鞋、马靴、乐福鞋，正式程度递减。 牛津鞋一片式牛津鞋 One piece/Whole cut Oxford 平头牛津鞋 Plain Oxford 黑漆皮牛津鞋搭配礼服时最好换上宽鞋带以呼应领结 带有趾帽的牛津鞋 Captoe 在美式英语中， Balmoral 和 Oxford 基本上是被当做同义词来使用的，在特别讲究的英国人看来还是有区别的。下面这双鞋子牛津鞋的特殊之处在于鞋子侧面的接缝，是呈水平的一条线，而不是弯曲的，只有这样的款式，才是严格意义上的 Balmoral 。也就是说 Balmoral 是牛津鞋的一种。 Balmoral 牛津鞋和德比鞋 Oxford VS. Derby 牛津鞋侧边鞋翼向前延伸成为鞋面上的一部分，当用鞋带绑紧时，鞋翼会密合成为一整块鞋面，而鞋舌则是另外缝上，隐藏在鞋翼下面 Closed lacing 。 Derby 鞋是open lacing ，特点是鞋舌与整个鞋面采用一张皮革，两片鞋耳之间用鞋带固定出一些间距，所以它是可以通过鞋带去调解鞋子松紧程度的。 马靴/沙漠靴马靴也就是 Chukka Boots Chukka Boots 沙漠靴沙漠靴是由 Chukka Boots 衍生出来的 Desert Boots 马靴 VS. 沙漠靴 Chukka 的特点 沙漠靴的特点 1. 多为真皮、木质鞋底 1. 生胶 or 橡胶鞋底 2. 鞋面和鞋底连接处的走线是暗线 2. 鞋面和鞋底连接处的走线是明线 3. 鞋带是圆的 3. 鞋带是扁的 4. 有两个鞋带孔或更多 4. 有且只有两个鞋带孔 5. 侧面的襟片更窄，更靠后，形状与传统德比鞋类似 5. 侧面的襟片更宽，更靠前 6. 整体鞋型更窄更显得修长，并且鞋帮更高耸 6. 整体鞋型，包括鞋头，更扁平 文章来源：https://read01.com/JeQGL8.html 乐福鞋可以理解为“一脚蹬”，主要有一下几种： 便士乐福鞋 Penny Loafers乐福鞋上装饰一条带子横过脚背，并在带子上切了两个形似嘴唇的孔。 Penny Loafers 二战之后，美国常青藤的学生为了和自己的父辈在服装上产生分裂以达到思想上的改变，从而在开孔中放入一枚硬币以求幸运。 Penny 流苏乐福鞋这个应该不用解释了，就是用穗装饰的。穿这个鞋的时候不要穿袜子，至少不要让别人看出来你穿了袜子。 Tassel Loafers No socks 马衔扣乐福鞋向马鞍制造工艺取材，将小块金属衔扣装饰在鞋面上。 Gucci Loafers 原幅乐福鞋没有任何鞋面装饰的，也没有鞋面的缝合线。许多型男为我们示范出，棕色款是首选。 hole-cut Loafers 歌舞剧鞋观摩歌舞剧时穿的皮鞋款式，一般采用抛光黑色皮革，鞋面有丝质蝴蝶结装饰。 Opera Pumps 编织乐福鞋编织算是一种元素，可以和其他鞋型结合。 编织1 编织2 其他皮鞋款式孟克鞋Monk 鞋正式程度稍逊于牛津鞋，分为单扣和双扣两种，而单扣的 Monk 比双扣的则更为正式。 Monk 布鲁彻尔鞋重点看一下布鲁彻尔鞋和德比鞋的区别，德比鞋的襟片是独立的，缝在鞋面上，而布鲁彻尔鞋的襟片和鞋面是一整张皮。 Derby&Blucher 莫卡辛鞋 Moccasin可以看做乐福鞋的一种。 Moccasin 另外还有长马靴 Rider boots （现在一般人不会穿这个的）、短马靴 Johpur boots 、船鞋 Boatshoes 、牛仔靴 Cowboy Boot 、马丁靴 Dr Mskillsens 、工装鞋 Work shoes 、登山鞋 Hiking boots 、豆豆鞋/驾驶鞋、拖鞋 Slippers 。。。。没那么正式，就不展开说了。 切尔西靴 Chelsea boots 也是男鞋，但是周围穿切尔西的都是妹子，所以，我总感觉它是女鞋。。。 布洛克雕花布洛克指的不是款式，而是雕花。花纹越少越正式。 全布洛克、半布洛克、四分之一布洛克、长翼布洛克 上图中的四分之一布洛克更像是 Punch Toe Cap Brogue 。仔细看一下半布洛克、四分之一布洛克和 Punch Toe Cap Brogue 的区别。 Semi Brogue Quarter Brogue Punch Toe Cap Brogue 四分之一布洛克和半布洛克的区别是四分之一布洛克的鞋头表面 top cap 是没有雕花的，其他几乎都一样。相比于四分之一布洛克， Punch Toe Cap Brogue 雕花更少。 还有一种 Blind Wingtips ，鞋头表面没有花纹，只有 W 型镂空雕花。 Blind Wingtips 常见雕花 “徽章” “冲孔”也不全是圆的，比如还有钻石冲孔。 鞋带系法不知道大家有没有注意到，大部分图片里的鞋带并不像运动鞋那样交叉绑带，而是直线式的。具体要怎么绑呢？ 方法1 方法2 方法3 另外，正装鞋的鞋带，要选择打蜡的棉质鞋带。圆的或者扁的都可以。 参考文献 https://www.zhihu.com/question/29113372 牛津鞋 http://www.haibao.com/article/2124418.htm Balmoral https://read01.com/JeQGL8.html#.Ws9xgZq-mM8 沙漠靴 https://www.zhihu.com/question/22593119 Penny Loafers https://www.amazon.cn/gp/splinter/kol/c6b88c2b-c987-4d7e-b8ed-9e81b82c2286?ie No Socks http://www.secoo.com/style/expertstyle/vol32.shtml Gucci Loafers；hole-cut Loafers https://www.zhihu.com/question/40333883 孟克鞋；Derby&amp;Blucher；1/2 1/4 Punch Toe；Penny；牛津&amp;德比 https://zhuanlan.zhihu.com/p/31108178 莫卡辛鞋；其他 https://www.zhihu.com/question/28056987 全布洛克、半布洛克、四分之一布洛克、长翼布洛克 https://www.zhihu.com/question/24724961 Blind Wingtips；Blucher https://www.zhihu.com/question/20155377 徽章；牛津&amp;德比；其他 https://www.100how.com/Beauty/man/2015-10-01/7672_2.html 方法2 http://fashion.qq.com/a/20160814/003488.htm 方法1 https://www.zhihu.com/question/22260414 方法3","tags":[{"name":"tt","slug":"tt","permalink":"https://KingsFish.github.io/tags/tt/"},{"name":"外貌协会","slug":"外貌协会","permalink":"https://KingsFish.github.io/tags/外貌协会/"}]},{"title":"个人品牌","date":"2018-04-09T13:39:28.000Z","path":"2018/04/09/个人品牌/","text":"最近加入了 「stormzhang」 的知识星球，收获很多，觉得钱花的值，谈一谈相关的变化。 「stormzhang」 是技术出身，但是他的星球基本不讲技术，因为这些都能从 Google 得到，他讲的是 认知 。 「stormzhang」 说的好，他的知识星球是 认知付费 而不是 知识付费 ，加入知识星球之后我的认知也的确变化了很多，比如 「个人品牌以及流量」 、 「情商」 、 「风险与收益」 等等。 「stormzhang」 其实给自己就树立了一个很好的个人品牌，用他自己的知识和见识把自己塑造成一个引导者的形象，很多球友有大方向性的问题都会咨询一下他，随之而来的就是流量，有流量之后想要变现或者做其他事情就变得相对简单了。 这让我想起了婷婷实验室的师兄，姑且叫他 「灰灰」。「灰灰」技术能力很强，是他们实验室的技术顶梁柱，给实验室干活多到老师都不好意思不给他加钱，成功的在实验室树立了一个技术牛人的个人品牌。 除此之外，他也经常接私活，有着很好的口碑，现在已经不用自己出去找私活，会有人找上门了。其中这也有宣传的功劳，他做完一些项目会和别人宣传，这样就能更好的强化个人品牌。 此外还有 「小叔」 。他经常在睿思上分享干货，比如去年开始的 “互联网卡” 。 自己手里已经玩过了很多套餐，对这些有了很多了解，同时不忘在睿思上写攻略，虽然他自己可能并没有意识到，但是他已经成功的给自己塑造成了一个 “互联网卡王” 的形象，以我为例，平时有相关的疑问我都会问他。 有了个人品牌，随之而来一定流量，想要做些事情就简单很多。以 「互联网卡」 为例，他完全可以跟联通或者电信营业厅协商，自己做一个代理的角色，每从他手里办理一张卡可以拿到一些佣金。这仅仅是初步的，随着个人品牌的不断增强，可以有更多的手段。 婷婷其实无意中也做了一些这方面的工作，她订阅了 「得到」 里 「薛兆丰的北大经济学课」，并且在睿思上发帖，建了个群做免费分享，目的是找到一些和她一样希望开阔视野的人。在我这个工科学校里，能有学习经济学意识的人是珍稀动物。这样就初步建立了一个小圈子，并且把自己塑造成一个多方面学习爱好者的形象。后期如果继续下去，志同道合的人会越来越多，她也许能借此做一些付费知识分享的事情。 个人品牌越早树立，好处就越大，前期的成果还能源源不断的引流，「stormzhang」 之前在知乎回答了一个问题 「如何自学 Android 编程」 ，拿了最高票答案，到现在还会有很多人通过这个问题关注他的公众号继而了解他的知识星球。 就个人目前而言，树立个人品牌最主要的手段还是要增强自己的专业能力，走 「灰灰」 的路线，先有深度，而后有广度。其实自己也意识的做了一点，比如自己搭建的博客，还有和 「freedom10086」 共同开发的睿思APP。但可能技术不够深入，所以效果不是很好，但是也给自己带来了一定流量。 树立个人品牌之路艰难而漫长，每一步都需要不同的策略，我现在还处于从 0 到 1 的部分，仍需继续加油。","tags":[{"name":"知识星球","slug":"知识星球","permalink":"https://KingsFish.github.io/tags/知识星球/"}]},{"title":"Kaggle初步-Titanic之灾","date":"2018-02-28T14:55:37.000Z","path":"2018/02/28/Kaggle初步-Titanic之灾/","text":"今天尝试了一下kaggle，从最简单的训练题开始做机器学习的项目。 训练题有三个，我选择了第一个“泰坦尼克之灾”进行尝试。 泰坦尼克之灾 房价预测 数字识别 “泰坦尼克之灾”背景是大家所熟悉的那个Jack and Rose的故事。豪华游艇要沉了，大家都惊慌逃生，可是救生艇数量有限。副船长发话了“Lady and Kid First！”，所以获救与否非随机，而是与一些因素相关的。 训练和测试的数据是乘客的一些信息以及获救情况，需要根据这些数据来预测其他乘客的存活情况。 这应该是一个二分类问题，也即Logistic Regresstion所能处理的范围。 大致浏览了一下数据，乘客的信息主要由这些： PassengerId =&gt; 乘客ID Pclass =&gt; 乘客等级(1/2/3等舱位) Name =&gt; 乘客姓名 Sex =&gt; 性别 Age =&gt; 年龄 SibSp =&gt; 堂兄弟/妹个数 Parch =&gt; 父母与小孩个数 Ticket =&gt; 船票信息 Fare =&gt; 票价 Cabin =&gt; 客舱 Embarked =&gt; 登船港口 提供的信息较多，刚开始觉得无所适从，记得Andrew NG老师说过，做机器学习的时候不要一上来就试图完美，先做一个基本的模型跑起来，有了结果之后再去优化这个模型或者做一个新的模型。 依据看电影得来的经验和数据 乘客的ID只是一个递增的数字，与结果没有太大的关联，所以直接舍 乘客的舱位等级肯定会影响存活与否 “Lady and Kid First！”也会涉及到性别对存活的影响，年龄也是如此； 堂兄弟/妹的个数似乎无法判别对最终结果的影响，暂时留存； 父母与孩子个数也是如此；船票信息主要是票号，对最终结果无太大影响，舍去； 票价和客舱信息应该是相关的，每个舱的价格不同，所以只取其一即可，票价作为一个连续的变量更好处理，但是查看数据后发现票价信息缺失了很大一部分，故此最初的模型暂不考虑影响； 登船港口无法判别，因此也暂时保留。 需要注意的是，在代码中，所有的数据都是以数字来保存的，但是给定的数据中很多都是字符串，比如性别，因此我们需要对数据进行一定的预处理，此模型中所使用的是pandas.get_dummies()函数。同时也要丢弃上面所说的无关数据。 之后使用sklearn的线性回归模型，设定好loss喂入数据即可。 预测时需要注意的是，测试数据也和训练数据一样需要进行相应的预处理。 以下是这个初步模型的最终代码。 代码点此下载 纸上得来终觉浅，之前跟着Andrew老师学习了那么多理论知识，但是到实战的时候感觉不知道怎么用，还是需要多做项目来提升自己的能力。 2018-03-02更新： 经过以下的优化： 去除登船港口特征 加入客舱特征，因客舱数据缺失并且类目太多，所以将客舱数据重新分成两类，“有客舱数据”和“无客舱数据” 正确率提高了1个百分点，排名从之前的8000+前进到了6001 排名 代码点此下载 参考文献机器学习系列(3)_逻辑回归应用之Kaggle泰坦尼克之灾","tags":[{"name":"机器学习","slug":"机器学习","permalink":"https://KingsFish.github.io/tags/机器学习/"},{"name":"kaggle","slug":"kaggle","permalink":"https://KingsFish.github.io/tags/kaggle/"}]},{"title":"增加gitment踩过的坑","date":"2018-02-27T06:45:04.000Z","path":"2018/02/27/增加gitment踩过的坑/","text":"之前博客使用的评论系统是disqus，用了一段时间之后发现，用disqus来评论的人很少，这才有了更换评论系统的想法。 其实最重要的原因是disqus貌似无法在国内使用，被GFW挡住了。虽然对于我来说不是什么问题，但是不能要求每个读者都有这项技能。 之前搜索时发现还有挺多的第三方评论系统，可以参考第三方评论系统选择。考虑到我的博客托管在Github，而且博客受众很多也是Github用户，干脆全部放到Github好了。 Gitment 是作者实现的一款基于GitHub Issues的评论系统。支持在前端直接引入，不需要任何后端代码。可以在页面进行登录、查看、评论、点赞等操作，同时有完整的 Markdown/GFM和代码高亮支持。尤为适合各种基于GitHub Pages的静态博客或项目页面。 备忘-配置流程增加gitment之前需要确认你的博客所使用的主题集成了gitment系统，我所使用的主题是indigo，已经集成了gitment。 确认之后第一步是在Github增加认证程序 OAuth Application 需要填写以下内容 OAuth 其中最重要的是Authorization callback URL，这个需要填写你的博客地址，上图是我所填写的内容示例。 注册成功之后会拿到client id和client secret。 拿到这两个东西之后，在本地的hexo主题配置文件_config.yaml里添加gitment。示例如下： 配置 owner: 填写你的Github用户名 repo: 用于存储评论的仓库，我这里直接使用博客的仓库，也可以另外创建仓库用于存储评论 client_id: 上一步申请到的client id client_secret: 上一步申请到的client secret 到这里差不多已经配置好了，只需要初始化一下 重新生成你的博客页面 在评论框登陆Github账号 登录之后初始化评论 踩过的坑注意，不要在本地进行评论测试。 Error: Not found owner或者repo配置错误了，按照上面的教程重新配置一下就好。可以通过查看生成网页查看是否配置好 web 这是我已经配置好后hexo生成的页面一部分。 如果确信owner和repo以及拿到的client id和client secret都没错，那么可以使用如下方法写死（不建议使用这种方法）。 打开hexo的主题目录，找到themes\\hexo-theme-indigo\\layout\\_partial\\plugins\\gitment.ejs打开（此路径仅适用于indigo主题，其他主题请换成相应的文件），修改成如下内容： gitment 之后重新生成页面即可 Error: Comments Not Initialized 第一步在Github增加认证步骤中，Authorization callback URL填写错误。此时只需在Github申请页面修正即可。 没有登陆Github账号。登录账号即可。 Error: validation failed每一篇文章的评论都是作为一个issue存在于仓库中，因此有一个唯一的id，但是Github对此id长度有限制，出现该错误就是因为id过长，默认传递的id应该是文章的题目，很容易过长。 解决方法是自己设立一个不会过长的id，在搜索了资料之后发现可以使用文章日期，这样就能随意起标题啦。具体如下： 与Error: Not found类似，打开themes\\hexo-theme-indigo\\layout\\_partial\\plugins\\gitment.ejs，增加id一栏 gitment 参考资料： 添加Gitment评论系统到Hexo主题NexT 初始化出现 Error: Not Found 评论系统集成 Gitment","tags":[{"name":"gitment","slug":"gitment","permalink":"https://KingsFish.github.io/tags/gitment/"}]},{"title":"即将过去的2017","date":"2017-12-26T14:54:35.000Z","path":"2017/12/26/即将过去的2017/","text":"下午和婷婷一起逛人人乐，婷婷突然说起罗胖（罗振宇）的跨年演讲，我才发觉到，2017已经快要过去了。跟婷婷讨论罗胖2016年跨年演讲好像才是昨天，罗胖却马上要进行第二次跨年演讲了。罗胖信誓旦旦的要开20年的跨年演讲，也不知道最后能不能实现，反正他已经把20年的钱收了（手动滑稽）。 一件事要坚持20年大概很难吧，不过很开心的是我就有两件事情坚持了20多年，吃饭和睡觉。 说起吃饭，今年又花了好多时间用来吃吃喝喝，我最近老是觉得我把钱都花在吃吃喝喝上面，恩格尔系数特别高，没事就带着婷婷出去吃东西，回民街逛成了自家后院。学校周边的吃的也没能幸免，科技路的小肥羊，融鑫路的马虎面，后街有名的芳芳餐厅，还有胡杨林餐厅都去吃了个开心。 像我这么个吃法，再加上渐渐减少的锻炼，长胖是必然的事情，5月份还是65kg上下，等到12月就成了70kg。不过还好，西电学生众筹的引擎健身终于开张了，9月初打算的健身，健身计划都写好了，为了等这个健身房开张，我足足给了自己3个月时间长肉……前两天去练了两次，不过鉴于之前太久没有锻炼，随便练一练，第二天就浑身酸爽，差点下不了床。等过几天好了要赶紧去，但愿回家之前能把身上的脂肪减一减。 最近没事常和婷婷聊实验室的事情，内容大概就是在实验室做了什么东西，在实验室又发生了什么开心的事情。就项目而言，我一直觉得时间不够，项目需要很多时间来做，这样自己的时间就少了很多。婷婷却觉得我做项目很有效率，因为在她的印象里我大部分时间好像都和她出去探（吃）索（吃）美（喝）食（喝）了，哪来的时间做项目，对于她这个想法我竟无话可说。 虽然说是天天和婷婷出去探索美食，但是想想其实这一年也做了一些事情。上半年还有课，所以项目时间不多，先是完成了老板去年10月份给的小任务——配置串口，这一个任务折腾了我两三个月，万幸在过年之前搞定了。 接下来就是FreeSwitch里面的命令行扩展。FreeSwitch全是用C语言写的，这个项目倒是让我好好的复习了一下C语言。大概花了2个月不到的时间完成了大部分的功能，为了偷懒当时还省了一部分代码没写，结果就是网页端在请求一部分数据的时候奇卡无比，研二的时候实在受不了了才补充完整。 暑假也没闲着，又有了压力测试的活，不过另外一件更重要的事情是终于在Github Page上搭建了自己的博客，有了自己一个写东西的地方。虽然在自己的服务器上也能搭一个，并且自由度更高，但是我只是单纯的想写点东西而已，并不想折腾那么大的功夫，而hexo + Github Page还能支持Markdown语法，所以最终还是选择了hexo + Github Page的方式。 除了搭建博客之外暑假还挤出来一点时间去拿了驾照，家里早就让我赶紧去拿个驾照，过年回家的时候开车回家的时候我爸就能有个人换换手。其实拿驾照也没有想象中那么难，但是学车累倒是真的，练科二场地和科目三的时候起的太早了，6:50学校门口的班车，那么起床最晚6:20。前一天睡得还晚，练个车一天人都不好了。万幸的时候所有科目都是一把过，最后拿驾照的时候感觉很平常，婷婷说我根本就没有付出什么精力，怎么会有那种如释重负的感觉。她当初学车的时候真的是累了个半死，天天都去练车，整个暑假都耗在上面了。 考科二的时候家里出了点事，最后回了一趟。算是第一次亲历身边亲人的死亡，之前年纪还小，外婆外公还有曾祖母去世都没有什么太大的感觉。生命真的很脆弱，惟愿家人身体健康。 技术方面做的比较差。Android落下了很多，想写的两个程序到现在已经都没怎么动；深度学习入了个门，不知道到时候找工作能不能用的上。还剩下几个月就要找工作了，还不知道到时候会怎么样呢。 Github 今年最大的改变以及收获应该要算接触了理财和经济学。之前不了解的原因，一向视理财为洪水猛兽，但是婷婷把我带进了门，现在自己用钱也能够赚一点点小钱，不指望能够实现财富增值，最起码能够跑赢通货膨胀，让自己的钱不会贬值。在婷婷的“带领”下我也接触了很多非技术方面的东西，比如艺术、人物传记、文学历史。未来光是技术水平高是不够的，不可能一辈子做技术，平时的确应该多接触其他方面的知识，虽然当时可能觉得没什么用处，但是以后职业生涯转型的时候，也许某一方面的视野就能给你很大的助力。 絮絮叨叨没有什么逻辑，想到什么写什么，整个想想其实这一年并非一事无成，唯一的遗憾大概是没有好好珍惜时间，技术水平没有什么很大的提升。 2017马上就要结束了，也给自己定个小目标吧，把16年计划的17年未完成的目标写进18年。 努力提升自己的技术水平，明年秋招给自己找一份满意的工作 规律健身，提升身体素质 阅读经济学书籍，了解更多的经济学知识，学习更多的理财方式 学习怎么让自己更有意思 …… 憧憬未来总是美好的，希望自己能在下一年实现”小目标“，让自己的能力更进一步。","tags":[]},{"title":"Leetcode-421-Maximum-XOR-of-Two-Numbers-in-an-Array","date":"2017-12-15T03:46:29.000Z","path":"2017/12/15/Leetcode-421-Maximum-XOR-of-Two-Numbers-in-an-Array/","text":"很久没有写Leetcode刷题的相关博客了，一来最近比较懒，二来刷的那些题目都不难，没有给我什么新的知识点，就没有写。今天碰到了一个位操作的题，以前这类题目我是不会去碰的，因为不熟悉，但是终究是要接触的。这道题一开始我并没有写出来，提交结果超时，在参考了其他人的解法思路后最终通过。 题目如下： Given a non-empty array of numbers, a0, a1, a2, … , an-1, where 0 ≤a i&lt; 231. Find the maximum result of a i XOR a j , where 0 ≤ i, j &lt; n.Could you do this in O(n) runtime?Example: 123Input: [3, 10, 5, 25, 2, 8]Output: 28Explanation: The maximum result is 5 ^ 25 = 28. 题目大意给定一个非空数组，里面所有数字属于区间(0, 231)。找出这个数组中两两异或的最大值。要求时间复杂度为O(n) 思路naive solution最简单的方法当属暴力搜索，两层循环，记录最大的异或值即可，代码比较简单，但是会超时。 123456789public int findMaximumXOR(int[] nums) &#123; int result = 0; for(int i = 0; i &lt; nums.length; i++)&#123; for (int j = i + 1; j &lt; nums.length; j ++)&#123; result = Math.max(nums[i] ^ nums[j]); &#125; &#125; return result;&#125; 此种解法时间复杂度为O(n2)，空间复杂度为O(1) better solution我们还需要用上一个异或的特性，假设a和b产生了最终的答案max，即a ^ b = x，那么根据异或的特性，a ^ x = b。同理，a和b的最高位（前n位）也有相同的性质。 先以最高位为例子，我们可以把所有的数字的最高位放到一个HashSet里面，然后使用1与set里面的所有数字进行异或，如果得出的结果仍然在set里面，那么最终结果的最高位必然为1，否则为0。也即，先假定结果为1，然后与set中所有数字异或，假定a与1异或得到结果b（a ^ 1 = b），而b仍然在set里面，那么说明set中有两个数字异或能得到1（a ^ b = 1）。否则，set中没有两个数字能够异或得到1，那么最终结果的最高位为1的假设失败，说明最终结果的最高位为0。以此类推可以得到第二位、第三位。。。的数字。 再做一下推广，我们将所有数字的前N位放到一个HashSet里面，然后使用之前N-1位得到的最大值前缀prefix与set里面的所有数字进行异或，如果得出的结果仍然在set中，那么第N位必然为1，否则为0。 举个例子，给定数组[14, 11, 7, 2]，二进制表示分别为[1110, 1011, 0111, 0010]。题目说了，数字最长不会超过32位，所以应从i = 31开始，但是所有数字中最多位4位数，简单起见，我直接从最高位i=3开始 12341. i = 3, set = &#123;1000, 0000&#125; =&gt; max = 10002. i = 2, set = &#123;1100, 1000, 0100, 0000&#125; =&gt; max = 11003. i = 1, set = &#123;1110, 1010, 0110, 0010&#125; =&gt; max = 11004. i = 0, set = &#123;1110, 1011, 0111, 0010&#125; =&gt; max = 1100 最终答案是1100 =&gt; 12，1011 ^ 0111 = 1100(11 ^ 7 = 12)。 Java版代码如下 12345678910111213141516171819202122232425public int findMaximumXOR(int[] nums) &#123; int max = 0; int mask = 0; for(int i = 31; i &gt;= 0; i --)&#123; // 为获取前n位的临时变量 mask = mask | (1 &lt;&lt; i); HashSet&lt;Integer&gt; set = new HashSet&lt;&gt;(); for(int num : nums)&#123; // 将所有数字的前n位放入set中 set.add(mask &amp; num); &#125; // 假定第n位为1,前n-1位max为之前迭代求得 int tmp = max | (1 &lt;&lt; i); for(int pre : set)&#123; // 查看`b`是否在 if(set.contains(tmp ^ pre))&#123; // b存在，第n位为1 max = tmp; break; &#125; &#125; &#125; return max;&#125; 此解法时间复杂度为O(32n)=O(n)，空间复杂度上，我们使用了一个HashSet用于存储所有数字，因此空间复杂度是O(n)。和暴力搜索解法相比，典型的空间换时间。附上AC时间图 提交结果 anothor better solution我以为，上面的解法已经是最佳解法了，结果却发现前面还有一个提交时间小山峰，查看了一下发现有更好的解法，此解法用到了Tries的数据结构。此数据结构我从来之前都没听说过，研究了一下算法后发现，其实Tries类似于二叉树，主要的思路是这样：构建一棵深度为33的二叉树。root节点左孩子为1，右孩子为0代表着所有数字的最高位，其次根据次高位继续往下。如果某一个节点左右子树都不为空，那么得到最终答案的两个数字肯定分别出自于左右子树且此位为1；如果任意一个为空，那么最终答案该位为0，依次迭代得到最终结果。对此解法我并没有详细研究，感兴趣的可以自己去看看Java O(n) solution using Trie cheat solution是的，通过查看时间表我发现了一个作弊的答案。 此题一共29个测试用例，最后一个测试用例是用来测试时间复杂度的，长度是20000。超时的原因就是因为这最后一个测试用例，因此有答案直接对此做了特殊处理，然后使用暴力解法……最后只用时15ms 123456789101112131415public int findMaximumXOR(int[] nums) &#123; if(nums.length == 20000)&#123; return 2147483644; &#125; long max = 0; for (int i = 0; i &lt; nums.length; i++) &#123; for (int j = i+1; j &lt; nums.length; j++) &#123; long xor = nums[i] ^ nums[j]; if (xor &gt; max) &#123; max = xor; &#125; &#125; &#125; return (int) max;&#125; 可怕的人类！","tags":[{"name":"BitManipulation","slug":"BitManipulation","permalink":"https://KingsFish.github.io/tags/BitManipulation/"},{"name":"Tries","slug":"Tries","permalink":"https://KingsFish.github.io/tags/Tries/"}]},{"title":"大雪","date":"2017-12-07T12:16:52.000Z","path":"2017/12/07/大雪/","text":"冬季是个进补的好时间，入冬以来根本无心学习科研，博客也快两个月没写，天天都想着怎么出去吃吃喝喝。 闲来无事逛睿思才发现今天是大雪，我还沉浸在还是秋天的时间，固执的认为现在还没到每年最冷的时候。想着我的胃每日被西区食堂难吃又贵的饭菜摧残，果断出去吃粉汤羊血。 冷的时候就天天想着冒着热气的食物，已经很久没有来惠记粉汤羊血了。屋里人依旧多，都在聊天。我跟婷婷开玩笑说，人家都是带着瓜子来聊天顺便吃饭，只有我们只是来吃饭的。 粉汤羊血吃成我这样的，估计也就我一个。婷婷说被我吃成了粉汤羊血泡馍，我倒是觉得把馍掰进去，让它吸收羊血饱满的汤汁，这样才是完整的吃完了粉汤羊血。 在这种氛围下，喝一点酒浑身发热最是尽兴，然而婷婷不跟我一起，店里也没有小容量的白酒，况且我酒量也差，只能要了一瓶冷冰冰的9度，最后也没喝完。 说起白酒想起了买的白酒基金。最近大盘一直在跌，自从上次茅台被点名批评了之后一直下挫，身为龙头带动整个白酒行业一路下行，再加上白马股估值过高在调整，我的资产已经从最高峰的挣了1000到现在的亏200，而原先涨势最差的嘉实虽然挣得不多，却一路高歌，收益率快到6%了。 虽然损失惨重，不过经历了这些我重新审视了一下自己的投资分配，回撤率过高，并且行业单一，涨的时候挣得多，但是跌的时候也会跌的很惨。 不过我却不担心会一直亏下去，毕竟我投的那些行业都是未来很有发展前景的，长期持有肯定不会错，这一波调整之后肯定会有新的行情，指不定明天就涨了呢。 食物能给我很大的幸福感，特别是在寒冷的冬天。约上三两个好友一起热热闹闹的吃个火锅，聊一聊最近的事情，不知道有多开心。婷婷一直都很奇怪为什么吃饭这种事情都能让我那么开心，其实我也很奇怪为什么她吃饭会不开心（滑稽.jpg）。 上次去澡堂子洗澡的时候称了一下体重，发现相比于一年前已经增加了10斤。现在我终于能理解为什么那些运动员退役之后都会体重增加了，运动少了，食量却没有变，怎么可能不变胖！或许我该开始去健身房了。","tags":[]},{"title":"时间时间","date":"2017-10-19T03:16:07.000Z","path":"2017/10/19/时间时间/","text":"近来越来越觉得时间不够用，科研有了新任务，自己想要接触新的领域，之前的技术还不能落下。 9月份一直在练车，老板之前给的任务没有头绪，也就一直拖着。国庆假之后就变得事多起来，新项目在谈，而且还是两个。不过庆幸的是，这两个项目大体跟之前这个类似，主要需要修改一些细节，工作量倒是减轻了很多，近期的主要任务是搞定老项目的遗留问题。 剩下的其实都是自身技能的提升。一是算法和基础继续看，比如操作系统，网络编程等等。二是Android，最近需要多练练手，手里大概有两个想法，一是视频APP，二是定位APP，做这两个APP需要学的东西还挺多。三是机器学习，主要也是两部分，Coursera上的课程，以及kaggle。为了简历上有东西，这两个都不能少。 其实我也不知道明年到底找哪方面的工作，看今年的形势，移动开发风口已过，Android方面的工作相比于之前少了很多。而机器学习基本上是近来最热门的的方向了，但是机器学习我也才刚入门，只怕到时候简历上面没什么可以写，希望kaggle能给自己增点料。记得去年见过知乎的机器学习大赛，内容大概是给定一些文本，要求出tag，相当于知乎上面的标签。不知道今年还有没有，可以去试试练个手。 再过两个月就要写开题报告了，毕设论文要做什么现在还不清楚，又是一件耗脑力耗时间的事情。 逝者如斯夫，不舍昼夜，好好珍惜时间。","tags":[]},{"title":"Leetcode-29-Divide-Two-Integers","date":"2017-10-11T13:11:07.000Z","path":"2017/10/11/Leetcode-29-Divide-Two-Integers/","text":"题目如下： Divide two integers without using multiplication, division and mod operator.If it is overflow, return MAX_INT 题目大意给定两个数字，求出它们的商，要求不能使用乘法、除法以及求余操作。 思路题目要求不能使用乘法、除法以及求余操作。 我们知道，乘法是可以由加法来代替计算的，将除数一直累加直至超过被除数。但是仔细考虑之后发现，如果使用加法，那么时长可能会过长。假设给定1和10000000，由1加到10000000，最后的结果肯定是超时。 既然不能直接累加，那么还有什么新的方法呢？我们直到，二进制是可以表示所有数字的。那么在这题中使用二进制来逼近是较为迅速的办法。 假定商是l，那么l一定可以用二进制来表示，也即2的幂和，5=22+21。那么所需要做的也就是累加除数与2的幂次乘积，直至刚好超过被除数，然后从最大的次幂开始计算，如果当前的和加上该次幂大于被除数，那么放弃该次幂，如果加上该次幂仍然小于被除数，那么就加上该次幂。 举个例子，假设除数为3，被除数为16，那么商应该是5。我们从2的0次幂与除数的乘积也即20x3=3开始，幂次逐渐增加，直至超过被除数。可以看出，当幂次达到2时刚好超过16（3x20+3x21+3x22=21&gt;16）。那么从3x22开始往下累加，3x22=12&gt;16，那么记录下22=4。再看3x21，发现3x22+3x21=18&gt;16，因此略过21=2。再看3x20，发现发现3x22+3x20=15&lt;16，那么将20=1记录下。次幂累加结束，计算一下商，分别记录了4和1，因此结果4+1=5，此答案也即为最终的商。 算法大概的思路差不多讲完了，还需要注意的就是边界问题，只有一个边界特例需要考虑Integer.MIN_VALUE和-1。此时的结果超过了Integer所能表示的最大范围，因此需要特殊处理。其次，为了简单起见，我们将除数和被除数的符号进行记录，然后将其转换为正数进行计算，这也涉及到溢出的问题，Integer.MIN_VALUE转换为正数之后会超过32位Integer所能表示的范围，因此在代码中使用long类型进行计算防止溢出。 此算法时间复杂度是O(logn)。空间复杂度为O(logn)。Java版的代码如下， 123456789101112131415161718192021222324252627282930313233343536public int divide(int dividend, int divisor) &#123; if(dividend == -2147483648 &amp;&amp; divisor == -1)&#123; //防止溢出 return 2147483647; &#125; ArrayList&lt;Long&gt; list = new ArrayList&lt;&gt;(); int end = dividend &gt; 0 ? 1 : 0; int sor = divisor &gt; 0 ? 1 : 0; long a = Math.abs((long)dividend); long b = Math.abs((long)divisor); int ret = 0; list.add(b); long i = 1; //记录除数与二次幂的乘积 while (b &lt;= a)&#123; b += b; i += i; list.add(b); &#125; long sum = 0; //累加 for (int j = list.size() - 2; j &gt;= 0; j --)&#123; i &gt;&gt;= 1; if (sum + list.get(j) &lt;= a)&#123; ret += i; sum += list.get(j); &#125; &#125; //根据除数以及被除数的正负确定返回值正负 if (end + sor == 1)&#123; return -ret; &#125; else &#123; return ret; &#125;&#125; 提交结果如下： 提交结果","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://KingsFish.github.io/tags/Binary-Search/"}]},{"title":"国庆小记","date":"2017-10-09T08:38:41.000Z","path":"2017/10/09/国庆小记/","text":"所谓的“3+7=8”有时候是正确的，当中秋碰上国庆，好好的十天假就缩水成了8天。不过对于我来说其实没有什么特别大的区别，研二没有课之后其实想要放假的话每天都可以是一个开心的假期。 国庆之前打算的出游计划是去趟太白山一睹风光，在西安待了5年多，离西安只有100多公里的名山也还没有去看过日出；然后去看看壶口瀑布，恰逢黄河汛期，景色想来也不错。然而婷婷一心扑在论文上，无心出远门逛，我的假期只得在市内度过了。 国庆假的前几天无非是出去逛吃逛吃，本来打算把钟楼和鼓楼逛一下，结果身体因素也没有去成。中秋中午陪舍友去了芳芳，刚好婷婷也陪她舍友出去逛，晚上突发奇想尝一下东北菜，婷婷也很支持，虽然大部分她也没吃过，不过味道还是很不错的。 东北王酱骨 国庆唯一的活动就是拖着几个月没练的身体去分水得瑟。说得瑟那当然是贬义的，上到二道桥也就行了，结果在米老板的蛊惑之下又作死往上爬了10KM，差点骑不动。不过下来吃肉很开心，米老板跟农家乐的老板认识，都不用点菜，等着吃就行。 大盘鸡 吃完集体去了一趟观音禅寺，寺里好像在改造，多了许多菩萨像。这次来的不是时候，千年银杏树的叶子绿意盎然，还没有变黄的迹象。据传这颗银杏树是唐太宗李世民所种，距今已经有1400多年的历史。下次等银杏树落叶可以叫上婷婷过来一起看。 在观音禅寺闲聊时讨论到晚饭的问题，最后大家一致决定要去大猫猫家吃火锅。可惜大方向错误，买菜的大任居然交给了两个素食主义者，这可是8个人的聚餐，最终只买了两包肉卷还有一点鱼丸，剩下的全是青菜，大家都纷纷表示强烈的谴责。 没有肉的火锅 回想起来，已经很久没有过这种骑车后热热闹闹吃个饭的经历了。老朋友们远的没办法聚，近的大家也都有自己的事情，骑车的热情也慢慢减少，没有精力去认识新的小伙伴。也许这就是常态，聚少离多。不过，生活还是要向前看。","tags":[]},{"title":"深度学习实践05-优化算法","date":"2017-09-29T01:34:07.000Z","path":"2017/09/29/深度学习实践05-优化算法/","text":"这周的课程开始了新的优化算法，优化的主要措施有以下三种： Mini-Batch梯度下降算法 Momentum算法 RMSprop算法 Adam算法 Mini-Batch梯度下降算法此算法与之前的梯度下降算法差别在于数据的迭代方式，梯度下降法直接将整个数据集进行训练，而Mini-Batch梯度下降算法则是根据一定条件将整个数据集进行分割，每个小数据集进行一次梯度下降，其实梯度下降法是MiniBatch算法的一个特例。具体实现的时候，Mini-Batch与梯度下降的主要区别是(1)分割数据集(2)增加数据集的内部循环。与梯度下降差别不大，在这里就不实现了。 partition.png Momentum算法Momentum算法与梯度下降算法的差别在于参数W和b的更新。更新的公式变成了下面的公式。 更新公式 也就是说，参数更新时的变化量从dW变成了Vdw，其他的没有很大的变化，其中t为。实现代码如下： 12345678910111213141516def update_parameters_with_momentum(parameters, grads, v, beta, learning_rate, t): L = len(parameters) // 2 for l in range(L): v[\"dW\" + str(l+1)] = beta * v[\"dW\" + str(l + 1)] + (1 - beta) * grads['dW' + str(l + 1)] v[\"db\" + str(l+1)] = beta * v[\"db\" + str(l + 1)] + (1 - beta) * grads['db' + str(l + 1)] v_corrected[\"dW\" + str(l+1)] = v[\"dW\" + str(l+1)] / (1 - beta1**t) v_corrected[\"db\" + str(l+1)] = v[\"db\" + str(l+1)] / (1 - beta1**t) parameters[\"W\" + str(l+1)] = parameters[\"W\" + str(l+1)] - learning_rate * v[\"dW\" + str(l+1)] parameters[\"b\" + str(l+1)] = parameters[\"b\" + str(l+1)] - learning_rate * v[\"db\" + str(l+1)] return parameters, v RMSprop算法RMSprop算法与Momentum算法类似，差别在于更新参数的方式。公式如下； 迭代公式 实现代码如下 123456789101112131415def update_parameters_with_momentum(parameters, grads, s, beta, learning_rate, t, epsilon=10e-8): L = len(parameters) // 2 for l in range(L): s[\"dW\" + str(l+1)] = beta2 * s[\"dW\" + str(l + 1)] + (1 - beta2) * (grads['dW' + str(l + 1)]**2) s[\"db\" + str(l+1)] = beta2 * s[\"db\" + str(l + 1)] + (1 - beta2) * (grads['db' + str(l + 1)]**2) s_corrected[\"dW\" + str(l+1)] = s[\"dW\" + str(l+1)] / (1 - beta2**t) s_corrected[\"db\" + str(l+1)] = s[\"db\" + str(l+1)] / (1 - beta2**t) parameters[\"W\" + str(l+1)] = parameters[\"W\" + str(l+1)] - learning_rate * parameters[\"W\" + str(l+1)] / (np.sqrt(s_corrected[\"dW\" + str(l+1)]) + episilon) parameters[\"b\" + str(l+1)] = parameters[\"b\" + str(l+1)] - learning_rate * parameters[\"b\" + str(l+1)] / (np.sqrt(s_corrected[\"db\" + str(l+1)]) + episilon) return parameters, s Adam算法Adam算法综合了Momentum算法和RMSprop算法，更新公式如下 迭代公式 实现如下： 123456789101112131415161718192021222324def update_parameters_with_adam(parameters, grads, v, s, t, learning_rate = 0.01, beta1 = 0.9, beta2 = 0.999, epsilon = 1e-8): L = len(parameters) // 2 v_corrected = &#123;&#125; s_corrected = &#123;&#125; for l in range(L): v[\"dW\" + str(l+1)] = beta1 * v[\"dW\" + str(l + 1)] + (1 - beta1) * grads['dW' + str(l + 1)] v[\"db\" + str(l+1)] = beta1 * v[\"db\" + str(l + 1)] + (1 - beta1) * grads['db' + str(l + 1)] v_corrected[\"dW\" + str(l+1)] = v[\"dW\" + str(l+1)] / (1 - beta1**t) v_corrected[\"db\" + str(l+1)] = v[\"db\" + str(l+1)] / (1 - beta1**t) s[\"dW\" + str(l+1)] = beta2 * s[\"dW\" + str(l + 1)] + (1 - beta2) * (grads['dW' + str(l + 1)]**2) s[\"db\" + str(l+1)] = beta2 * s[\"db\" + str(l + 1)] + (1 - beta2) * (grads['db' + str(l + 1)]**2) s_corrected[\"dW\" + str(l+1)] = s[\"dW\" + str(l+1)] / (1 - beta2**t) s_corrected[\"db\" + str(l+1)] = s[\"db\" + str(l+1)] / (1 - beta2**t) parameters[\"W\" + str(l+1)] = parameters[\"W\" + str(l+1)] - learning_rate * v_corrected[\"dW\" + str(l+1)] / (np.sqrt(s_corrected[\"dW\" + str(l+1)]) + epsilon) parameters[\"b\" + str(l+1)] = parameters[\"b\" + str(l+1)] - learning_rate * v_corrected[\"db\" + str(l+1)] / (np.sqrt(s_corrected[\"db\" + str(l+1)]) + epsilon) return parameters, v, s","tags":[]},{"title":"深度学习实践04-参数优化以及正则化","date":"2017-09-24T14:23:50.000Z","path":"2017/09/24/深度学习实践04-参数优化以及正则化/","text":"今天完成了第二门课的第一周内容，主要是三个方面： 偏差和方差的来源，以及减小他们的方法——正则化 梯度爆炸/消失的原因以及解决方法——Xavier随机初始化 梯度检验 下面说一下各自的算法实现 一、偏差以及方差的消除1.1 L2正则化L2正则化主要是在损失函数以及梯度变化量上面进行修改，损失函数修改之后的函数如下： 损失函数 梯度变化量修改之后如下 梯度变换量 先实现成本函数的计算，该神经网络是一个3层的神经网络 123456789101112131415def compute_cost_with_regularization(A3, Y, parameters, lambd): m = Y.shape[1] W1 = parameters[\"W1\"] W2 = parameters[\"W2\"] W3 = parameters[\"W3\"] # compute_cost函数就是之前的成本函数 cross_entropy_cost = compute_cost(A3, Y) # 计算L2正则化 L2_regularization_cost = lambd * (np.sum(np.square(W1)) + np.sum(np.square(W2)) + np.sum(np.square(W3))) / (2 * m) cost = cross_entropy_cost + L2_regularization_cost return cost 然后是梯度变化量 12345678910111213141516171819202122232425def backward_propagation_with_regularization(X, Y, cache, lambd): m = X.shape[1] (Z1, A1, W1, b1, Z2, A2, W2, b2, Z3, A3, W3, b3) = cache dZ3 = A3 - Y # lambd * W3 / m 就是L2正则化所添加的项目，以下同理 dW3 = 1./m * np.dot(dZ3, A2.T) + lambd * W3 / m db3 = 1./m * np.sum(dZ3, axis=1, keepdims = True) dA2 = np.dot(W3.T, dZ3) dZ2 = np.multiply(dA2, np.int64(A2 &gt; 0)) dW2 = 1./m * np.dot(dZ2, A1.T) + lambd * W2 / m db2 = 1./m * np.sum(dZ2, axis=1, keepdims = True) dA1 = np.dot(W2.T, dZ2) dZ1 = np.multiply(dA1, np.int64(A1 &gt; 0)) dW1 = 1./m * np.dot(dZ1, X.T) + lambd * W1 / m db1 = 1./m * np.sum(dZ1, axis=1, keepdims = True) gradients = &#123;\"dZ3\": dZ3, \"dW3\": dW3, \"db3\": db3,\"dA2\": dA2, \"dZ2\": dZ2, \"dW2\": dW2, \"db2\": db2, \"dA1\": dA1, \"dZ1\": dZ1, \"dW1\": dW1, \"db1\": db1&#125; return gradients 1.2 dropout正则化dropout正则化的主要思路是随机消除每一层中的某一些神经单元，以此来减少对输入的以来，从来减轻过拟合——也即方差过大的问题。使用的方法流程如下 随机初始化一个和每一层的输出A矩阵同纬度的矩阵D 根据阈值keep_prob将D中的元素变成0和1，然后再与A相乘来消除A中某些层中的某一些节点 将A中的均值进行复原 同时，dA也需要进行相同的操作，流程与上面的一致。需要注意的是，我们不对输入和输出层进行dropout正则化 12345678910111213141516171819202122232425262728293031323334def forward_propagation_with_dropout(X, parameters, keep_prob = 0.5): # retrieve parameters W1 = parameters[\"W1\"] b1 = parameters[\"b1\"] W2 = parameters[\"W2\"] b2 = parameters[\"b2\"] W3 = parameters[\"W3\"] b3 = parameters[\"b3\"] # LINEAR -&gt; RELU -&gt; LINEAR -&gt; RELU -&gt; LINEAR -&gt; SIGMOID Z1 = np.dot(W1, X) + b1 A1 = relu(Z1) # 对第一层进行dropout正则化 D1 = np.random.rand(A1.shape[0], A1.shape[1]) D1 = (D1 &lt;= keep_prob) A1 = A1 * D1 A1 = A1 / keep_prob Z2 = np.dot(W2, A1) + b2 A2 = relu(Z2) # 对第二层进行dropout正则化 D2 = np.random.rand(A2.shape[0], A2.shape[1]) D2 = (D2 &lt;= keep_prob) A2 = A2 * D2 A2 = A2 / keep_prob Z3 = np.dot(W3, A2) + b3 A3 = sigmoid(Z3) cache = (Z1, D1, A1, W1, b1, Z2, D2, A2, W2, b2, Z3, A3, W3, b3) return A3, cache 其次是对dA进行相同操作，需要注意的是dA1和A1使用的应该是相同的随机矩阵D1 12345678910111213141516171819202122232425262728293031def backward_propagation_with_dropout(X, Y, cache, keep_prob): m = X.shape[1] (Z1, D1, A1, W1, b1, Z2, D2, A2, W2, b2, Z3, A3, W3, b3) = cache dZ3 = A3 - Y dW3 = 1./m * np.dot(dZ3, A2.T) db3 = 1./m * np.sum(dZ3, axis=1, keepdims = True) dA2 = np.dot(W3.T, dZ3) # 对dA2进行dropout正则化 dA2 = dA2 * D2 dA2 = dA2 / keep_prob dZ2 = np.multiply(dA2, np.int64(A2 &gt; 0)) dW2 = 1./m * np.dot(dZ2, A1.T) db2 = 1./m * np.sum(dZ2, axis=1, keepdims = True) dA1 = np.dot(W2.T, dZ2) # 对dA1进行dropout正则化 dA1 = dA1 * D1 dA1 = dA1 / keep_prob dZ1 = np.multiply(dA1, np.int64(A1 &gt; 0)) dW1 = 1./m * np.dot(dZ1, X.T) db1 = 1./m * np.sum(dZ1, axis=1, keepdims = True) gradients = &#123;\"dZ3\": dZ3, \"dW3\": dW3, \"db3\": db3,\"dA2\": dA2, \"dZ2\": dZ2, \"dW2\": dW2, \"db2\": db2, \"dA1\": dA1, \"dZ1\": dZ1, \"dW1\": dW1, \"db1\": db1&#125; return gradients 二、梯度爆炸/消失的原因以及解决方法梯度爆炸以及消失的主要是由W的值以及网络深度导致的，在比较深的网络里面，W增长速度是幂级别的，而Z=WX+b，这样很容易导致Z过大导致梯度变化量过小而降低学习速度。一个常用的解决方法是Xavier初始化，公式如下 初始化公式 这个方法实现起来比较简单。只需要在初始化W的时候乘上一个因子即可，常用的激活函数是Relu函数，tanh函数与其类似，因此只实现Relu函数 12345678910def initialize_parameters_he(layers_dims): parameters = &#123;&#125; L = len(layers_dims) - 1 for l in range(1, L + 1): parameters['W' + str(l)] = np.random.randn(layers_dims[l], layers_dims[l - 1]) * np.sqrt(2 / layers_dims[l - 1]) parameters['b' + str(l)] = np.zeros((layers_dims[l], 1)) return parameters 三、梯度检验梯度检验的目的是确认反向传播的正确性，因为反向传播较为复杂，很容易出现不知名bug。梯度检验的流程主要如下： 将W和b合成一个新的变量θ 利用公式计算θ近似值 根据反向传播计算W和b并合成为新的的变量θ 计算θ近似值与真实值之间的差距，如果小于某一个数，则认为计算正确，否则就需要检验所有的反向计算是否出错 由于梯度检验的复杂性，本文实现的是较为简单的梯度检验算法J=θx。需要注意的是，梯度检验只能用于debug，不能用于训练，因为梯度检验需要的时间很长。 123456789101112131415161718192021def gradient_check(x, theta, epsilon = 1e-7): # 计算近似值 thetaplus = theta + epsilon thetaminus = theta - epsilon J_plus = x * thetaplus J_minus = x * thetaminus gradapprox = (J_plus - J_minus) / (2 * epsilon) grad = x numerator = np.linalg.norm(grad - gradapprox) denominator = np.linalg.norm(grad) + np.linalg.norm(gradapprox) difference = numerator / denominator if difference &lt; 1e-7: print (\"The gradient is correct!\") else: print (\"The gradient is wrong!\") return difference 总结这周的课程主要是对神经网络的优化，包括Xavier初始化，以及如何debug等，以加快机器学习的速度，减少错误率。下周将学习全新的优化算法——MiniBatch梯度下降法。","tags":[]},{"title":"深度学习实践03-构建深层神经网络","date":"2017-09-24T08:24:07.000Z","path":"2017/09/24/深度学习实践03-构建深层神经网络/","text":"深层神经网络的构建18号的时候就已经学完了，自己写激活函数导数的时候遇到了一点困难，再加上懒癌发作，现在才弄到博客上来。 本次需要构建一个深层的神经网络，层数可以在训练时确定，主要流程跟之前的两次实践仍然是计算量的差别。主要流程还是一致的： 初始化参数W、b 根据W、b以及输入X求得输出Z和A 根据输入X和输出Z、A求得梯度下降量dW、db 使用dW、db来更新W、b 循环2-5直至满足学习终止条件，如迭代300次。 算法实现假定训练集输入为X，训练集结果为Y在实现流程之前依然是加载使用到的python库 12import numpy as npimport math 初始化参数W和b因为我们构建的是一个深层网络，所以对每一层都需要进行参数初始化 1234567891011def initial(layers_dims): # layders_dims：每一层神经网络的神经元个数 L = len(layers_dims) parameters = &#123;&#125; for i in range(1, L): W = np.randm.randn(layers[l], layers[l - 1]) * 0.01 b = np.zeros((layers[1], 1)) parameters[\"W\" + str(l)] = np.random.randn(layers_dims[l], layers_dims[l - 1]) parameters[\"b\" + str(l)] = np.zeros((layers_dims[l])) return parameters 根据W、b、输入X求得输出A和Z根据前向公式计算输出A和Z 前向公式 两个激活函数已经在math以及numpy中实现了，直接调用即可。 12345678910def forward(W, b, X, activation): Z = np.dot(W, X) + b if activation == \"sigmoid\": A = sigmoid(Y) elif activation == \"relu\": A = relu(Y) return A, Z 前向传播函数实现如下： 1234567891011121314151617181920def forward_progate(parameters, X): caches = [] A = X L = len(parameters) // 2 for l in range(1, L): cache = &#123;&#125; A_pre = A A, Z = forward(parameters[\"W\" + str(l)], parameters[\"b\" + str(l)], A_prev, \"relu\") cache[\"A\" + str(l)] = A cache[\"Z\" + str(l)] = Z caches.append(cache) AL, ZL = forward(parameters[\"W\" + str(L)], parameters[\"b\" + str(L)], caches[L][\"A\" + str(L - 1)], \"sigmoid\") cache = &#123;\"A\" + str(L): AL, \"Z\" + str(L): ZL&#125; caches.append(cache) return AL, caches 根据X、Y和A求dW和db根据反向传播公式求出dW和db，这一步主要由两个函数构成，一个是之前的反向求导，另外一个就是激活函数的导数了。 反向公式 1234567def activation_back(Z, activation): if activation == \"sigmoid\": Y = sigmoid(Z) * (1 - sigmoid(Z)) elif activation == \"relu\": Y = (Y &gt; 0) return Y 反向求导 12345678910111213141516171819202122232425def backward_progate(caches, AL, parameters): m = Y.shape[1] dAL = -(np.divide(Y, AL) - np.divide(1 - Y, 1 - AL)) grads = &#123;&#125; L = parameters // 2 dZ = dAL * activation_back(Z, \"relu\") dW = np.dot(dZ, A) / m db = np.sum(dZ, axis = 1, keepdims = True) / m dA = np.sot(parameters[\"W\" + str(L)].T, dZ) grads[\"db\" + str(l)] = db grads[\"dW\" + str(l)] = dW for l in reversed(range(L)): cache = caches[l] Z = cache[\"Z\" + str(l)] A = cache[\"A\" + str[l]] dZ = dA * activation_back(Z, \"relu\") dW = np.dot(dZ, A) / m db = np.sum(dZ, axis = 1, keepdims = True) / m dA = np.sot(parameters[\"W\" + str(L)].T, dZ) grads[\"db\" + str(l)] = db grads[\"dW\" + str(l)] = dW return grads 使用dW和db来更新W、b根据公式更新参数W和b 更新参数 123456789101112def update_parameters(parameters, grads, learning_rate = 1.2): # learning process, update parameters with grads # parameters: W1, W2, b1, b2 # grads: dW1, dW2, db1, db2 L = parameters // 2 for i in range(1, L): parameters[\"W\" + str(l)] = parameters[\"W\" + str(l)] - learning_rate * grads[\"W\" + str(l)] parameters[\"b\" + str(l)] = parameters[\"b\" + str(l)] - learning_rate * grads[\"b\" + str(l)] return parameters 建立深层神经网络为简单起见，这里建立一个4层的神经网络，每一层但神经单元分别是5,3,2,1。 12345678910111213141516171819202122def nn_models(X, Y, iterations): # whole netrue network model of 2 layer # n_h: the number of units in the hidden layer # iterations: times of learning layers_dims = [X.shape[0], 5, 3, 2, Y.shape[0]] parameters = random_initial(layers_dims) for i in range(0, iterations): # AL is the output of model # cache store Z and A of each layer AL, caches = forward_progate(parameters, X) # get grads of each layer grads = backward_progate(caches, AL, parameters) # update parameters of each layer parameters = update_parameters(parameters, grads) return parameters 结果使用这个神经网络对包含“猫”的图片进行识别，经过2500次的迭代学习，最终这个神经网络对训练集的识别准确率达到了98.5%，而测试集的准确率从第一次作业的72%提升到80%。不过这个神经网络其实还存在过拟合的问题，训练集与测试集的差距较大，之后的课程会对过拟合以及超参数进行优化。 至此，吴恩达老师的深度学习课程中的第一门课已经全部完成。","tags":[]},{"title":"秋风扫落叶","date":"2017-09-19T02:48:15.000Z","path":"2017/09/19/秋风扫落叶/","text":"2017年9月6号，我正在正华科目二的候考室玩着手机，和我一个教练的其他5个人都第一批点名就进去等考试了，现在只剩下我一个人。碰见了那个一起在西南门等班车那个妹子，聊了聊什么时候点名什么时候考试这类的。大概各自都觉得挺无聊，她就回候考室坐着等去了，我嫌屋里烟味太重，就在外面晒太阳，顺便看看那些还在练倒库的人找点乐子。 突然看到堂哥在微信群里说爷爷已经去世了，让大家有时间的都抽出时间回家一趟。当即给妈打了个电话，妈说让我先安心考试，考完试再说。 花了一个小时寻找最短时间的回家路线，一天耗在火车上。回顾我所知的与爷爷一起的生活，印象最深的是小时候他揍我，当时心里委屈的很，他根本没有弄清楚事实，而后就是各种账本，记下了父母给了他多少钱，我们又花了多少钱。小的时候特别恨他，自己管钱之后觉得他就是一个顽固而又吝啬的老头，用奶奶的话说就是想把钱紧紧的攥在自己手里。 火车站广场 到家当天晚上在姑姑家睡，姑父跟我谈起爷爷生前的一些事情，我总感觉有点不习惯，像是在讨论一个和我无关的事情，可能我还没有适应，也可能我跟爷爷的感情没有姑父的深。 第二天上午就去了殡仪馆，看到了在玻璃下躺着的爷爷。化妆师给他化了妆，他脸上的老年斑看起来少了很多，整个人也瘦了很多，亲人说是人去世之后会缩水，因此看起来瘦了一些。 妈说爷爷是农历七月十六早上去世的。爸他们那天早上准备给爷爷洗个澡，进去之后看到爷爷睁着眼睛，就准备给他脱衣服，然后才发现爷爷呼吸已经停止了，但是身体还是热的，应该是去世没多久。人去世了，眼睛却是睁着的，他们说有什么未见的人或是有什么未了的事情，之后当天下午姑姑以及姑婆赶来，他才合上眼睛。我感觉这些都带着迷信因素，我也不在场，无从得知详情。 按照奶奶的说法，如果七月十五之前去世，那么会是坏事情，但爷爷是十六走的， 早餐也没吃，奶奶说爷爷去世选了个好时候，自己一口饭都没舍得吃，早餐和粮食都留给了子孙后代。 回家之后妈叫我和他一起收拾祖屋。祖屋现在已经不住人了，但是还有很多之前爷爷的东西。说是收拾祖屋，其实是收拾爷爷的遗物，然后归总烧掉。只有我和奶奶才知道祖屋钥匙在哪里，收拾一通之后找出了不少“老古董”。孩子们出生的生辰八字、之前的分家记录、以前的工分记录等等。最大的收获是找到了爷爷奶奶1967年的结婚证，不过可惜的是上面没有照片。 意外收获 妈收拾完跟我聊天，说其实她心里堵得慌。自从爷爷去世，她心里就不好受，直到殡仪馆火化完爷爷的遗体之后才好一些。但是看到爷爷的遗物，心里又开始乱想。 之前爷爷一直重病在床，奶奶在照顾他，现在爷爷去世，上一辈说是让奶奶别呆在家里了。四个儿子一个女儿，随便跟哪个一起生活都行，或者这家住两天，那家住两天，老人东西也不多，搬迁的时候不麻烦。之前由于爷爷没有时间出来走走，现在来散散心也不错。 之后的某天不知道什么原因，奶奶和我们一起在上楼，突然翻出来一堆衣服，把妈叫到旁边跟她说这些是她自己准备的寿衣，这几件是上衣，那几件是裤子，还说什么男双女单之类的，意思是男的去世身上的衣服必须是双数，而女的去世必须是单数。还告诉了我妈她有哪些哪些财产，分别都在哪里。 火车 我突然觉得自己心里也堵得慌。随着岁月的流失，原来他们真的在一点点老去。记忆里白天时间家里根本看不到奶奶的身影，每天都要出去干农活，现在却是每天撑着个棍子，笑眯眯的看着我们做事情。 医生之前说爷爷已经没法再进行救治了。暑假回家看他，整天卧病在床，他的脊柱和腰都已经受伤，躺也只能单侧躺，单侧躺时间太长又会难受，其实日子过得很痛苦。子孙差不多都回来见过了一面，去世也算是一种解脱吧。 愿一路走好，魂佑子孙。","tags":[]},{"title":"深度学习实践02-浅层神经网络","date":"2017-09-18T14:50:41.000Z","path":"2017/09/18/深度学习实践02-浅层神经网络/","text":"浅层神经网络理论学习已经被拿下了，现在把编程作业自己实现一下 本次需要实现的浅层神经网络结构如下 模型 整个神经网络结构实现的过程跟深度学习实践01-Logistic Regression识别包含猫的图片类似，不过增加了计算量而已。主要流程如下： 初始化参数W1、b1、W2和b2 根据W1、b1、W2、b2以及输入X求得输出Z1、Z2、A1、A2 根据输入X和输出Z1、Z2、A1、A2求得梯度下降量dW1、db1``dW2和db2 使用dW1、db1``dW2和db2来更新W1、b1、W2和b2 循环2-5直至满足学习终止条件，如迭代300次。 算法实现假定训练集输入为X，训练集结果为Y在实现流程之前依然是加载使用到的python库 12import numpy as npimport math 初始化参数W和b这一步与逻辑回归有所不同的是，我们需要根据神经网络的结构来初始化不同维度的W1和W2；其次，我们需要随机的初始化W1和W2，为什么呢？假设W1和W2都是初始化为全0矩阵，那么第一层的所有神经单元做的工作都是相同的，计算出来的是同一个值，类似的，当第二次迭代的时候每一层的不同神经单元计算也是相同的，这样的话神经单元的个数就没有什么意义了。并且，W初始化的值不能太大，以sigmoid激活函数为例子，如果W值较大，那么最终计算出来的Y^数值也会比较大，在点(Y^, sidmoid(Y^))处的斜率接近于0，根据梯度下降法的特性，整个神经网络刚开始的学习速度就会大大降低，不利于提高效率。因此初始化的代码更改如下： 12345678def initial(n_x, n_h, n_y): W1 = np.random.randn(n_h, n_x) * 0.01 b1 = np.zeros((n_h ,1)) W1 = np.random.randn(n_y, n_h) * 0.01 b1 = np.zeros((n_y ,1)) parameters = &#123;\"W1\": W1, \"W2\": W2, \"b1\": b1, \"b2\": b2&#125; return parameters 根据W、b、输入X求得输出A和Z根据前向公式计算输出A和Z 前向公式 两个激活函数已经在math以及numpy中实现了，直接调用即可。前向传播函数实现如下： 123456789101112def forward(parameters, X): W1 = parameters['W1'] b1 = parameters['b1'] W2 = parameters['W2'] b2 = parameters['b2'] Z1 = np.dot(W1, X) + b1 A1 = np.tanh(Z1) Z2 = np.dot(W2, A1) + b2 A2 = sigmoid(Z2) cache = &#123;\"Z1\": Z1, \"Z2\": Z2, \"A1\": A1, \"A2\": A2&#125; return cache 根据X、Y和A求dW和db根据反向传播公式 反向公式 求出dW和db 12345678910111213141516def backward(X, Y, cache, parameters): m = X.shape[1] A2 = cache['A2'] A1 = cache['A1'] W2 = parameters['W2'] W1 = parameters['W1'] dZ2 = A2 - Y dW2 = np.dot(dZ2, A1.T) / m db2 = np.sum(dZ2, axis = 1, keepdims = True) / m dW1 = np.dot(dZ1, X.T) / m dZ1 = np.dot(W2.T, dZ2) * (1 - A1**2) db1 = np.sum(dZ1, axis = 1, keepdims = True) / m grads = &#123;\"dW1\": dW1, \"dW2\": dW2, \"db1\": db1, \"db2\": db2&#125; return grads 使用dW和db来更新W、b根据公式更新参数W和b 更新参数 1234567891011121314151617def update_parameters(parameters, grads, learning_rate=1.2): dW1 = grads['dW1'] db1 = grads['db1'] dW2 = grads['dW2'] db2 = grads['db2'] W1 = parameters['W1'] b1 = parameters['b1'] W2 = parameters['W2'] b2 = parameters['b2'] W1 = W1 - learning_rate * dW1 W2 = W2 - learning_rate * dW2 b1 = b1 - learning_rate * db1 b2 = b2 - learning_rate * db2 parameters = &#123;\"W1\": W1, \"W2\": W2, \"b1\": b1, \"b2\": b2&#125; return parameters 浅层神经网络的建立12345678910111213def nn_model(X, Y, iteration_times): n_x = X.shape[0] n_h = 4 n_y = Y.shape[0] parameters = initial(n_x, n_h, n_y) for i in range(iteration_times): cache = forward(parameters, X) grads = backward(X, Y, cache, parameters) parameters = update_parameters(parameters, grads) return parameters 经过大量学习过程，我们习得了模型中的参数W和b。 结果使用这个神经网络对包含“猫”的图片进行识别，经过2500次的迭代学习，最终这个深层的神经网络训练集识别率为98.5%，而测试集相比于之前的逻辑回归的72%得到了提升，准确率为80% 至此，吴恩达老师的深度学习五门课的第一门课“深度学习初步以及构建神经网络”已经全部完成。","tags":[]},{"title":"深度学习实践01-Logistic Regression识别包含猫的图片","date":"2017-09-17T13:27:50.000Z","path":"2017/09/17/深度学习实践01-Logistic-Regression识别“猫”/","text":"刚通过吴恩达老师的“深度学习”视频学完了Logistic Regression —— 逻辑回归，现在小试牛刀，看看如何实现“猫”图片的识别。 逻辑回归主要使用梯度下降法求出参数下降量来逐步减小成本函数，最终求得需要的模型。逻辑回归思路比较简单，实现的难度较小。主要流程如下： 初始化参数W和b 根据W、b、输入X求得输出A 根据输入X和输出A求得梯度下降量dW和db 使用dW和db来更新W、b 循环2-5直至满足学习终止条件，如迭代300次。 实现该算法使用的语言是python，因为python使用简单，而且它的库numpy可以极大的减少运行时间，加快迭代过程。 算法实现假定训练集输入为X，训练集结果为Y在实现流程之前首先得加载使用到的python库 1import numpy as np 初始化参数W和b这部分的时候简单，只需根据输入的规模将W和b初始化全0即可 123456def initial(dim): W = np.zeros((dim, 1)) b = 0 parameters = &#123;\"W\": W, \"b\": b&#125; return parameters 根据W、b、输入X求得输出A根据下面公式求出A 正向公式 首先实现激活函数sigmoid 123def sigmoid(Z): A = 1 / (1 + np.exp(Z)) return A 再来实现前向计算 1234567def forward(parameters, X): W = parameters['W'] b = parameters['b'] Z = np.dot(W.T, X) + b A = sigmoid(Z) return A 根据X、Y和A求dW和db根据公式求dW和db 反向公式 123456def back_progate(X, Y, A): dW = X(A - Y) db = np.sum(A - Y, axis = 1, keepdims = True) / m grads = &#123;\"dW\": dW, \"db\": db&#125; return grads 使用dW和db来更新W、b根据公式更新参数W和b 更新参数 1234567891011def update_parameters(parameters, grads, learning_rate=0.5): W = parameters['W'] b = parameters['b'] dW = grads['dW'] db = grads['db'] W = W - learning_rate * dW b = b - learning_rate * db parameters = &#123;\"W\": W, \"b\": b&#125; return parameters Logistic Regression模型的建立将以上的函数进行组合完成Logistic Regression模型的建立 123456789def lr_model(X, Y, iteration_times): n_x = X.shape[0] parameters = initial(n_x) for i in range(0, iteration_times): A = forward(parameters, X) grads = back_progate(X, Y, A) parameters = update_parameters(parameters, grads) return parameters 最终，通过大量的学习过程，我们求出了所需的参数W和b，之后用于测试的时候只需要代入即可，Logistic Regression模型至此全部实现。 结果经过209张图片的训练，最终Logistic Regression模型对图片的识别成功率大约为70%，对于一个这么简单的模型来说，已经足够了。如果想要继续提升准确率，可以加大训练的图片规模。","tags":[]},{"title":"Leetcode-120-Triangle","date":"2017-08-26T15:24:01.000Z","path":"2017/08/26/Leetcode-120-Triangle/","text":"题目如下 Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.For example, given the following triangle[ [2], [3,4], [6,5,7], [4,1,8,3]] The minimum path sum from top to bottom is 11 (i.e., 2 + 3 + 5 + 1 = 11)Note:Bonus point if you are able to do this using only O(n) extra space, where n is the total number of rows in the triangle. 题目大意给定一个三角形(二维不定长列表)，求出从顶部到底部的最小路径和。每一步你可以选择下一行的两个相邻数字。以上面的三角形为例子：最小路径和是11，路径为2-&gt;3-&gt;5-&gt;1 = 11。如果算法的空间复杂度为O(n)会有额外的得分奖励(n为三角形层数)。 思路这题使用动态规划较为简便。最初的思路为自顶向下，对每一行进行遍历，同时使用一个一维数组dp存储最佳状态的路径和(dp的长度为三角形的层数)。以此类推，最后一层将会记录所有的路径结果，这时只需要对dp进行遍历求出当中的最小值即可。以上面的三角形为例子。当遍历第一行时，dp的存储为2,0,0,0，第二行时状态为2+3=5,2+4=6，第三行为5+6=11,min(5+5,6+5)=10,6+7=12，第四行为15,min(11+1,10+1)=11,min(10+8,12+8=20)=18,16。只需要遍历最后一行即可求出最小路径和11。 不过在此算法代码编写过程中我发现了两个主要问题，其一因为我们只使用了一维数组，而中间的数字会有来自上一层的两个路径，那么势必会造成数值的丢失，因此需要另外一个变量来存储之前的值，比如在计算第四行dp(1)时，之前的dp(0)已经被更新了，那么就需要有一个临时变量来存储之前的dp(0)=11；其二是时间问题，算法到最后仍然需要对dp进行一次遍历，当层数较多的时候耗费时间较多。 在思考如何解决这两个问题的时候突然想到了二维DP问题的时候空间优化方法，二维DP问题也有数值丢失的问题，而它是使用倒序来解决这个问题的。运用到这个问题时来，我们可以把自顶向下改成自底向上，每次比较该节点两个孩子的数值大小，将小的那个孩子节点的值再加上本身节点的值即为该节点以下的最小路径和，以此类推直到顶点。这两种方式对于结果的正确性来说没有什么影响，这样的话就解决了第一个数值保存的问题，同时我们发现这样也恰好解决了第二个问题，根据此算法，最后的最小路径和肯定会存储在dp(0)，这样就省去了最后对dp的遍历时间。 此算法使用了一个一维数组用于存储结果，空间复杂度为O(n)(n为三角形层数)；同时此算法有两层循环，所以时间复杂度是O(n2)。Java版的代码如下： 123456789public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123; int [] dp = new int[triangle.size() + 1]; for (int i = triangle.size() - 1; i &gt;= 0; i --)&#123; for (int j = 0; j &lt; triangle.get(i).size(); j ++)&#123; dp[j] = triangle.get(i).get(j) + Math.min(dp[j], dp[j + 1]); &#125; &#125; return dp[0];&#125; 提交结果如下： 提交结果 ```","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://KingsFish.github.io/tags/Dynamic-Programming/"}]},{"title":"Leetcode-494-Target-Sum","date":"2017-08-22T14:05:02.000Z","path":"2017/08/22/Leetcode-494-Target-Sum/","text":"题目如下： You are given a list of non-negative integers, a1, a2, …, an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.Find out how many ways to assign symbols to make sum of integers equal to target S. Example 1: 12345678910&gt; Input: nums is [1, 1, 1, 1, 1], S is 3. &gt; Output: 5&gt; Explanation: &gt; -1+1+1+1+1 = 3&gt; +1-1+1+1+1 = 3&gt; +1+1-1+1+1 = 3&gt; +1+1+1-1+1 = 3&gt; +1+1+1+1-1 = 3&gt; There are 5 ways to assign symbols to make the sum of nums be target 3.&gt; Note: The length of the given array is positive and will not exceed 20. The sum of elements in the given array will not exceed 1000. Your output answer is guaranteed to be fitted in a 32-bit integer. 题目大意给定一个正数数组以及一个整数S，现在有两个符号+和-，对于数组里面的每一个数字，你可以选择+或者-作为它的新符号，找出所有选择符号的方式，使这些数字和为S。简单来说，给定一个数组，每个数可以加或者减，求出所有能使这些数字加减和为S的组合数。如{1,1,1,1,1}，S为3，那么一共有5种方法使得这些数字和为3： -1+1+1+1+1 = 3+1-1+1+1+1 = 3+1+1-1+1+1 = 3+1+1+1-1+1 = 3+1+1+1+1-1 = 3 思路假设数组中所有数字之和为sum。根据使用的符号不同，我们可以将数组内数字分为2组P和N，如数组{1,2,3}，目标为0，那么显然有如下选择方式： +1+2-3 = 0 那么其中P={1,2}，N={3}。那么sum(P)-sum(N)=S，并且sum(P)+sum(N)=sum。由此可以推出S+sum=sum(P)-sum(N)+sum(P)+sum(N)=2*sum(P)。 这样我们就把原来的问题转换成了一个新的问题，在整个数组中，能否找到一些数字的和为(S+sum)/2，这就成了一个最经典的0-1背包问题，这样的话就简单了很多。 这里有一个需要注意的地方，(S+sum)/2这个数必须为偶数，否则无法得到，其次，S也必须小于sum，否则也无法求得。 这个算法的空间复杂度不定，取决于S和sum，不过题目限制了sum &lt; 1000，那么空间复杂度为O(sum)。至于时间复杂度也取决于sum，时间复杂度是O(sum*N2)。Java版的代码如下： 123456789101112131415161718public int findTargetSumWays(int[] nums, int S) &#123; int sum = 0; for (int i = 0; i &lt; nums.length; i ++)&#123; sum += nums[i]; &#125; if (S &gt; sum || (S + sum) % 2 != 0)&#123; return 0; &#125; sum = (S + sum) / 2; int [] dp = new int[sum + 1]; dp[0] = 1; for (int i = 0; i &lt; nums.length; i ++)&#123; for (int j = sum; j &gt;= nums[i]; j --)&#123; dp[j] += dp[j - nums[i]]; &#125; &#125; return dp[sum];&#125; 提交结果如下: 运行结果 总结最近在刷Leetcode上的tag为动态规划的题，做了那么多其实动态规划的思想一直没变，最重要的是找到状态、状态转移公式以及转移状态的条件。当然，有的时候还需要一些数学推导，把当前不熟悉的问题转化成熟悉的问题。```","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://KingsFish.github.io/tags/Dynamic-Programming/"}]},{"title":"Leetcode-474 Ones-and-Zeross题解","date":"2017-07-23T05:04:09.000Z","path":"2017/07/23/Leetcode-474-Ones-and-Zeros/","text":"最近正在死磕动态规划，前阵子把Leetcode上的动态规划标签的简单题刷完了(其实一共也才5题)，最近在看动态规划中经典的0-1背包问题，顺便在Leetcode上就找了这个练习题。题目如下： In the computer world, use restricted resource you have to generate maximum benefit is what we always want to pursue.For now, suppose you are a dominator of m 0s and n 1s respectively. On the other hand, there is an array with strings consisting of only 0s and 1s.Now your task is to find the maximum number of strings that you can form with given m 0s and n 1s. Each 0 and 1 can be used at most once.Note: The given numbers of 0s and 1s will both not exceed 100 The size of given string array won’t exceed 600. Example 1: 123Input: Array = &#123;&quot;10&quot;, &quot;0001&quot;, &quot;111001&quot;, &quot;1&quot;, &quot;0&quot;&#125;, m = 5, n = 3Output: 4Explanation: This are totally 4 strings can be formed by the using of 5 0s and 3 1s, which are “10,”0001”,”1”,”0” Example 2: 123Input: Array = &#123;&quot;10&quot;, &quot;0&quot;, &quot;1&quot;&#125;, m = 1, n = 1Output: 2Explanation: You could form &quot;10&quot;, but then you&apos;d have nothing left. Better form &quot;0&quot; and &quot;1&quot;. 题目大意给定一个字符串数组以及整数m和n，m和n分别代表着0和1的个数，求出这些0和1能组成字符串数组中字符串的最大个数。如： 给定数组{&quot;10&quot;, &quot;0&quot;, &quot;1&quot;},以及m = 1, n = 1。那么输出为2，1个0和1个1可以组成字符串数组的中的二三两个字符串。 思路第一种解法这是一个多维的0-1背包问题，只是把背包容量的大小换成了0和1的个数，而宝石换成了字符串，宝石的重量为字符串中0和1的个数，宝石价值都为1。 状态和递推式和0-1背包问题类似。因为“背包”容量是2维的，所以存储状态的数组是3维的，状态dp[i][j][k]表示前i个字符串中能用j个0和k个1组成的最大字符串数。这样的话状态就已经确定下来，剩下的就是寻找转移方程了。 字符串之间的转移是如何进行的呢？其实当我们考虑dp[i][j][k]时，我们讨论的是要不要组成第i个字符串，假设第i个字符串的0和1的个数分别为zeros和ones。如果不组成这个字符串，那么dp[i][j][k]的值就和dp[i - 1][j][k]的值是一样的；如果组成这个字符串，那么dp[i][j][k]就应该是dp[i - 1][j - zeros][k - ones] + 1，也即前i - 1的字符串中除去第i个字符串使用的0和1所剩下的0和1所能组成的最大字符串数量再加上1（组成了第i个字符串，所以+1）。这样就得到了递推式： dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - zeros][k - ones]) 这个算法的时间复杂度为O(lmn)，其中l是字符串数组的长度，空间复杂度也是O(lmn)，Java版的代码如下 12345678910111213141516171819202122232425262728293031323334353637public class Solution &#123; public int findMaxForm(String[] strs, int m, int n) &#123; int l = strs.length; int [][][] d = new int[l + 1][m + 1][n + 1]; for (int i = 0; i &lt;= l; i ++)&#123; int [] nums = new int[]&#123;0,0&#125;; if (i &gt; 0)&#123; nums = getNum(strs[i - 1]); &#125; for (int j = 0; j &lt;= m; j ++)&#123; for (int k = 0; k &lt;= n; k ++)&#123; if (i == 0) &#123; d[i][j][k] = 0; &#125; else if (j &gt;= nums[0] &amp;&amp; k &gt;= nums[1])&#123; d[i][j][k] = Math.max(d[i - 1][j][k], d[i - 1][j - nums[0]][k - nums[1]] + 1); &#125; else &#123; d[i][j][k] = d[i - 1][j][k]; &#125; &#125; &#125; &#125; return d[l][m][n]; &#125; // this method is used to get the count of 0 and 1 private int [] getNum(String str)&#123; int [] nums = new int [2]; for (int i = 0; i &lt; str.length(); i++)&#123; if (str.charAt(i) == '0') &#123; nums[0] ++; &#125; else &#123; nums[1] ++; &#125; &#125; return nums; &#125;&#125; 提交Leetcode，结果如图 运行结果 0-1背包问题中的空间优化方法0-1背包问题有优化空间复杂度的方法。类似的，这一题也可以将三维的数组优化成二维，字符串数量那一维删去，就可以得到空间复杂度为O(mn)的算法。 以下图的0-1背包问题作为讲解。 状态数组 我们可以看到，在每一次计算d[i][j]时，我们并没有用到所有的状态，只是前一行的两个状态。这样的话状态存储的就能从L x m优化成2 x m，然后轮流使用这两行进行状态即可。 但是轮流使用还是很麻烦，那么有没有进一步的优化空间呢。从上面的递推式我们可以发现，当前的状态仅仅使用上一行的两个位置的状态，那么我们完全可以使用1 x m的数组进行存储。那么状态转移方程就变成了 d[j] = max(d[j], d[j - w] + v) d[i - 1][j - w] d[i - 1][j] d[i][j] 左边的d[j]是第二行的d[i][j]，而右边是上一行的d[i - 1][j]，d[j - w]也是上一行的d[i - 1][j - w]。但是这样有个问题，如果d[i][j + 1]在更新的时候刚好要用到d[i - 1][j]，而这个时候d[i - 1][j]已经被更新成为了d[i][j]，那么结果就会出现错误。如果解决这个问题呢？其实只需要将j的迭代顺序从0 -&gt; N变成倒序即N -&gt; 0即可。这样的话就算d[i][j + 1]在更新的时候要用上d[i - 1][j]，d[j]也就是旧的还未更新之前的d[i - 1][j]。这样就将0-1背包的空间复杂度从O(lm)降到了O(m)。 Ones and Zeros 问题中的空间优化方法类似于上面的0-1背包问题，在计算dp[i][j][k]时，我们只用到了dp[i - ][j][k]和dp[i - 1][j - zeros][k - ones]两个状态，因此将第二维和第三维的循环变量倒序，然后修改一下状态转移方程为 d[j][k] = max(d[j][k], d[j - zeros][k - ones] + 1) 这样把上一版的Java的代码修改如下 12345678910111213141516171819202122232425262728public class Solution &#123; public int findMaxForm(String[] strs, int m, int n) &#123; int l = strs.length; int [][] dp = new int[m + 1][n + 1]; for (int i = 0; i &lt; l; i ++)&#123; int [] nums = getNum(strs[i]); for (int j = m; j &gt;= nums[0]; j --)&#123; for (int k = n; k &gt;= nums[1]; k --)&#123; dp[j][k] = Math.max(dp[j][k], dp[j - nums[0]][k - nums[1]] + 1); &#125; &#125; &#125; return dp[m][n]; &#125; // this method is used to get the count of 0 and 1 private int [] getNum(String str)&#123; int [] nums = new int [2]; for (int i = 0; i &lt; str.length(); i++)&#123; if (str.charAt(i) == '0') &#123; nums[0] ++; &#125; else &#123; nums[1] ++; &#125; &#125; return nums; &#125;&#125; 第二版不仅复杂度降了很多，代码也变简单了。提交Leetcode结果如下： 提交结果 总结死磕动态规划也有一段时间了，总算会了一些，不像之前没学过那样磕磕碰碰看的头大了。其实动态规划都有其一定的规律，主要是定义状态以及状态转移方程，将大问题转化成子问题，最终一步步优化得到最后的结果。","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://KingsFish.github.io/tags/Dynamic-Programming/"}]},{"title":"机器学习03-线性回归","date":"2017-07-19T07:54:20.000Z","path":"2017/07/19/Machine-Learning-03/","text":"线性模型较为简单，易于求出参数，在之后的高级算法中有更多的应用。 线性回归的基本形式给定一系列数据样本(xi, yi)，其中x=(x1 ··· xn)，线性模型试图学得一个通过属性的线性组合来进行预测的函数，即 f(x)=w1x1 + ··· + wnxn + b 用向量则可以表示成 f(x)=wTx + b 其中w=(w1; w2···; wn)。将w和d学习得到之后就可以确定此模型。 那么如何求解w和d呢？ 输入属性数目只有一个时w和d的求解此时输入数据x是一个实数，但是有m个数据。求解w和d的关键在于衡量f(x)和y的差别。均方误差是回归任务中最常用的性能度量，因此我们可以试图将均方误差缩小，即： (w*, d*) = arg min((f(x1) - y1)2 + ··· + (f(xm) - ym)2) = arg min((y1 - wx1 - b)2 + ··· + (ym - wxm - b)2) 令E(w,b)等于上述函数，应用最小二乘法，分别对w和d求导，然后令偏导为0，则可得到w和d的解 更一般的情况此时x有n个属性，也即x是一个n维向量。 类似的，利用最小二乘法来对w和b进行估计，可得w和b的解: 2XT(Xw - y) = 0 当X&lt;sup&gt;T&lt;/sup&gt;X为满秩矩阵或者正定矩阵时 w = (XTX)-1XTy 其中，X是输入数据的m x n矩阵，y是输出矩阵 对数线性回归线性回归虽简单，但是可以由很多的变化。线性回归的一般形式是： y = wTx + b 如果模型预测值逼近于y的衍生物，比如指数尺度，那么就可以将输出标记的对数作为线性模型逼近的目标，即： lny = wTx + b 这就是对数线性回归，它实际上是试图将ewTx + b趋近于y。 更一般的，考虑单调可微函数g(x) g(y) = wTx + b 显然，对数线性回归是上面一般形式在g(x)=ln(x)时的特例。 “对数几率回归” - 分类问题的“线性回归”上面讨论的是如何使用线性模型来进行回归模型，分类任务中也有”线性回归“模型。 定义根据上面的广义线性回归模型，只要找到一个特殊的g(x)将真实标记y与线性回归模型预测值联系起来即可。 简单起见考察二分类问题，线性模型z = wTx + b输出为实数，而分类问题输出为0/1，那么只要找到将所有实数映射为0/1的g(x)即可。阶跃函数是最理想的。 但是我们可以想到，阶跃函数并非连续，无法真正应用。那么只需要找到近似与阶跃函数的替代函数即可。对数几率函数是一个较为常用的替代函数: y = 1 / (1 + e-z) 代入可得： ln(y / (1 - y)) = wTx + b 若将y视为样本x作为正例的可能性，则1 - y是其反例可能性，两者的比值称为“几率”。因此，其对应的模型称为对数几率回归。 如何确定w和b待续。。。","tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://KingsFish.github.io/tags/Machine-Learning/"}]},{"title":"Leetcode 64 Minimum Path Sum","date":"2017-07-17T04:34:15.000Z","path":"2017/07/17/Leetcode-64-Minimum-Path-Sum/","text":"Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path. Note: You can only move either down or right at any point in time. 题目大意给定二维数组，一个机器人从左上角开始，每次只能往右或者往下走，问到达长方形最左下角时，所走路径最小数字和是多少？ 思路很明显是一个二维的动态规划题。动态规划最重要的就是要找到递推式，将当前的大问题划分为更小的子问题。 以3x7的格子为例，对于坐标为(2,5)的格子，只有可能是从上面(1,5)或者左边(2,4)的格子到达的。所以我们只需要选出到(2,4)和(1,5)两个格子的最小路径和中较小的那一个，之后在加上(2,5)本身的数字即为到达(2,5)的最小路径和。这样我们就得到了递推式 1D(i, j) = A(i, j) + min(D(i - 1, j), D(i, j - 1)) 当然我们还需要考虑一些特殊情况。当格子在第一行即i = 0时，只能由左边的格子到达；当格子在第一列即j = 0时，只能由上方的格子到达。这两种特殊情况中的格子都只需要加上对应的上方或者左边的路径和即可。 这种思路需要使用m x n的空间用来存储到达所有格子的最小路径和，但是数组已经给定了，因此空间复杂度为O(1)。我们需要遍历整个格子，因此时间复杂度是O(m*n)。Java版的代码如下： 123456789101112131415161718public class Solution &#123; public int minPathSum(int[][] grid) &#123; for (int i = 1; i &lt; grid[0].length; i++) &#123; grid[0][i] += grid[0][i - 1]; &#125; for (int i = 1; i &lt; grid.length; i++) &#123; grid[i][0] += grid[i - 1][0]; &#125; for (int i = 1; i &lt; grid.length; i++) &#123; for (int j = 1; j &lt; grid[0].length; j++) &#123; grid[i][j] += Math.min(grid[i - 1][j], grid[i][j - 1]); &#125; &#125; return grid[grid.length - 1][grid[0].length - 1]; &#125;&#125; Leetcode提交运行时间为4ms 提交结果","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://KingsFish.github.io/tags/Dynamic-Programming/"}]},{"title":"Leetcode-62 Unique Paths","date":"2017-07-17T02:58:49.000Z","path":"2017/07/17/Leetcode-62-Unique-Paths/","text":"A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below). How many possible unique paths are there? 示例图 Note: m and n will be at most 100. 题目大意给定两个数字m和n作为一个长方形的长和宽，一个机器人从左上角开始，每次只能往右或者往下走，问到达长方形最左下角一共有多少种走法？ 思路很明显是一个二维的动态规划题。动态规划最重要的就是要找到递推式，将当前的大问题划分为更小的子问题。 以3x7的格子为例，对于坐标为(2,5)的格子，只有可能是从上面(1,5)或者左边(2,4)的格子到达。那么到达这个格子的走法应当是到达(2,4)和到达(1,5)两个格子的走法之和。那么我们就得到了递推式 1D(i, j) = D(i - 1, j) + D(i, j - 1) 当然我们还需要考虑一些特殊情况。当格子在第一行即i = 0时，只能由左边的格子到达；当格子在第一列即`j = 0’时，只能由上方的格子到达。其实这两个特殊情况中的格子都只有一种走法到达。 这种思路需要使用m x n的空间用来存储所有格子的走法总数，同时需要遍历整个格子，因此空间复杂度和时间复杂度都是O(m*n)。Java版的代码如下： 12345678910111213141516public class Solution &#123; public int uniquePaths(int m, int n) &#123; int [][] number = new int [m][n]; for (int i = 1; i &lt; m; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (i == 0 || j == 0) &#123; number[i][j] = 1; &#125; else &#123; number[i][j] = number[i - 1][j] + number[i][j - 1]; &#125; &#125; &#125; return number[m - 1][n - 1]; &#125;&#125; Leetcode提交运行时间为1ms 提交结果","tags":[{"name":"Dynamic Programming","slug":"Dynamic-Programming","permalink":"https://KingsFish.github.io/tags/Dynamic-Programming/"}]},{"title":"使用SIPp对FreeSwitch压力测试01-注册","date":"2017-07-16T04:00:39.000Z","path":"2017/07/16/Performance-testing-on-FreeSwitch-with-SIPp-01/","text":"最近SIP电话项目功能部分已经基本完成，但是甲方对服务器有很多性能部分的要求，这个项目的上一个人主要工作就是功能的实现，剩下的压力测试就就落到了我身上。主要使用SIPp对FreeSwitch服务器进行压力测试。 SIPp简介SIPp是一个测试SIP协议性能的工具软件。这是一个GPL的开放源码软件。 它包含了一些基本的SIP用户代理工作流程（UAC和UAS，其中UAC指主动发起呼叫端，UAS指接收呼叫端），并可使用INVITE和BYE建立和释放多个呼叫。它也可以读XML的场景文件，即描述任何性能测试的配置文件。它能动态显示测试运行的统计数据（呼叫速率、信号来回的延迟，以及 消息统计）。周期性地把CSV统计数据转储，在多个套接字上的TCP和UDP，利用重新传输管理的多路复用。在场景定义文件中可以使用正规表达式，动态调整呼叫速率。 SIPp可以用来测试许多真实的SIP设备，如SIP代理，B2BUAs,SIP媒体服务器，SIP/x网关，SIP PBX，等等，它也可以模仿上千个SIP代理呼叫你的SIP系统。 简单的说，SIP能够模拟多个UAC以及被UAS，使用XML文件描述SIP流程，这样就能够对服务器进行性能测试。 下载以及安装下载SIPp的网址：http://sipp.sourceforge.net/，这里可以下载最新版的SIPp软件，并且有英文资料可供查阅 SIPp可以在这里下载 安装SIPp可以在Linux和Cygwin上面，当然，SIPp在Linux上性能要比Cygwin上好。在Linux上SIPp提供了源码包安装，因此安装之前需要编译，以下编译环境不可缺少： C++编译器 curse库或者ncurse库 如需要pcap功能：需要libpcap以及libnet 如需要支持TLS功能： 需要OpenSSL 0.9.8以上版本 如需要支持SCTP： 需要lksctp-tools 对于需要支持统计分布的暂停：需要开源科学计算库（Gnu Scientific Libraries） 根据项目的需求，我需要pcap和OpenSSL功能，因此安装过程如下 123456789101112131415161. 安装编译环境yum –y install gcc-c++yum –y install ncurses-develyum –y install openssl-devel为了安装libpcap，还需安装以下两个开发包。yum –y install flexyum –y install bison2. 下载并安装libpcap开发包。http://www.tcpdump.org/release/libpcap-1.5.3.tar.gz./configure &amp;&amp; make &amp;&amp; make install3. 安装完毕后，就可以开始sipp的配置和安装了。./configure –with-pcap –with-opensslmake &amp;&amp; make install 可以使用sipp -v查看sipp版本号以测试sipp是否安装成功 测试sipp是否成功安装 对注册功能进行性能测试注册功能的测试较为简单，此测试本没有必要，因为FreeSwitch服务器与SIP客户端不是一直保持连接，而是每隔一段时间客户端往FreeSwitch发送Register消息来随时更新自己的位置。这样的话并不涉及到性能，但是之后的UAS需要用到注册的功能实现，所以在此就把注册功能的压力测试一并做了。 前面说了，SIPp主要依靠场景文件来实现功能。场景文件指的是一个XML文件，在这个文件里描述了SIP的相关流程，比如注册、被叫以及主叫流程。 注册用的UAC文件 此XML文件描述的流程如下： 注册测试流程 为了防止200消息丢失，因此最后暂停2s用于接收重发的200消息 我所使用的sipp命令如下 sipp -r 300 -rp 1000 -i 192.168.0.160 -sf register.xml -inf user.csv 192.168.0.128 -aa -r 300 -rp 1000每秒钟发起300个呼叫,也就是300caps -i 192.168.0.160用于设置本地IP地址，用于填充XML文件中的local_ip，指定Contact:，Via:，和From:的地址 -sf用于加载指定的外部场景文件(UAC文件) -inf user.csv用于指定场景文件中所使用的数据，之后会有更详细的解释 192.168.0.128用于指定FreeSwitch服务器地址 关于SIPp其他参数的使用可以参考官方文档 所使用的数据文件user.csv内容如下 1000;[authentication username=2000 password=1234] 其中1000是注册号码，在XML文件里面使用field0来引入 authentication username=2000 password=1234用于服务器鉴权使用，如上方的注册流程图所示，在客户端第一次发送请求注册之后，服务器会回应401 Unauthorized消息要求鉴权，一般要求使用md5方式加密注册账号、密码以及401消息中对应的nonce字段，当然，SIPp已经将这些加密过程做好了，我们只需要提供账号密码即可。在XML场景文件中使用field1来引入输入数据到第二次INVITE请求包中即可。具体可以查看上面提供的场景文件。 这是我测试的结果： 测试结果","tags":[{"name":"SIP","slug":"SIP","permalink":"https://KingsFish.github.io/tags/SIP/"}]},{"title":"机器学习02-模型的性能度量","date":"2017-07-15T01:16:23.000Z","path":"2017/07/15/Machine-Learning-02/","text":"性能度量用于判定机器学习的结果好坏程度。在比对不同的模型能力的时候，使用不同的性能度量往往会导致不同的评判结果。 在预测任务中，数据集D={(x1,y1),(x2,y2),···(xk,yk)}，yi是xi的真实标记。如果评估学习器f的性能，需将f(x)与yi进行比较。 回归任务常用的性能度量常用“均方误差”作为回归任务的性能度量 E(f;D)=(1/m){f(x1)-y1)+···+f(xm)-ym)} 更一般的，对于数据分布D和概率密度函数p(x)，有 E(f;D)=sum(f(x)-y)2)p(x)dx 分类任务常用的性能度量错误率和精度错误率和精度是分类任务中最常用的两种性能度量，既适用于二分类任务，也适用于多分类任务。错误率是分类错误的样本数占总数的比例，精度则是分类正确的样本数占总数的比例。对于数据集D，分类错误率定义为 E(f;D)=l/m其中l是指所有数据集中，f(xi)!=yi的个数 而精度定义为 acc(f;D)=n/m=1-E(f;D)其中n是指所有数据集中，f(xi)=yi的个数 更一般的，对于数据分布D和概率密度函数p(x)，错误率为 E(f;D)=sum(l(x)p(x))其中，l(x)取值为0或者1，当f(x)=y时取0，当f(x)!=y时取1 精度为 acc(f;D)=sum(l(x)p(x))=1-E(f;D)其中，l(x)取值为0或者1，当f(x)=y时取1，当f(x)!=y时取0 查准率、查全率与F1错误率和精度虽然常用，但是不能满足所有需求。以西瓜问题为例，我们用训练好的模型进行判别，显然，错误率指的是有多少比例的西瓜判别错误，但是我们关心的是“好瓜有多大的比例被挑出来了”或者“挑出来的西瓜有多少是好瓜”，这是就需要用到其他的度量。对于此类问题，“查全率”和“查准率”是更为适合的性能度量。 对于二分类问题，可以根据真实结果和预测结果对整体数据进行划分，分为“真正例”，“假正例”，“假反例”和“真反例”。如下表所示： 真实类别 预测为正例 预测为反例 正例 TP(真正例) FN(假反例) 反例 FP(假正例) TN(真反例) 此表称为“混淆矩阵(confusion matrix)” 查准率P和查全率R分别定义为 查准率PP=TP/(TP+FP) 查全率RR=TP/(TP+FN) 一般来说， 查准率高的时候，查全率偏低；查全率高的时候，查准率往往降低。以西瓜问题为例：查准率指的是所有预测为好瓜的西瓜中，真正的好瓜所占的比例；查全率指的是真正的好瓜中，有多少好瓜被挑出来了。 以查准率P为纵轴，查全率R为横轴作图，就得到了查准率-查全率曲线，称为“P-R曲线”。 P-R曲线 在比较两个模型的性能时，如果一个学习器的P-R曲线被另外一个学习器P-R曲线包住，那么后者的性能优于前者，如上图，A的性能优于C，B的性能也优于C；如果两个学习器的曲线有交叉点（如A和B），那么难以断定两个学习器性能的优劣，只能在具体的查准率或者查全率条件下进行比较。 然而，在很多情况下，还是希望将AB做出比较，这时可以对比AB的P-R曲线下面积。但是这个值不太容易估量，因此有其他的性能度量来综合考察查准率和查全率。 平衡点平衡点(Break-Even Point，简称BEP)指得是“P=R”时候的取值，如上图，C的的BEP是0.64,。基于BEP的比较，可以认为学习器A优于B。 F1度量BEP过于简单，更常用的是F1度量。 F1=2*P*R/(P+R)=2*TP/(样例总数+TP-TN) F1是基于查准率和查全率的调和平均定义的 1/F1=1/2*(1/P+1/R) 对于特定的应用场景，查准率和查全率的重视度是不一样的。例如在追捕逃犯时，希望尽可能的不遗漏逃犯，因此查全率较为重要；而在搜索引擎的搜索过程中，希望给用户精准的搜索信息，因此查准率更为重要。F1度量的更一般形式——Fβ Fβ=(1+β2)*P*R/((β2*P)+R) 其中β&gt;0度量了查全率对查准率的相对重要性β=R/P。β=1时退化为标准的F1。 有时候我们会有多个混淆矩阵，比如我们做了多次训练。我们希望在n个二分类混淆矩阵上考察查准率和查重率。 一种直接的做法是在各混淆矩阵上分别求出查准率和查全率(P1,R1)···(Pn,Rn)，再求其平均，这称之为“宏查准率(macro-P)”、”宏查全率(macro-R)”以及“宏F1(macro-F1)” 另一种做法是先将个混淆矩阵对应元素进行平均，得到TP、FP、TN、FN的平均值，之后根据平均值求“微查准率(micro-P)”、”微查全率(micro-R)”以及”微F1(micro-F1)” ROC与AUC分类任务一般是如下流程：经过一定的训练之后，对于测试集的每一个数据，学习器给出相应的输出预测值，然后将这个预测值与某一个阈值(Threshold)进行比较，若大于阈值则为正例，否则为反例。例如，假设学习器输出的预测值范围为[0.0,1.0]，阈值为0.7，那么学习器输出预测值大于0.7的为正例，反之则为反例。 实际上，我们可以根据输出预测值进行排序，“最可能”的是正例排在前面，而“最不可能的”排在后面，然后使用阈值作为“截断点”将样本分类。 在不同的场景中，我们可以根据任务需求不一来确定截断点。因此，排序的好坏体现了学习器在不同任务下的“期望泛化性能”的好坏。ROC曲线则是从这个角度出来来研究学习器泛化性能的有力工具。 ROC全称为“受试者工作特征(Receiver Operating Characteristic)”曲线。ROC曲线的纵轴是“真正例率”(True Positive Rate，简称TPR)”，横轴为“假正例率(False Positive Rate，简称FPR)”，两种分别定义为： 真正例率TPR=TP/(TP+FN) 假正例率FPR=FP/(TN+FP) 真正例率指的是真实正例中有多少被预测为正例，假正例率指的是真实反例中有多少被预测为正例。 ROC曲线和AUC示意图 对角线对应于“随机猜想”模型。点(0,1)则是所有正例都排在反例前面的“理想模型”。在实际情况中，通常是利用有限个测试样例来绘制ROC曲线，此时只能获得有限个坐标点，得不到圆滑的曲线（上图右侧）。 与P-R曲线类似，如果学习器A的ROC曲线被学习器B完全“包住”，那么后者性能优于前者。但是当两个曲线有交点时，则需要比较曲线下的面积AUC(Area Under ROC Curve)。 AUC可以由ROC曲线的每个坐标点与横轴围成的矩形面积求和得到。 代价敏感错误率与代价曲线现实生活中会有这样的场景，不同类型造成的错误后果不同。比如门禁，错误的把可通过人员挡在门外，会使得用户体验不佳，但是如果把不可通过人员进入则会造成严重的安全事故。为了权衡不同错误导致的不同损失，可以给每个错误设立一定的权重，称之为“非均等代价(unequal cost)”。 以二分类为例，可以设定一个“代价矩阵(cost matrix)”。如下表，其中costij代表将第i类预测为第j类样本的代价。一般来说，costii=0。 真实类别 预测为第0类 预测为第1类 第0类 0 cost01 第1类 cost10 0 根据上表，”代价敏感(cost-sensitive)“定义为 E(f;D;cost)=(1/m)*sum(l*cost01+n*cost10) 其中，l为真实类别中第0类而预测为第0类的数据个数，n为真实类别中第1类而预测为第1类的数据个数 在非均等代价下，ROC不能直接反映出学习器的期望总体代价，而”代价曲线“则可以到达该目的。代价曲线的横轴是取值为[0,1]的正例概率代价： P(+)cost=p*cost01/(p*cost01+(1-p)*cost10) 其中，p是样例为正例的概率；纵轴是取值为[0,1]的归一化代价。 costnorm=FNR*p*cost01+FPR*(1-p)*cost10/(p*cost01+(1-p)*cost10) 其中，FPR为ROC曲线中的假正例率，FNR=1-TPR是假反例率。代价曲线的绘制很简单： ROC曲线上的每一个点对应了代价平面的一条线段，假设ROC曲线上的坐标为(TPR, FPR)，则可相应计算出FNR，然后在代价平面上绘制从(0,FPR)到(1,FNR)的线段。如此将ROC曲线上的每一个点转化成代价平面上的一条线段，然后取所有线段的下界，围城的面积就是在所有条件下学习器的期望总体代价。 代价曲线与期望总体代价","tags":[]},{"title":"机器学习01-模型评估与选择以及参数的调节","date":"2017-07-14T08:11:11.000Z","path":"2017/07/14/Machine-Learning-01/","text":"模型评估与过拟合学习器在训练过程中，很容易将训练样本本身的特征当作普遍特征。如在西瓜挑选问题中，如果训练样本中有很大一部分西瓜为深绿色，则学习器很大可能会将深绿色作为好瓜的评定标准之一。再比如在树叶判定过程中，如果给的叶子中有很多是有锯齿的，那么学习器很可能会将锯齿作为叶子的判定标准之一，继而产生错误的判定结果。这也称之为“过拟合”。 评估方法很多时候我们只有D一个数据集，那么我们就需要将D进行训练集S和测试集T的划分，评估方法就是用来划分集合的方法。但是不管是什么方法都需要注意一点，训练集的数据最好不要出现在测试集中。以下是一些划分集合的方法： 留出法将数据集D直接划分两个互斥的集合，即S|T=D，S&amp;T=O。 注意，S和T的划分应该尽可能保持数据分布的一致性，即如果D中有1000个数据，其中700个正例和300个反例，且S有700个数据，T有300个数据，那么S最终应当有490个正例和210个反例。这种抽样方法也称之为“分层抽样”。 另外一个需要注意的问题是，单次的留出法并不可靠，每次抽样的数据有波动，那么这些不同的划分会导致不同的结果。因此一般在实际过程中需要随机多次划分，重复进行实验，最后取这些重复实验的均值最为最终结果。 留出法还有一个问题是，如果S划分的太小，那么与D的差距较大，那么测试集的结果与真实结果会有很大差别；但是如果S划分的太小，那么测试集T规模很小，最终的结果可能不稳定准确。此问题没有解决方法，一般取2/3~4/5的样本用于训练，剩余样本用于测试。 交叉验证法将D进行分层抽样，产生多个互斥子集{D&lt;sub&gt;1&lt;/sub&gt;,D&lt;sub&gt;2&lt;/sub&gt;,···D&lt;sub&gt;k&lt;/sub&gt;}，保持每个互斥子集的分布一致性，K最常用的取值是10，此时称为10折交叉验证；其他常用的还有5、20。 10折交叉验证示意图 同样，交叉验证法也有和留出法一样的不稳定问题，也需要进行多次划分，常见的有10次10折交叉验证法。 若D中有m个样本数据且k=m，则称之为留1法，此方法结果比较准确，但是当m比较大的时候，计算开销太大。 自助法假设D有m个样本，在上面的两种方法中，都需要留出一部分数据用于测试，当数据集规模比较小的时候会有很大的偏差，最后的结果会受到影响。 自助法是一个很好的解决方法。对于数据集D，每次在D中抽取一个样本复制到D&#39;，然后将其放回，重复m次后得到新样本数据集D&#39;，显然，这个新的数据集中会有一部分的重复数据，另外一部分数据则不会出现在新样本数据中。做一个简单的估计，样本在m次抽样中都不被抽取的概率是(1-1/m)&lt;sup&gt;m&lt;/sup&gt;，取极限可得概论为1/e，约为36.8%。所以最终会有36.8%的数据保留作为测试数据。这个方法也成为“包外估计”。 自助法一般在数据集规模较小的时候使用，因为此方法会有估计误差。数据集规模较大的时候一般使用“留出法”和“交叉验证法”。 调参与最终模型大多数算法都需要进行参数调节，参数配置的不同往往影响着模型性能的好坏。学习算法中的很多参数在实数范围内取值，因此对于每一个参数都建立模型是不可行的。通常的做法是：对每一个参数选定一个范围和变化步长，如选定变化范围[0,5]，步长为1，那么实际要评估的参数有6个，最终从这6个候选值中产生选定值。 给定包含m个样本的数据集D，在模型评估和选择过程中由于需要留出一部分数据用于评估测试。因此，在模型选择完毕后，学习算法和参数已经选定，此时应该用数据集D重新训练模型。这个模型在训练过程中使用了所有m个样本。这才是最终我们提交给用户的模型","tags":[{"name":"Machine Learning","slug":"Machine-Learning","permalink":"https://KingsFish.github.io/tags/Machine-Learning/"}]},{"title":"Leetcode-554 Brick Wall题解","date":"2017-07-13T15:24:01.000Z","path":"2017/07/13/Leetcode-554-Brick-Wall/","text":"今天刷leetcode碰到了这题，题目如下: There is a brick wall in front of you. The wall is rectangular and has several rows of bricks. The bricks have the same height but different width. You want to draw a vertical line from the top to the bottom and cross the least bricks. The brick wall is represented by a list of rows. Each row is a list of integers representing the width of each brick in this row from left to right. If your line go through the edge of a brick, then the brick is not considered as crossed. You need to find out how to draw the line to cross the least bricks and return the number of crossed bricks. You cannot draw a line just along one of the two vertical edges of the wall, in which case the line will obviously cross no bricks. Example:Input: [[1,2,2,1],[3,1,2],[1,3,2],[2,4],[3,1,2],[1,3,1,1]] Output: 2Explanation: 题目大意题目的大概意思是给我们一堵墙的砖块组成，用二维的List或者说数组表示，每一层的宽度是一样的，数组中的每个数字代表砖块的宽度，如上图所示。题目要求我们找出垂直划线的情况下所穿越的最小砖块数，当然，墙最左端和最右端是不在思考范围内的，因为两边所穿越的砖块数必然是0手动滑稽。 思路大概阅读了题目之后，受到之前Leetcode上计算汉明距离那题的影响，我首先想到的是从左到右遍历，因为墙的宽度一致，而且砖宽度都是整数，因此对于每一层，我们计算出每一层当前位置往左的总长度，之后在垂直方向以步长为一，逐步计算每根线画下来穿过的砖块数，同时记录最小穿过的砖块数，即可达到目的。 123456789101112131415161718192021222324252627public int leastBricks(List&lt;List&lt;Integer&gt;&gt; wall) &#123; if (wall.size() == 0) &#123; return 0; &#125; int sum = 0, min = Integer.MAX_VALUE;; for (int i = 0; i &lt; wall.size(); i++) &#123; List&lt;Integer&gt; list = wall.get(i); for (int j = 1; j &lt; list.size(); j++) &#123; list.set(j, list.get(j - 1) + list.get(j)); &#125; sum = list.get(list.size() - 1); &#125; for (double i = 0.5; i &lt; sum; i += 0.5) &#123; int temp = 0; for (int j = 0; j &lt; wall.size(); j++) &#123; int k = wall.get(j).size() - 1; while (k &gt;= 0 &amp;&amp; wall.get(j).get(k--) &gt; i); if (wall.get(j).get(k + 1) != i)&#123; temp ++; &#125; &#125; if (temp &lt; min) &#123; min = temp; &#125; &#125; return min;&#125; 将此代码提交之后以后结果超时，看了一下超时测例是[[1000000],[10000000],[10000000]]，根据我的思路当然会超时，因为要迭代10000000次，如果碰上数值更大的则耗时更久。 参考了一下别人已经AC的答案，比较好的思路应该是用HashMap（特意选Tag是HashMap的题目来做，结果自己根本就没用上…）记录。对于墙的各层，如果一个完整的砖块以左（包含自己）长度相等，那么从此长度往下划线的时候就不会穿过此砖块，因此，我们只需要记录同一个长度出现的次数，最终，如果以出现次数最多的长度往下划线，穿过的砖块数就越少。代码重写如下： 1234567891011121314151617181920public int leastBricks(List&lt;List&lt;Integer&gt;&gt; wall) &#123; if (wall.size() == 0) return 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); int max = 0; for (List&lt;Integer&gt; list : wall) &#123; int length = 0; for (int i = 0; i &lt; list.size() - 1; i++) &#123; length += list.get(i); int times; if (map.containsKey(length)) &#123; times = map.get(length) + 1; &#125; else &#123; times = 1; &#125; map.put(length, times); max = max &lt; times ? times : max; &#125; &#125; return wall.size() - max; &#125; 总结写完总结一下，其实自己的思路已经很接近正确的思路了，计算每一层完整砖块左边的长度总和，之后进行比较即可，不过自己依然没有想到用HashMap记录来比较能更高效求的结果。这一类的题目其实都有套路，熟能生巧，做的多了，也就会了。","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"},{"name":"HashMap","slug":"HashMap","permalink":"https://KingsFish.github.io/tags/HashMap/"}]},{"title":"Linux下配置串口","date":"2017-07-13T14:55:37.000Z","path":"2017/07/13/Configuration-of-serial-port-on-Linux/","text":"背景串口是物理连接，相比于ssh来说比较稳定，平时使用ssh远程操作Linux，但是在网络挂掉的情况下串口往往是最终手段，因为生产环境下的服务器一般没有视频输出接口，而会有串口，并且只需要一根串口线，其他电脑就可以物理连接到服务器并进行操作。 之前实验室做了个服务器的项目，对方要求实现通过串口登陆并控制Linux，但是已经购买的服务器并没有串口，于是买了一个USB转串口设备，服务器通过USB转接扩展出串口，之后仍然需要在服务器做相应的配置才能实现登陆。其实USB转串口设备与真实的串口设备配置差别不大，这个之后会说到。花了很久的时间才google出相关的配置方法，因此记录一下。 步骤我的Linux环境是CentOS 6.5 x64 首先是驱动的问题，通过查阅资料发现，CnetOS 6.5已经集成了RS232串口驱动，因此驱动方面我们无需再操心。 想要通过串口连接Linux，那就必须用到getty。getty是get teletype的缩写,它是一个Unix程序，用来连接物理的或虚拟终端，我们需要启动它来监听我们的USB口来查看是否有活动。getty有很多版本，常见的有agetty和fgetty，在我的Linux中的是agetty。Linux下配置串口（USB转串口）主要分三个部分： 一、创建脚本创建文件/etc/init/ttyUSB0.conf，并输入以下内容： 1234567# ttyUSB0 - agetty# This service maintains a agetty on ttyUSB0 from the point the system# started until it is shut down again.start on stopped rc RUNLEVEL=[12345]stop on runlevel [!12345]respawnexec /sbin/agetty -L 9600 ttyUSB0 vt100 脚本 注： #之后的是注释 RUNLEVEL为Linux启动模式 9600为串口速率，可更改，但切记：通过串口连接服务器的速率需与其一致 ttyUSB0为插入USB转串口设备后系统为其分配的文件名，每个人的环境不一样需要随之更改，此设备名可以在/dev下查看，真实的串口设备分配的名称应该是ttyS0、ttyS1等。 vt100为终端模式，常用的还有vt220 二、启动脚本在Linux控制台中输入： 1sudo start ttyUSB0 注：ttyUSB0是第一步中创建的脚本名称，可更改 三、将脚本加入开机启动修改/etc/inittab，在其最后添加 1t0:123:respawn:/sbin/agetty -L ttyUSB0 9600 vt100 再在`Linux·终端输入 1sudo /sbin/telinit q 做完上面的三个步骤，就可以通过串口来登陆Linux了。 但是按照如上步骤配置完root用户是无法通过串口登陆的，因为root的权限过高，因此收到一定的限制。如果想要让root用户也可以通过串口登录到服务器，则还需要做如下配置： 四、允许root用户通过串口登陆修改/etc/securetty，添加 1ttyUSB0 这样，root用户就可以通过串口登录到Linux服务器了。 客户端方面比较简单，只需打开支持串口的ssh工具如putty，将速率设置与脚本里的一致，并选中windows电脑所使用的串口设备号即可。 刚接入的时候putty上可能会出现无登陆提示的情况 `putty`无登陆提示 不用管，直接输入用户名 输入用户名 这个时候就会有输入密码提示 输入密码提示 至此，Linux下配置串口教程全部完成。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://KingsFish.github.io/tags/Linux/"}]},{"title":"Leetcode 409 Logest Palindrome题解","date":"2017-07-13T12:24:01.000Z","path":"2017/07/13/Leetcode-409-Longest-Palindrome/","text":"题目如下： Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters. This is case sensitive, for example “Aa” is not considered a palindrome here. Note:Assume the length of given string will not exceed 1,010. Example: 123456Input:&quot;abccccdd&quot;Output:7Explanation:One longest palindrome that can be built is &quot;dccaccd&quot;, whose length is 7. 题目大意题目的大概意思是，给定一个字符串，要我们找出字符串中可以组合成的最长回文长度，比如abccccdd可以组成的最长回文字符串是dccaccd，长度为7，将其返回即可 思路一开始想到的思路比较简单，将字符串化成字符数组并排序，遍历此数组，找出所有相同字符的数量，如果为1个，将其忽略，如果是1个以上的奇数，则总长度加上这个奇数减一，如果为1以上的偶数，则总长度直接加和即可。最后仍然需要做一个判定，如果出现这种情况abbccdd，结果应该是7而不是6，需要有一个flag来记录是否出现过单个的字符，因为出现一次的字符可以放在回文的中间，其次，如果出现1以上的奇数，也需要将其记录，如aabbbccdd，结果应该是9而不是8。因为使用了一个字符串数组，因此空间复杂度为O(n)，而只遍历了一次，因此时间复杂度为O(n)。此思路的代码如下： 123456789101112131415161718192021222324252627public int longestPalindrome(String s) &#123; char [] cs = s.toCharArray(); Arrays.sort(cs); int result = 0; boolean isSingle = false; for (int i = 0; i &lt; cs.length; i++) &#123; int temp = i; while (i + 1 &lt; cs.length &amp;&amp; cs[i] == cs[i + 1]) &#123; i++; &#125; if (i != temp) &#123; temp = i + 1 - temp; if (temp % 2 == 0) &#123; result += temp; &#125; else &#123; result += temp - 1; isSingle = true; &#125; &#125; else &#123; isSingle = true; &#125; &#125; if (isSingle) &#123; result += 1; &#125; return result;&#125; 此代码提交之后通过了，总时长为12ms，超越了74%的提交。 提交结果 阅读了一下其他人提交的代码，有的思路是使用HashSet或者HashTable，将字符串拆成数组并排序，遍历此数组，如果在HashSet中发现了该字符，则计数量count加1，否则将此字符加入HashSet，遍历完之后如果发现HashSet不为空，那么最终的长度应该是count的两倍加1，否则最终的长度为count的两倍。此思路空间复杂度为O(n)，时间复杂度也为O(n)。代码如下： 123456789101112131415public int longestPalindrome_v2(String s) &#123; if(s==null || s.length()==0) return 0; HashSet&lt;Character&gt; hs = new HashSet&lt;Character&gt;(); int count = 0; for(int i=0; i&lt;s.length(); i++)&#123; if(hs.contains(s.charAt(i)))&#123; hs.remove(s.charAt(i)); count++; &#125;else&#123; hs.add(s.charAt(i)); &#125; &#125; if(!hs.isEmpty()) return count*2+1; return count*2;&#125; 提交结果： 提交结果","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"},{"name":"HashSet","slug":"HashSet","permalink":"https://KingsFish.github.io/tags/HashSet/"}]},{"title":"Leetcode-543 Diameter of Binary Tree题解","date":"2017-07-13T12:24:01.000Z","path":"2017/07/13/Leetcode-543-Diameter-of-Binary-Tree/","text":"题目如下： Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.Example:Given a binary tree 12345 1 / \\ 2 3 / \\ 4 5 Return 3, which is the length of the path [4,2,1,3] or [5,2,1,3]. Note: The length of path between two nodes is represented by the number of edges between them. 题目大意给定一颗二叉树，寻找这棵树的直径，直径定义为这棵树中任意两个节点的路径长度最大值。如上面的给定的那棵树，明显最长路径是3，也即4 -&gt; 2 -&gt; 1 -&gt; 3。当然有一点要注意，最长路径可能不经过根节点。 思路这道题是104. Maximum Depth of Binary Tree的运用题目。刚拿到题目我一开始是不敢做的， 因为潜意识里认为这题很难。但是看了一下题目居然是Easy难度，仔细思考了一下发现难度其实不大，主要是考查树的遍历。最长路径有两种： 其一，这条路径经过了根节点，那么只需要找出根节点下的两棵子树的深度然后相加即可。 其二，如果这条路径没有经过根节点，那么只需要找出根节点左子树内或者根节点右子树内的最深度即可。自底向上，递归查找子树的深度，如果发现左子树深度与右子树深度之和大于当前纪录的直径，那么进行相应的值记录，然后返回左子树和右子树深度较大的那个来进行下一轮的比对。递归完成之后即可找出直径。 整个树进行了一次递归调用，因此时间复杂度是O(n)，n是树的节点数，同时，只使用了一个数来记录直径，因此空间复杂度是O(1)，代码如下： 1234567891011121314151617int depth = 0;public int diameterOfBinaryTree(TreeNode root) &#123; search(root); return depth;&#125;private int search(TreeNode root) &#123; if (root == null) &#123; return 0; &#125; int left = search(root.left); int right = search(root.right); if (depth &lt; left + right) &#123; depth = left + right; &#125; return left &gt; right ? left + 1 : right + 1;&#125; 提交AC，运行时间8ms 提交结果 总结其实很多题目并不难，只是自己看到题目之后觉得比较复杂，潜意识里就认为这道题比较难而不敢做。这道题只是之前做过的一道题的扩展而已，继续加油练习。","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"},{"name":"Binary Tree","slug":"Binary-Tree","permalink":"https://KingsFish.github.io/tags/Binary-Tree/"}]},{"title":"Leetcode-525 Contiguous Array题解","date":"2017-07-13T12:24:01.000Z","path":"2017/07/13/Leetcode-525-Contiguous-Array/","text":"题目如下： Given a binary array, find the maximum length of a contiguous subarray with equal number of 0 and 1.Example 1: 123Input: [0,1]Output: 2Explanation: [0, 1] is the longest contiguous subarray with equal number of 0 and 1. Example 2: 123Input: [0,1,0]Output: 2Explanation: [0, 1] (or [1, 0]) is a longest contiguous subarray with equal number of 0 and 1. 题目大意给定一个只包含0和1的数组，找出数组中0和1数量相等的最长子序列。 思路将0变成-1，然后遍历整个数组，求出前面的的数字之和，同时将这个数字放在HashSet中记录，如果之后的遍历之中出现了相同的和，那么说明这一段长度内的0和1数量相等，然后把这些子序列中的长度最长的那个记录并返回即可。整个数组只遍历了一次，因此时间复杂度是O(n)，使用了HashSet记录数组和， 空间复杂度比较难分析，与输入有关，最坏情况是O(n)，最好情况是O(1)，代码如下： 1234567891011121314public int findMaxLength(int[] nums) &#123; int sum = 0, max = 0; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); map.put(0, -1); for (int i = 0; i &lt; nums.length; i++) &#123; sum += nums[i] == 0 ? -1 : 1; if (map.containsKey(sum)) &#123; max = max &gt; i - map.get(sum) ? max : i - map.get(sum); &#125; else &#123; map.put(sum, i); &#125; &#125; return max;&#125; 提交AC，运行时间75ms 提交结果 很好奇的看了下时间最短的代码，时间只有35ms，给大神们跪了。。。 1234567891011121314151617public int findMaxLength(int[] nums) &#123; int len = nums.length; int[] map = new int[len*2+1]; int cp = len, res = 0; map[cp]=1; for(int i=0; i&lt;len; i++)&#123; cp+=2*nums[i]-1; if(map[cp]==0) map[cp]=i+2; else&#123; int ssl = i-map[cp]+2; if(res &lt; ssl) res=ssl; &#125; &#125; return res;&#125; 大概看了代码，思路是类似于状态机。先新建一个2倍nums长度+1的数组，从新数组中间的位置开始，对于nums中每一个数，如果是0，则新数组指针往左移动一格；如果碰到了1，则指针往右移动一格。同时在新位置判断，如果此位置之前没有存储过数值，则在此位置存储i，否则说明目前为止出现过0和1数量i相等的子序列，并且起始位置即为此位置存储的i，因此直接计算子序列长度即可。依次遍历，这样就能把最长子序列求出来。该数组遍历了一次，因此时间复杂度是O(n)，使用了2*n+1长度的辅助数组，因此空间复杂度是O(n)。 提交结果","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"},{"name":"HashSet","slug":"HashSet","permalink":"https://KingsFish.github.io/tags/HashSet/"}]},{"title":"Leetcode-15 3Sum题解","date":"2017-07-13T03:53:22.000Z","path":"2017/07/13/Leetcode-15-3Sum/","text":"题目如下： Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0?Find all unique triplets in the array which gives the sum of zero.Note: The solution set must not contain duplicate triplets.For example, given array S = [-1, 0, 1, 2, -1, -4],A solution set is:[ [-1, 0, 1], [-1, -1, 2]] 题目大意给定一个数组，要求找出所有和为0的三个数的集合，不能重复。 思路最直接的思路是遍历，先对数组排序，然后第一层遍历固定第一个数字，在第一个数字右边进行第二层遍历，固定第二个数字，再进行二分查找是否有加和为0的第三个数。在此同时，为了防止重复的组合，需要记录上次和为0的值并与此次值进行比较。时间复杂度为O(n2 logn)，空间复杂度为O(1)。代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041public List&lt;List&lt;Integer&gt;&gt; threeSum_v2(int[] nums) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); List&lt;Integer&gt; temp; int lastIndex_i = -1, lastIndex_j = -1; for (int i = 0; i &lt; nums.length - 2;) &#123; for (int j = i + 1; j &lt; nums.length - 1; j++) &#123; int position = binarySearch(nums, - (nums[i] + nums[j]), j + 1, nums.length); if (position != -1) &#123; if (!(lastIndex_i != -1 &amp;&amp; nums[i] == nums[lastIndex_i] &amp;&amp; nums[j] == nums[lastIndex_j])) &#123; temp = new ArrayList&lt;&gt;(); temp.add(nums[i]); temp.add(nums[j]); temp.add(nums[position]); result.add(temp); lastIndex_i = i; lastIndex_j = j; &#125; &#125; &#125; i++; while (i &lt; nums.length - 2 &amp;&amp; nums[i] == nums[i - 1]) &#123; i++; &#125; &#125; return result;&#125;private int binarySearch(int [] nums, int target, int lo, int hi)&#123; while (lo &lt; hi) &#123; int mid = lo + (hi - lo) / 2; if (nums[mid] &gt; target) &#123; hi = mid; &#125; else if (nums[mid] &lt; target) &#123; lo = mid + 1; &#125; else &#123; return mid; &#125; &#125; return -1;&#125; 提交之后AC了，但是时间惨不忍睹，218ms。 运行时间 看了看大神们是怎么做的，思路和我很类似，也是先对数组排序，但是在第二层遍历的时候直接进行第二和第三个数字。对于每一个第一层的数字，第二层遍历分别将最左端的值和最右端的值最为初始值,left和right，如果加和发现过大，那么就是右边的值太大，将right减1。反之如果加和发现太小，那么就是左边的值太小，将left加1，以此类推，直至三个数加和或者left大于right。仍需要注意的是，在第二层遍历中，如果找出了一组加和为0的集合，记录之后如果left右边或者right左边有与left和right相同的值，则分别需要进行左移和右移防止集合重复。 这个算法还有其他小细节的改进。如果发现第一个数字为正数，那么可以直接结束搜索，因为正数右边全为正数，加和不可能为0。其次，如果排序之后发现最后一个数为负数，那么也可以直接结束搜索。此算法进行了两层循环，所以时间复杂度为O(n2)，空间复杂度为O(1)。代码如下 ​123456789101112131415161718192021222324252627282930313233public List&lt;List&lt;Integer&gt;&gt; threeSum_v1(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;(); Arrays.sort(nums); if (nums.length &gt; 0 &amp;&amp; nums[nums.length - 1] &lt; 0) return lists; for (int i = 0; i &lt; nums.length - 2; i++) &#123; // if nums[i] &gt; 0, we can never get sum to 0 if (nums[i] &gt; 0) break; //avoid duplicate triplets if (i != 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int target = -nums[i]; int left = i + 1, right = nums.length - 1; // both side while (left &lt; right) &#123; // target is negative if (nums[left] + nums[right] &gt; target) &#123; // right side is too huge right--; &#125; else if (nums[left] + nums[right] &lt; target) &#123; // left side is too small left++; &#125; else &#123; lists.add(Arrays.asList(nums[i], nums[left], nums[right])); // avoid duplicate while (++left &lt; right &amp;&amp; nums[left] == nums[left - 1]) ; while (--right &gt; left &amp;&amp; nums[right] == nums[reft + 1]) ; &#125; &#125; &#125; return lists;&#125; 提交结果，运行时间为71ms： 运行结果 总结第二版的运行时间比我的第一版短了2/3，而且代码比我的清晰简洁了很多。算法的能量是巨大的，仍需继续努力啊。","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://KingsFish.github.io/tags/Binary-Search/"}]},{"title":"FreeSwitch增加控制台命令","date":"2017-07-13T02:42:56.000Z","path":"2017/07/13/Adding-connsole-commands-in-FreeSwitch/","text":"最近老板的活大部分干完了，大概总结一下。 一、主要内容老师给的活主要分为四个部分： 修改FreeSwitch绑定的IP和端口，这个情况主要是用在多网卡的服务器上。因为FreeSwitch运行的时候默认会绑定某一个IP地址，但是默认绑定的地址可能不是我们想要的IP，于是就有了绑定IP的控制台命令。端口 用户管理，包括用户的增、删、改、查。 呼叫转移规则，包括遇忙转移、无条件转移、无应答转移以及热线电话。 会议管理，包括会议的增、删、改、查。改的部分只做了改密码，而且会议开启之后才能改密码。 二、目前工作状况2.1 FreeSwitch服务器IP的端口修改FreeSwitch绑定的IP和端口是通过读写文件完成的。涉及到的文件有5个，包括 ${conf.dir}/vars.xml ${conf.dir}/sip_profile/external.xml ${conf.dir}/sip_profile/internal.xml 其中，vars.xml中需要修改一个参数&lt;X-PRE-PROCESS cmd=&quot;set&quot; data=&quot;domain=$${local_ip_v4}&quot;/&gt; external.xml需要修改两个参数&lt;param name=&quot;rtp-ip&quot; value=&quot;$${local_ip_v4}&quot;/&gt;&lt;param name=&quot;sip-ip&quot; value=&quot;$${local_ip_v4}&quot;/&gt; internal.xml需要改的参数与externaml.xml文件改的一样&lt;param name=&quot;rtp-ip&quot; value=&quot;$${local_ip_v4}&quot;/&gt;&lt;param name=&quot;sip-ip&quot; value=&quot;$${local_ip_v4}&quot;/&gt; 如果改一次IP就得把3个文件读取然后改完再重写，比较麻烦而且读写文件会影响服务器运行效率师兄给的意见是在vars.xml中添加server_bind_ip这个全局变量，然后将上面的5个参数的值置为server_bind_ip，之后修改IP只需要改server_bind_ip这个值就可以 但是老师认为不能让管理人员去修改xml文档，因此我又加上了一个新的全局参数ip_changed，用于查看IP是否改过，server_bind_ip这个参数是否添加过，如果添加过只需改一下server_nbbind_ip参数即可，但是如果没有添加过，则需要改上述3个文件以及添加server_bind_ip参数 修改端口就简单很多，只需要修改vars.xml中的&lt;X-PRE-PROCESS cmd=&quot;set&quot; data=&quot;internal_sip_port=5060&quot;/&gt;即可。而至于修改静态路由则等服务器对接之后再进行，综合之前所看到的资料，应该是修改${conf.dirs}/dialplan/default.xml即可 2.2 用户信息管理用户信息管理主要包括增、删、改、查 增加用户只需要往${conf.dir}/directory/default目录下添加以用户ID命名的xml文件，此xml文件的内容有模版，然后修改其中的三个参数password,priority,forced_released_call。其中forced_released_call是可选的，默认为true，其他的默认，之后再“reloadxml”-重新加载一下xml 删除用户方面，只需要删除上述目录下用户ID对应的xml文档 修改用户信息方面，与增加用户类似，只能修改三个参数password,priority,forced_released_call。修改${conf.dir}/directory/default目录下用户ID相同的xml文档，读取文档，修改之后再重新写入即可 查询用户信息则简单得多，FreeSwitch则已经提供了查询所有用户信息的API。但是我们查询用户也需要针对某一个特定用户的信息查询，其次FreeSwitch提供的查询API没有给出用户密码等级等相关信息。因此有两个工作，一个是针对查询所有用户信息API进行修改，增加密码等级等信息，二是增加对于特定ID查询用户信息。所需要的工作不多，源代码中提供了用户信息查询的函数，直接调用就能得到所需的信息。 2.3 呼叫转移规则设置呼叫转移规则则包括四个方面： 无条件转移 遇忙转移 无应答转移 热线电话 这4个方面都包括四个小方面：增、删、改、查。增和改其实都是一个命令，所以简化之下就只有三个方面，且这四个方面只需要一个命令即可。 增：db insert/${domain}-${cmd}/${user_id}/${transfer_id} 删：db delete/${domain}-${cmd}/${user_id}/${transfer_id} 查：db select/${domain}-${cmd}/${user_id} 其中，${domain}是服务的IP，${user_id}是设置转移规则的用户，${tranfer_id}是设置转移规则的目标用户，${cmd}为字符串，各规则不一，对应如下： 无条件转移 -&gt; cfwdn 遇忙转移 -&gt; cfwdb 无应答转移 -&gt; cfwdna 热线电话 -&gt; hotline 至此，呼叫规则转移设置完毕 2.4 会议室管理会议室管理方面则为最难的一部分。老板的设想是预先设定会议，号码以及密码都设置好，之后参加会议的人直接打电话就可以。但是会议目前的流程是电话号码可以设定，密码也可以设置，但是这是一个总体规则，对于所有会议都使用，而且有的会议室号码不用预约也可以使用，和设想流程刚好相反。 在查阅了dialplan的相关资料之后找到了解决方法，FreeSwitch是根据dialplan中的default.xml配置来进行通话的。每一个&lt;extension&gt;都是一个配置，FreeSwitch从上到下进行扫描匹配，成功匹配到第一个之后就不再进行扫描。因此，只需要往default.xml中添加一个&lt;extension&gt;，匹配destination_number，然后在&lt;action&gt;中做出&lt;answer&gt;以及conference动作就可以。不过也需要对文件进行读取以及重新写入，需要对资源进行一定消耗。 删除会议方面不难，也是需要对文件进行读写，删除该会议的&lt;extension&gt;就可以删除该会议 其他的控制台命令如修改会议密码和查询所有会议，FreeSwitch都有提供的控制台命令，自己就无需再做了 三、总结这个项目从3月10号开始，前前后后一共花了40天左右做完，目前为止，大块头以及有难度的部分已经做完，剩下的边边角角的工作还需要跟老师商量之后很快也可以搞定，这个项目可以说告一段落了。 在此期间，其实有很大一部分时间是自己休闲，并不是所有时间都在做，所以实际上的时间可能不到一个月。现在也是研一，平时也得上课，所以没有全部时间放在上面也很正常。其次，这个服务器是C语言写的，而C语言已经很久没有写过了，进度慢也正常。 但是实际上整个项目期间，除了这个项目之外我其他的东西都没有做，算法、课程还有网络方面都拉下了，至于之前的网络也没有好好学。其次，Android也很久没有动过了，自从大四之后就没有看过相关的知识，Android版本已经过了两三个大版本，有很多新的东西需要学习，而且已经很久没写过相关的项目，手也已经生了。 近期项目大部分已经结束了，也要开始继续算法，网络以及课程的学习。这也是简书的第一篇文章，写作的习惯也要开始慢慢养成。 撸起袖子加油干！ 于2017年4月23号晚11点","tags":[{"name":"SIP","slug":"SIP","permalink":"https://KingsFish.github.io/tags/SIP/"}]},{"title":"Leetcode-18 4Sum题解","date":"2017-07-13T02:34:22.000Z","path":"2017/07/13/Leetcode-18-4Sum/","text":"题目如下： Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target. Note: The solution set must not contain duplicate quadruplets. 1234567For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.A solution set is:[ [-1, 0, 0, 1], [-2, -1, 1, 2], [-2, 0, 0, 2]] 题目大意给定一个数组，要求找出所有和为target的四个数的集合，不能重复。 思路参照3Sum的思路，只需要在3Sum代码外面加层壳即可，3Sum的题解可以参看这里。3Sum的空间复杂度是O(1)，时间复杂度是O(n2)，4Sum只是在3Sum外面加了一层遍历，因此空间复杂度为O(1)，时间复杂度为O(n3)。此思路的代码如下： 123456789101112131415161718192021222324252627282930313233343536public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123; Arrays.sort(nums); List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; nums.length - 3; i++) &#123; for (int j = i + 1; j &lt; nums.length - 2; j++) &#123; List&lt;Integer&gt; list; int lo = j + 1, hi = nums.length - 1, temp = target - (nums[i] + nums[j]); while (lo &lt; hi) &#123; if (nums[lo] + nums[hi] &gt; temp) &#123; hi --; &#125; else if (nums[lo] + nums[hi] &lt; temp) &#123; lo ++; &#125; else &#123; list = new ArrayList&lt;&gt;(4); list.add(nums[i]); list.add(nums[j]); list.add(nums[lo]); list.add(nums[hi]); result.add(list); while (lo &lt; hi &amp;&amp; nums[lo] == nums[lo + 1]) lo ++; while (hi &gt; lo &amp;&amp; nums[hi] == nums[hi - 1]) hi --; lo ++; hi --; &#125; &#125; while (j &lt; nums.length - 2 &amp;&amp; nums[j] == nums[j + 1]) &#123; j ++; &#125; &#125; while (i &lt; nums.length - 3 &amp;&amp; nums[i] == nums[i + 1]) &#123; i ++; &#125; &#125; return result;&#125; 提交之后AC，运行时间为60ms。","tags":[{"name":"Algorithm","slug":"Algorithm","permalink":"https://KingsFish.github.io/tags/Algorithm/"},{"name":"Binary Search","slug":"Binary-Search","permalink":"https://KingsFish.github.io/tags/Binary-Search/"}]}]