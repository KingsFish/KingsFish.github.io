<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>葫芦籽的碎碎念</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://KingsFish.github.io/"/>
  <updated>2019-10-03T16:21:00.634Z</updated>
  <id>https://KingsFish.github.io/</id>
  
  <author>
    <name>Fish</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谈谈Android编译运行过程</title>
    <link href="https://KingsFish.github.io/2019/10/03/%E8%B0%88%E8%B0%88Android%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <id>https://KingsFish.github.io/2019/10/03/谈谈Android编译运行过程/</id>
    <published>2019-10-02T16:01:36.000Z</published>
    <updated>2019-10-03T16:21:00.634Z</updated>
    
    <content type="html"><![CDATA[<p>最近阅读了一下<code>Android</code>编译和运行相关的文章，大概了解了整体运行过程，在这里总结一下。</p><a id="more"></a><p>整篇文章相对而言不涉及到过多的技术细节，没有什么基础的人也能够通过这篇文章了解到<code>Android</code>的相关知识。</p><p>这篇文章内容较多，主要内容有：</p><ul><li><code>JVM</code>和<code>Android</code>的关系</li><li>字节码</li><li><code>Android</code>构建系统</li><li><code>AOT</code>和<code>JIT</code>的含义，以及它们和<code>R8</code>的关系</li><li><code>Android</code>运行系统</li></ul><p>在此之前，先要说一下一些基础知识。</p><h2 id="一、CPU-amp-JVM"><a href="#一、CPU-amp-JVM" class="headerlink" title="一、CPU &amp; JVM"></a>一、CPU &amp; JVM</h2><p>每台手机设备都具有<code>CPU</code>，<code>CPU</code>性能强弱是手机流畅性影响因素之一，这里不展开讨论这个问题。目前手机端有名的<code>CPU</code>应当是高通的骁龙系列。当然也有其他架构的<code>CPU</code>，如<code>ARM</code>、<code>ARM64</code>、<code>x86</code>、<code>x86_64</code>、<code>MIPS</code>。针对不同架构的<code>CPU</code>进行开发时，需要对不同的<code>CPU</code>架构生成不同的<code>.so</code>文件，这是一件很麻烦的事情。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="ar.png" alt="不同的CPU架构" title>                </div>                <div class="image-caption">不同的CPU架构</div>            </figure><p>这个时候<code>JVM</code>（Java虚拟机）就展示出了它的优势。<code>JVM（Java Virtual Machine）</code>会在硬件层面上增加一层抽象层。也就是说，你开发的<code>app</code>只需要支持<code>Java API</code>构成的”CPU”即可，再也不用被繁多的<code>CPU</code>架构困扰，也不用做额外的适配工作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="jvm.png" alt="JVM原理" title>                </div>                <div class="image-caption">JVM原理</div>            </figure><p><code>Java</code>代码只需要使用<code>javac</code>编译器编译成字节码文件(<code>.class</code>文件)，然后代码就可以跑在<code>JVM</code>上，和操作系统隔离。一次编译，到处运行。这样，开发者无需考虑系统类型、设备类型、内存以及<code>CPU</code>，只要把精力集中在业务逻辑就可以了。</p><h3 id="1-1-JVM内部结构"><a href="#1-1-JVM内部结构" class="headerlink" title="1.1 JVM内部结构"></a>1.1 JVM内部结构</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="jvmAr.png" alt="JVM结构" title>                </div>                <div class="image-caption">JVM结构</div>            </figure><p>下面来说说<code>JVM</code>，<code>JVM</code>主要由三部分构成：</p><ul><li><code>ClassLoader</code><br>负责加载编译后的<code>Java</code>文件(<code>.class</code>)，验证链接关系，检测字节码是否正确，为静态变量和代码分配内存以及初始化。</li><li>运行时数据<br>负责所有的程序数据：<code>stack</code>、方法、变量还有<code>Heap</code></li><li>执行引擎<br>执行编译完成并加载的代码和<code>GC</code></li></ul><p>了解完以上知识之后，就可以开始继续了解解释器(<code>Interpreter</code>)和<code>JIT</code>编译器了。</p><h3 id="1-2-Interpreter-amp-JIT"><a href="#1-2-Interpreter-amp-JIT" class="headerlink" title="1.2 Interpreter &amp; JIT"></a>1.2 Interpreter &amp; JIT</h3><p>这两兄弟是一起工作的。每次跑程序时，<code>Interpreter</code>选取应当执行的<code>.class</code>字节码，然后将其实时翻译成机器码执行。这么做有一个缺点，如果一个方法或者逻辑被多次调用，那么每次调用都要重新翻译一次，效率特别低，实际上翻译出来的机器码可以重复使用。</p><p>在这种情况下，<code>JIT（Just In Time）</code>就派上用场了。执行引擎在<code>Interpreter</code>的帮助下将字节码翻译成机器码，如果发现有重复执行的代码，<code>JIT</code>就开始工作，将这部分频繁调用的代码翻译成机器码，当程序再次调用这个部分的逻辑时，执行引擎会直接使用<code>JIT</code>翻译完成的机器码，这样就能够提升系统的性能表现，这部分代码也叫<code>Hot Code</code>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="hotcode.png" alt="执行流程" title>                </div>                <div class="image-caption">执行流程</div>            </figure><h3 id="1-3-Dalvik"><a href="#1-3-Dalvik" class="headerlink" title="1.3 Dalvik"></a>1.3 Dalvik</h3><p>那么上面说的这些和<code>Android</code>有什么关系呢？</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="back.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p><code>JVM</code>设计运行的硬件环境和<code>Android</code>设备不一样，<code>JVM</code>最初是为电视机顶盒设计的，拥有“无限”电量，而一般来说手机设备有<code>4000mah</code>已经是很大的电池了，另外<code>Android</code>设备存储空间比较小（现在其实挺大的）。因此，<code>Google</code>修改了<code>JVM</code>的整体结构，包括<code>Java</code>代码编译过程和字节码结构，以适应手机设备。编译过程的差异将在下一节讲述，字节码结构则下面用代码实例说明一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> i1, <span class="keyword">int</span> i2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i3 = i1 + i2;</span><br><span class="line">    <span class="keyword">return</span> i3 * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码生成的<code>.class</code>字节码如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="jvmbytecode.png" alt="java bytecode" title>                </div>                <div class="image-caption">java bytecode</div>            </figure><p>使用<code>Android</code>的<code>Dex</code>编译器编译代码生成的<code>.dex</code>字节码如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="dexbytecode.png" alt="Dex bytecode" title>                </div>                <div class="image-caption">Dex bytecode</div>            </figure><p>两张图对比可以明显看出来，<code>.dex</code>字节码会比<code>.class</code>字节码更简洁。</p><p>另外，<code>Java</code>字节码是基于栈结构（所有的变量都存储在栈上）的，而<code>Dex</code>字节码基于寄存器结构（所有变量存储在寄存器中）。</p><p>基于栈结构的字节码，在执行操作时需要先将操作数加载到操作栈上，然后计算，最后再将得到的结果从栈上弹出到局部变量表中。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="stackbase.png" alt="基于栈的计算过程" title>                </div>                <div class="image-caption">基于栈的计算过程</div>            </figure><p>而基于寄存器的字节码可以直接读取寄存器中存储的数据，然后一步到位将结果存入另外的寄存器。<code>Dex</code>这种字节码相对<code>Java</code>字节码而言更高效，需要的空间也更少。</p><p>在<code>Android 5.0</code>以前，Android系统中解析<code>Dex</code>字节码的虚拟机叫做<code>Dalvik</code>。</p><p><code>Dalvik</code>加载和解析执行<code>Dex</code>字节码的方式和<code>JVM</code>使用<code>JIT</code>以及<code>Interpreter</code>一样。</p><h2 id="二、Android-构建过程"><a href="#二、Android-构建过程" class="headerlink" title="二、Android 构建过程"></a>二、Android 构建过程</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="gradleBuild.png" alt="Gralde Build Process" title>                </div>                <div class="image-caption">Gralde Build Process</div>            </figure><p><code>.java</code>和<code>.kt</code>文件由<code>Java/Kotlin</code>编译器编译成<code>.class</code>文件。这些<code>.class</code>文件则通过<code>Dex</code>编译器编译成<code>.dex</code>文件，最终和资源文件等打包成<code>.apk</code>文件。</p><p>可以看到，<code>Android</code>构建其实和<code>Java</code>语言有很大关系。<code>Java</code>语言基本每年更新一个新版本，目前最新的是<code>Java 12</code>。而相对于<code>Java</code>的迅速迭代而言，<code>Android</code>虚拟机则慢了很多，很多语言新特性无法直接在虚拟机上使用。因此，<code>Android</code>构建过程中，除了要将<code>class</code>文件转化成<code>dex</code>文件之外，还有一个重要的任务是将新特性转化成老版本<code>Java</code>能够运行的特性，也就是所谓的“脱糖”。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="desuger.png" alt="脱糖" title>                </div>                <div class="image-caption">脱糖</div>            </figure><h3 id="2-1-Jack-amp-Jill"><a href="#2-1-Jack-amp-Jill" class="headerlink" title="2.1 Jack &amp; Jill"></a>2.1 Jack &amp; Jill</h3><p>为了解决这个问题，<code>Google</code>在16年推出了<code>Jack &amp; Jill</code>这套编译机制。具体流程如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="jack.png" alt="Jack & Jill" title>                </div>                <div class="image-caption">Jack & Jill</div>            </figure><p><code>Google</code>想使用<code>Jack</code>工具直接将<code>Java</code>代码编译成<code>dex</code>文件，至于应用所使用过的第三方库，则使用<code>Jill</code>工具编译成中间文件然后再编译成<code>dex</code>文件。</p><p>这样看起来简单明了，没有那么多中间过程。但实际效果没有预期那么好。<code>Google</code>需要重新实现Java生态所有特性支持，如注解，工作量很大；并且有些第三方库依赖于Java字节码神效；另外，经过实际应用，发现这个工具速度慢，耗内存，且不支持<code>instant run</code>。<code>Google</code>在17年废弃了这个编译工具链。</p><h3 id="2-2-D8"><a href="#2-2-D8" class="headerlink" title="2.2 D8"></a>2.2 D8</h3><p>为了改善构建环境，<code>Google</code>在<code>Android Studio 3.2</code>中使用<code>D8(Dope 8)</code>取代了原来的<code>Dex</code>编译器。这个替换操作主要的目的是将脱糖操作和<code>class2dex</code>操作合并，减少构建时间。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="d8.png" alt="D8构建过程" title>                </div>                <div class="image-caption">D8构建过程</div>            </figure><p>那么<code>D8</code>有多快呢？这得分工程规模来看。小<code>APP</code>的话，<code>100</code>次构建取平均值之后，优化的时间为<code>2s</code>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="d8times.png" alt="D8构建时间对比图" title>                </div>                <div class="image-caption">D8构建时间对比图</div>            </figure><p>官方描述<code>D8</code>的优点有：</p><ul><li>编译更快、时间更短；</li><li>DEX 编译时占用内容更小；</li><li>.dex 文件大小更小；</li><li>D8 编译的 .dex 文件拥有相同或者是更好的运行时性能；</li></ul><p>这还没完，<code>Google</code>还有一个大招。</p><h3 id="2-3-R8"><a href="#2-3-R8" class="headerlink" title="2.3 R8"></a>2.3 R8</h3><p><code>R8</code>是<code>D8</code>的衍生产品，他们使用相同的代码库，但是<code>R8</code>还解决了其他问题。跟<code>D8</code>一样，<code>R8</code>也能将<code>Java</code>新<code>feature</code>提供给开发者使用，但不仅限于此。</p><p><code>R8</code>带来的一个最大改进是优化<code>.dex</code>中的代码，只保留了支持应用所需要的<code>API</code>，删除了没有用上的类和方法。</p><p>另外，<code>R8</code>能够替代<code>Proguard</code>。<code>Proguard</code>是一个在构建过程中使用到的混淆工具，在<code>.class</code>转换<code>.dex</code>过程中，<code>R8</code>会替代<code>Proguard</code>的工作，比如优化、混淆代码，移除无用的类。</p><p>用Java 8的lambda表达式做测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MathLambda</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">NumericTest</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">computeTest</span><span class="params">(<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(NumericTest numericTest)</span> </span>&#123;</span><br><span class="line">        numericTest.computeTest(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">java8ShowCase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MathLambda math = <span class="keyword">new</span> MathLambda();</span><br><span class="line">        math.doSomething((n) -&gt; (n % <span class="number">2</span>) == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>R8</code>能够减少生成的字节码行数。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="dexvsr8.png" alt="Dex vs R8" title>                </div>                <div class="image-caption">Dex vs R8</div>            </figure><p><code>R8</code>在<code>Android Studio 3.4</code>被引入并默认开启，官方宣称能够优化逻辑代码，混淆代码和清除无用的类和方法。</p><p>同一个APP，分别使用Dex+Proguard和R8构建100次，取平均值，结果如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="provsr8.png" alt="Dex-Proguard vs R8" title>                </div>                <div class="image-caption">Dex-Proguard vs R8</div>            </figure><p>如上图，在构建过程中，使用<code>R8</code>减少了<code>13s</code>构建时间，同时减少了<code>112</code>个方法，生成的<code>apk</code>也小了<code>348kb</code>。整体而言，结果很不错。</p><p>举一个<code>R8</code>优化字符串操作的例子，如下代码：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="strcode.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>直接编译成字节码如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="strbefore.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>从字节码可以看到，每次都先计算字符串<code>WILDCARD</code>的长度，然后取子字符串。其实字符串常量<code>WILDCARD</code>长度为固定的，所以没有必要一次次重新计算，编译期计算出来就可以。优化之后的字节码如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="strafter.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>可以看到<code>0008</code>行直接将一个固定值赋给了变量<code>v0</code>，然后在获取子字符串进行之后的操作。</p><h2 id="三、Android运行过程"><a href="#三、Android运行过程" class="headerlink" title="三、Android运行过程"></a>三、Android运行过程</h2><h3 id="3-1-Dalvik虚拟机"><a href="#3-1-Dalvik虚拟机" class="headerlink" title="3.1 Dalvik虚拟机"></a>3.1 Dalvik虚拟机</h3><p>从应用商店下载一个<code>apk</code>文件，安装后，点击图标<code>icon</code>，然后就可以看到<code>APP</code>运行在了手机上。那么中间发生了哪些事情？</p><p><code>APK</code>安装文件一般包含了所有的资源文件（图片，图标和布局等）和代码文件，安装时系统会把这些资源存储到内存中。当用户点击应用图标时，手机会启动一个<code>Dalvik</code>进程，然后将该<code>app</code>的<code>dex</code>文件加载到内存，同时<code>Dalvik</code>虚拟机将会把<code>dex</code>字节码通过<code>Interpreter</code>或<code>JIT</code>翻译成机器码，最终这款<code>app</code>运行在了你手机上。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="running.png" alt="APP 运行过程" title>                </div>                <div class="image-caption">APP 运行过程</div>            </figure><p>当应用要使用到某部分代码（字节码）时，<code>Dalvik</code>会通过<code>Interpreter</code>将字节码实时翻译成机器码运行，经过一段时间后，如果有部分代码被经常调用（比如刷抖音时调用的请求视频数据逻辑），那么这部分代码会被定义成<code>hotcode</code>，随后被<code>JIT</code>翻译成机器码存储在内存中。当这部分代码再次被调用时，就不需要实时翻译，直接使用翻译好的机器码即可，这样就提高了运行效率。</p><p>这个过程和餐厅接待客人的一些现象很相似。<code>Interpreter</code>就是客人来了之后现场点现场做，<code>JIT</code>则是根据之前的经验，将这个客人常点的菜提前先做好，这样就能提高上菜速度。</p><p><code>JIT</code>机制是<code>Android 2.2</code>引入的，之前全靠<code>Interpreter</code>实时翻译，可想而知之前卡顿有多严重。</p><h3 id="3-2-ART"><a href="#3-2-ART" class="headerlink" title="3.2 ART"></a>3.2 ART</h3><p><code>Dalvik</code>对于手机设备来说是一个很好的解决方案，但是它。因此<code>Google</code>对<code>JVM</code>进行了改进，推出了一种新的<code>JVM</code>，称为<code>ART</code>虚拟机。<code>Dalvik</code>和<code>ART</code>最大的区别在于<code>ART</code>不会在运行时对字节码进行翻译执行，而是把这个过程提前到了安装过程中。<code>ART</code>使用<code>AOT（Ahead of Time）</code>编译器来将字节码翻译成<code>.oat</code>文件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="oat.png" alt="AOT 运行过程" title>                </div>                <div class="image-caption">AOT 运行过程</div>            </figure><p><code>APP</code>被安装时，<code>ART</code>将<code>Dex</code>字节码预编译成<code>.oat</code>文件，每次启动<code>APP</code>时系统直接读取<code>.oat</code>文件运行即可，不再使用<code>JIT</code>以及<code>Interpreter</code>这种即时翻译的工具，大大提升了运行流畅度。</p><p>这样看起来好像<code>AOT</code>好像没什么毛病，<code>Google</code>当初也觉得自己找到了终极解决方式，但实际上<code>AOT</code>还是会有一些问题：</p><ul><li><code>AOT</code>在安装过程中进行预编译行为，这样安装和更新<code>APP</code>时间相比原来就会大大增加。另外，升级<code>Android</code>系统时，系统会把所有程序重新安装一次，想想那么多<code>APP</code>要重新安装编译成<code>.oat</code>文件，头都大了。</li><li>空间大小。<code>AOT</code>将整个<code>.dex</code>文件都翻译为<code>.oat</code>文件，包括那种很少使用或者根本不会被使用到的代码（比如第一次打开<code>APP</code>的设置向导或者开屏界面）。根据<code>Google</code>相关的数据，常用的代码大概占所有代码的<code>15~20%</code>左右，这样就浪费了很大一部分空间，在一些小存储容量的低端机上这个问题尤其明显。</li></ul><p>既然这也不好，那也不好，那就集中两种方式的优点就好了。<code>Google</code>工程师想出了一个新点子：<code>Interpreter + JIT + AOT</code>混合编译，具体方案如下：</p><ol><li>安装的时候不进行预编译，也即不生成<code>.oat</code>文件。<code>app</code>第一次启动时，<code>ART</code>使用<code>Interpreter</code>来实时翻译<code>.dex</code>文件。</li><li>当出现<code>Hot Code</code>时，使用<code>JIT</code>进行翻译，并将翻译后的机器码存入缓存（内存）中，之后调用<code>Hot Code</code>时直接从缓存中取。</li><li>当设备空闲时，比如锁屏，<code>Hot Code</code>会被<code>AOT</code>编译器编译成<code>oat</code>文件存入本地存储空间。</li><li><code>app</code>再次启动时，如果存在<code>.oat</code>文件，那么直接使用<code>.oat</code>文件，否则从步骤1开始。</li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="oatRun.png" alt="AOT 运行过程" title>                </div>                <div class="image-caption">AOT 运行过程</div>            </figure><p>国内的厂商会有“基于用户操作习惯进行学习，APP打开速度不断提高<br>”的说法，有一部分是这个混合编译方案的功劳。</p><p>根据官方数据，平均来看，app运行8次之后，这个机制能够优化80%的空间。</p><p>这个混合机制为<code>Android N(5.0)</code>引入的，也正是这个时候开始用户对<code>Android</code>的运行效率看法有了改观。</p><h3 id="3-3-PGO"><a href="#3-3-PGO" class="headerlink" title="3.3 PGO"></a>3.3 PGO</h3><p>经过上面这些动作，<code>Android</code>的运行速度其实已经有很大的改观。但还是有可以改进的地方。</p><p>在说<code>AOT</code>混合编译的时候系统会生成一个<code>profile</code>，这个<code>profile</code>记录了<code>hotcode</code>的信息，哪些类和哪些方法会被经常调用。而对于大多数人来说，同一个<code>APP</code>的<code>hotcode</code>区别不大，其实可以共用，因此<code>Google</code>在<code>2018 Google I/O</code>大会上提出了<code>Cloud Profiles</code>的方案。具体原理如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="share.png" alt="共享" title>                </div>                <div class="image-caption">共享</div>            </figure><p>这个方案依赖<code>Google Play</code>来完成。当一个设备为空闲状态并且连接到<code>WiFi</code>时，<code>Google Play Service</code>会将编译后的文件共享，之后如果有一样的手机从<code>Googole Play</code>中下载这个<code>APP</code>时，终端会收到其他人的<code>hotcode</code>信息，这样用户在第一次使用时就能获得良好的体验。</p><p>但实际上，一个人的<code>hotcode</code>无法代表所有人的<code>hotcode</code>信息，那么需要多少个样本才能拿到一个比较稳定的<code>hotcode profile</code>呢？根据官方的数据，这个数字还挺小的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="numbers.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>平均而言，<code>30</code>个<code>profile</code>已经能达到一个比较稳定的水平，而且效果也不差。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="time.png" alt="启动时间" title>                </div>                <div class="image-caption">启动时间</div>            </figure><p>然而这些方案对于国内来说都没什么用…因为没法使用<code>Google Play</code>。但<code>Android 9</code>开始，<code>Google</code>提供了一个内置<code>hotcode</code>的方案，也就是说，可以在构建期间往<code>APP</code>中放置<code>hotcode</code>信息，这样系统在安装<code>APP</code>时直接将这部分代码编译成机器码，速度会有很大的提升。</p><p>不过这部分内容在国内资料很少，<code>Google</code>搜索了之后也才发现官方给了这一篇文章，<a href="https://source.android.google.cn/devices/tech/perf/pgo#using-pgo" target="_blank" rel="noopener">Build With PGO</a>，有兴趣的可以自己继续了解一下。</p><h3 id="3-4-鸿蒙系统-amp-方舟编译器"><a href="#3-4-鸿蒙系统-amp-方舟编译器" class="headerlink" title="3.4 鸿蒙系统 &amp; 方舟编译器"></a>3.4 鸿蒙系统 &amp; 方舟编译器</h3><p>说到了编译器和<code>Android</code>的运行机制，不得不说一下最近大热的华为鸿蒙系统和方舟编译器。这里先放一张官网给的架构图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="har.png" alt title>                </div>                <div class="image-caption"></div>            </figure><p>在网上搜集了一些信息之后，不得不说华为的愿景很大。想把<code>Java/Kotlin、C++</code>直接编译成能够运行的机器码，据了解的信息，普通的<code>APP</code>经过华为的编译器之后，包体积会增大一些。另外，对于语言的动态特性，比如<code>Java</code>的多态，直接在编译期处理成静态特性。这些都是华为官方宣称的优点，不知道华为具体是怎么做的，拭目以待吧。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><ul><li><a href="https://proandroiddev.com/android-cpu-compilers-d8-r8-a3aa2bfbc109" target="_blank" rel="noopener">https://proandroiddev.com/android-cpu-compilers-d8-r8-a3aa2bfbc109</a></li><li><a href="https://source.android.google.cn/devices/tech/perf/pgo#case-study-pgo-for-art" target="_blank" rel="noopener">https://source.android.google.cn/devices/tech/perf/pgo#case-study-pgo-for-art</a></li><li><a href="https://juejin.im/post/5ca480b66fb9a05e1d26bb7a" target="_blank" rel="noopener">https://juejin.im/post/5ca480b66fb9a05e1d26bb7a</a></li><li><a href="https://www.infoq.com/news/2019/04/play-cloud-art-profiling-android/" target="_blank" rel="noopener">https://www.infoq.com/news/2019/04/play-cloud-art-profiling-android/</a></li><li><a href="https://juejin.im/post/5d4bdb23e51d453c2577b747" target="_blank" rel="noopener">https://juejin.im/post/5d4bdb23e51d453c2577b747</a></li><li><a href="https://zhuanlan.zhihu.com/p/62794593" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/62794593</a></li><li><a href="https://juejin.im/post/5cbe60796fb9a0324d43ab97#heading-5" target="_blank" rel="noopener">https://juejin.im/post/5cbe60796fb9a0324d43ab97#heading-5</a></li><li><a href="https://blog.csdn.net/Mr_dsw/article/details/90141647" target="_blank" rel="noopener">https://blog.csdn.net/Mr_dsw/article/details/90141647</a></li><li><a href="https://zhuanlan.zhihu.com/p/65307730" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/65307730</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近阅读了一下&lt;code&gt;Android&lt;/code&gt;编译和运行相关的文章，大概了解了整体运行过程，在这里总结一下。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="https://KingsFish.github.io/categories/Android/"/>
    
    
      <category term="虚拟机" scheme="https://KingsFish.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
      <category term="编译" scheme="https://KingsFish.github.io/tags/%E7%BC%96%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>我的微信公众号开通了~</title>
    <link href="https://KingsFish.github.io/2019/09/21/%E8%91%AB%E8%8A%A6%E7%B1%BD%E7%9A%84%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>https://KingsFish.github.io/2019/09/21/葫芦籽的碎碎念/</id>
    <published>2019-09-21T14:56:40.000Z</published>
    <updated>2019-09-22T14:59:50.401Z</updated>
    
    <content type="html"><![CDATA[<p>犹豫了很久，终于还是开通了微信公众号，名为「葫芦籽的碎碎念」，前几天刚刚开通的，准备长期运营。</p><h3 id="为什么要开通这个微信公众号"><a href="#为什么要开通这个微信公众号" class="headerlink" title="为什么要开通这个微信公众号"></a>为什么要开通这个微信公众号</h3><p>开通微信公众号所考虑的因素比较多：</p><ul><li>目前博客所有的文件保存在本地以及<code>Github</code>仓库中，有无法访问和数据丢失的风险。</li><li>博客评论系统比较麻烦，目前用过<code>Disqus</code>，<code>Gitment</code>，<code>valine</code>。<code>Disqus</code><del>由于不可抗力因素</del>国内无法访问；<code>Gitment</code>太乱，依托于<code>Github</code>的<code>issue</code>系统，并且需要登录<code>Github</code>；<code>valine</code>用了一段时间，感觉还不错，评论不需要注册账号，也不需要后端，不过<code>valine</code>依托于<code>LeanCloud</code>作为后端存储系统，而最近<code>LeanCloud</code>需要实名注册备案，不想把自己的隐私信息交出去。</li><li>使用博客的话，目前只提供了一个邮箱联系方式，与粉丝的连接性较差。使用公众号则可以随时与粉丝联系（<del>其实博客并没有多少粉丝T_T</del>）。</li></ul><h3 id="博客和公众号的共存性"><a href="#博客和公众号的共存性" class="headerlink" title="博客和公众号的共存性"></a>博客和公众号的共存性</h3><p>目前精力主要放在微信公众号中，但是会将微信公众号的部分内容（目前计划是技术相关，后期看精力会再增加）同步到博客。微信公众号会多一些其他内容，如自己除了技术其他方面的学习，读书笔记等等。</p><p>最近刚入职，精力主要放在了熟悉业务相关内容上，因此更新频率下降了很多，最近一次更新已经是2个多月之前了。另外，自己的学习计划也有很多没有时间完成，之后会慢慢把这些都捡起来。</p><p>最后，附上我的微信公众号，欢迎各位读者关注</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="wechat.jpg" alt="葫芦籽的碎碎念" title>                </div>                <div class="image-caption">葫芦籽的碎碎念</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;犹豫了很久，终于还是开通了微信公众号，名为「葫芦籽的碎碎念」，前几天刚刚开通的，准备长期运营。&lt;/p&gt;
&lt;h3 id=&quot;为什么要开通这个微信公众号&quot;&gt;&lt;a href=&quot;#为什么要开通这个微信公众号&quot; class=&quot;headerlink&quot; title=&quot;为什么要开通这个微信公
      
    
    </summary>
    
      <category term="生活琐事" scheme="https://KingsFish.github.io/categories/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>2019上半年复盘</title>
    <link href="https://KingsFish.github.io/2019/07/11/2019%E4%B8%8A%E5%8D%8A%E5%B9%B4%E5%A4%8D%E7%9B%98/"/>
    <id>https://KingsFish.github.io/2019/07/11/2019上半年复盘/</id>
    <published>2019-07-11T15:44:42.000Z</published>
    <updated>2019-07-11T15:03:51.130Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉<code>2019</code>过去了一半，学生生涯的最后一个学期。</p><center>一</center><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="640.webp" alt title>                </div>                <div class="image-caption"></div>            </figure><p>上半年的首要任务是毕业，写论文之前最好写一篇专利，这样的话被抽中盲审几率较小。</p><p>写专利是件简单的事情，然而在学校专利办老师的加持下，变成了一件非常痛苦的事情。大家能不在学校专利办改，就不在那改。原因无他，专利办老师态度实在太差，去过的人都不想再去第二次。</p><p>跌跌撞撞把专利改完，开始着手论文的事情。从构思到完工大概花了一个月的时间，<code>DeadLine</code>果然是第一生产力。其实也不想自己能写得有多好，毕竟时间摆在那里，只要能顺利毕业就行。</p><p>托专利的福，最终盲审没有抽中，明审也安心通过。答辩的时候也比较顺利，听到答辩委员会说恭喜你们获得硕士学位的时候，心里石头落下了地。</p><center>二</center><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="640.webp" alt title>                </div>                <div class="image-caption"></div>            </figure><p>一月份的时候逛星球，无意中发现有人推荐了一下蜗牛读书，说是体验还不错，几千万的用户量。但是我从来都没有听过，于是下载体验了一下。结果一发不可收拾。</p><p>蜗牛的阅读体验很不错。读书是免费时长制，每天可以免费阅读1小时，看广告的话是2小时。虽然看起来时间比较短，但实际上已经基本能够满足需求。阅读时间会换算成蜗牛读书的内部货币——蜗牛壳。蜗牛壳可以用来换书，换过的书不消耗阅读时长。另外，可以约人共读书籍，这样的话能一起交流，同时蜗牛壳翻倍。</p><p>总的来说，感觉没有<code>kindle</code>的情况下，蜗牛读书是个不错的替代品。上半年在这上面阅读了不少书籍。目前在蜗牛上已经阅读了10多本书，总字数约300W+，也算是个不错的成果。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="djdh.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><center>三</center><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="640.webp" alt title>                </div>                <div class="image-caption"></div>            </figure><p>学生生涯的最后半年，毕业之前，终于把父母来西安的计划实现了。趁着学士服发到了手里，把他们两叫来了西安，也算是了了老妈的心愿。毕竟这么多年了，她还没有出去旅游过。</p><p>来的那几天带他们去逛了逛陕西历史博物馆，看了兵马俑，在兵马俑那里还给老妈买了一个玉手镯。据讲解员说，那家卖玉手镯的商店是国营商店，所以质量方面不用担心。其实不管真和假，给老妈一个心理寄托。玉的功效这种东西，信则有，不信则无。</p><p>除此之外，终于在工作之前去了婷婷家，完成了这件必须完成的事情，顺便当作出去旅游了一次。东北的景色果然跟西安和家里不大一样，看不到边的平原。只可惜五一时间太紧，没有多待几天，只是在路过哈尔滨的时候逛了一下中央大街，拍了一张到此一游的照片。</p><p>以后怕是没有这么长的时间可以用来旅游了。</p><center>四</center><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="640.webp" alt title>                </div>                <div class="image-caption"></div>            </figure><p>因为租房子要用到公司的自如服务费折扣，所以提前确定了公司的入职时间。第一次租房子，直接在自如上租的，好像没有被社会敲打。婷婷说房子地理位置还不错，附近的配套设施还挺齐全的。离公司近，旁边有个城中村，买菜买水果都很方便。</p><p>最终赶在6月末入职，成为了一名社畜。Leader和mentor人都不错，挺好沟通的，同事也很nice。大概大家都是程序员，相处起来比较容易。总的来说，入职这两周体验还不错。</p><p>新的环境，新的人，自己依旧要加油~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不知不觉&lt;code&gt;2019&lt;/code&gt;过去了一半，学生生涯的最后一个学期。&lt;/p&gt;
&lt;center&gt;一&lt;/center&gt;
&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
 
      
    
    </summary>
    
      <category term="复盘" scheme="https://KingsFish.github.io/categories/%E5%A4%8D%E7%9B%98/"/>
    
    
      <category term="总结" scheme="https://KingsFish.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="2019" scheme="https://KingsFish.github.io/tags/2019/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 507 Perfect Number</title>
    <link href="https://KingsFish.github.io/2019/07/11/Leetcode-507-Perfect-Number/"/>
    <id>https://KingsFish.github.io/2019/07/11/Leetcode-507-Perfect-Number/</id>
    <published>2019-07-11T15:44:35.000Z</published>
    <updated>2019-07-11T15:55:13.523Z</updated>
    
    <content type="html"><![CDATA[<p>晚上赶在睡觉之前<code>AC</code>的，好久没有刷过题目了。题目描述如下：</p><blockquote><p>We define the Perfect Number is a positive integer that is equal to the sum of all its positive divisors except itself.<br>Now, given an integer n, write a function that returns true when it is a perfect number and false when it is not.<br>Example:<br>Input: 28<br>Output: True<br>Explanation: 28 = 1 + 2 + 4 + 7 + 14</p></blockquote><p>题目大意是，给定一个数字，判断该数字是否是完美数字，完美数字的定义是，该数字等于所有约数的和。</p><p>题目不是很难，可以直接暴力搜索，遍历找到该数字的约数，求和再比较即可。但是如果直接暴力搜索，我推测一般会超时。所以最好进行一定的优化。</p><p>假定给定数字为<code>num</code>，遍历的数字为<code>i</code>。明显可知，<code>[num / i, num]</code>这个范围内的数字不可能是<code>num</code>的约数了，因此，每次<code>i</code>增加时，可以同时更新中止条件，这样能省下来很大一部分时间，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkPerfectNumber</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1为特例，需要额外处理</span></span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">1</span>, i = <span class="number">2</span>, j = num;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j) &#123;</span><br><span class="line">            <span class="comment">// 更新j</span></span><br><span class="line">            j = num / i;</span><br><span class="line">            <span class="keyword">if</span> (num % i == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// i是num的公约数，那么j也是公约数</span></span><br><span class="line">                sum += i;</span><br><span class="line">                sum += j;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num == sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终提交结果<code>AC</code>，超过了<code>96.47%</code>的提交，但是占用内存较多，不知道是什么原因（也不知道内存占用这项数据什么时候上线的）。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="res.png" alt title>                </div>                <div class="image-caption"></div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;晚上赶在睡觉之前&lt;code&gt;AC&lt;/code&gt;的，好久没有刷过题目了。题目描述如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We define the Perfect Number is a positive integer that is equal to the su
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://KingsFish.github.io/categories/Leetcode/"/>
    
    
      <category term="Brute Force" scheme="https://KingsFish.github.io/tags/Brute-Force/"/>
    
  </entry>
  
  <entry>
    <title>Android中的框架模式：MVC&amp;MVP&amp;MVVM</title>
    <link href="https://KingsFish.github.io/2019/05/13/Android%E4%B8%AD%E7%9A%84%E6%A1%86%E6%9E%B6%E6%A8%A1%E5%BC%8F%EF%BC%9AMVC-MVP-MVVM/"/>
    <id>https://KingsFish.github.io/2019/05/13/Android中的框架模式：MVC-MVP-MVVM/</id>
    <published>2019-05-13T14:48:03.000Z</published>
    <updated>2019-06-14T14:54:54.854Z</updated>
    
    <content type="html"><![CDATA[<p>最近在实验室内部做了一次分享，主要内容是<code>Android</code>开发中常使用的三种软件框架模式，<code>MVC</code>、<code>MVP</code>和<code>MVVM</code>，另外写了一个小<code>Demo</code>来演示这几种模式的实际写法，在此一并发到博客上。</p><p>要声明的是，对于软件框架模式，每个人有自己的理解，另外模式也有多种变形，可能会与本文中的不完全一致，因此本文阐述的是我自己对这几个模式的理解。</p><h2 id="软件框架模式"><a href="#软件框架模式" class="headerlink" title="软件框架模式"></a>软件框架模式</h2><h3 id="什么是软件框架模式"><a href="#什么是软件框架模式" class="headerlink" title="什么是软件框架模式"></a>什么是软件框架模式</h3><blockquote><p>软件框架模式是软件架构的设计理念，一个通用的、可重用的解决方案，用于解决在给定上下文中的软件体系结构问题</p></blockquote><p>软件框架模式即为软件的结构设计，对于一个特定场景下的问题，如何组织和编写软件解决这个问题。就像人类要组织一场活动，如何安排场地和人员以完成活动就是活动的结构设计。</p><p>良好的软件框架模式意味着优秀的软件架构，一般具有以下几个优点：</p><ul><li>框架中各部分模块关系清晰，职责和功能划分明确，功能模块易于复用，降低开发难度</li><li>每个模块和其他模块之间关联度低，便于单元测试</li><li>耦合度低，程序灵活，应对新变化如新增需求或者修改需求时便于软件维护</li></ul><p>很多人会把软件框架模式和软件设计模式混淆，个人认为，这两者都是软件从业人员经验的总结。但相对而言，软件设计模式更像是编程过程中局部使用的编程技巧，而框架模式则负责整个软件框架，处于全局的视角位置。</p><h3 id="常见的软件框架模式"><a href="#常见的软件框架模式" class="headerlink" title="常见的软件框架模式"></a>常见的软件框架模式</h3><h4 id="分层模式"><a href="#分层模式" class="headerlink" title="分层模式"></a>分层模式</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1.png" alt="分层模式示意图" title>                </div>                <div class="image-caption">分层模式示意图</div>            </figure><p>「分层模式」是最常见的软件框架模式，很多组织架构和这种模式十分相似。该模式将软件分成若干个水平层，每一层都有特定的角色和职能，代表着应用的某一些功能，不需要知道其他层的细节，层与层之间通过接口通信，OSI的七层和TCP/IP的5层协议都应用了这种模式。</p><h4 id="事件总线模式"><a href="#事件总线模式" class="headerlink" title="事件总线模式"></a>事件总线模式</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2.png" alt="事件总线模式示意图" title>                </div>                <div class="image-caption">事件总线模式示意图</div>            </figure><p>「事件总线模式」主要用于处理事件，包括4个主要组件：事件源、事件监听器、通道和事件总线。对于不同事件源，产生的事件不同，这些事件都会发布到事件总线上的特定通道上。事件监听器器订阅特定的通道，每当有新事件发生时，订阅了该事件的监听器就可以通过订阅的通道得知该事件，从而做一定处理，每个监听器也可以对多个不同的事件进行监听。事件总线模式和设计模式里的发布订阅模式有一定相似之处。</p><h4 id="微核架构"><a href="#微核架构" class="headerlink" title="微核架构"></a>微核架构</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="3.jpg" alt="微核架构示意图" title>                </div>                <div class="image-caption">微核架构示意图</div>            </figure><p>「微核架构」也称为插件化应用模式，由薄核心和多个功能插件组成。这种模式可以通过插件的形式添加额外的特性到核心系统中，提供了很好的扩展性，也使得新特性与核心系统隔离开。</p><p>一般来说，核心提供了特定场景下的通用业务逻辑流程，而插件模块则根据这些规则实现具体的业务逻辑，一个例子是<code>FreeSwitch</code>。<code>FreeSwitch</code>是一个软电话交换系统，提供了软电话的通用逻辑，如话机两端先进行信令的沟通然后通过这个流程，详细的信令协议则由各插件实现，如SIP协议，H323协议等等，还有语音编解码的具体过程，都是由各语音编码插件完成，FreeSwitch只是提供了整体处理流程。</p><h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>「微服务架构」提倡将大而全的应用功能拆分成以服务组件为单位的小模块，每个服务组件的服务能力粒度有大有小，小到一个单一的字符串提取，大到一个完整的计费系统。<code>5G</code>目前使用的就是微服务架构，将运营商的多种功能拆分成小功能单元，每一个新的应用都可以调用不同能力的服务组件以实现自身的功能。通信也在往互联网软件的方向发展。</p><h4 id="模型-视图-控制器模式"><a href="#模型-视图-控制器模式" class="headerlink" title="模型-视图-控制器模式"></a>模型-视图-控制器模式</h4><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="4.png" alt="MVC模式示意图" title>                </div>                <div class="image-caption">MVC模式示意图</div>            </figure><p>「模型-视图-控制器模式」也即「<code>MVC</code>模式」。这个模式多用于<code>GUI</code>程序的开发，如前端、<code>iOS</code>和<code>Android</code>。<code>MVC</code>模式将软件分成三个层级，模型（Model）、视图（View）和控制层（Controller）。模型包含核心功能和数据，视图展示信息，控制器处理用户输入。这个模式也是本篇文章的主要内容。</p><h2 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h2><h3 id="MVC模式介绍"><a href="#MVC模式介绍" class="headerlink" title="MVC模式介绍"></a>MVC模式介绍</h3><p><code>MVC</code>模式主要分为三个部分，<code>Model</code>、<code>View</code>和<code>Controller</code>。</p><ul><li>模型持有所有的数据、状态和程序逻辑，一个模型可以有不同的多个视图表现形式，复用性高。</li><li>视图是用户看到并与之交互的页面，通常直接从模型中取得它需要显示的状态与数据，一个视图往往有一个相应的控制器，理论上也可以同不同的模型相关联</li><li>控制器位于视图和模型中间，负责接受用户的输入，将输入进行解析并反馈给模型</li></ul><p>下图是<code>MVC</code>模式的一个流程示例。<code>View</code>层有用户点击，<code>Controller</code>层接收到点击事件，做简单处理之后向<code>Model</code>层发送请求，<code>Model</code>层中主要的程序逻辑对接收到的数据进行计算等操作，得到结果后再通知<code>View</code>层进行视图更新。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="5.png" alt="MVC流程" title>                </div>                <div class="image-caption">MVC流程</div>            </figure><p>以一个计算器为例，如果要用<code>MVC</code>模式设计软件，则<code>View</code>层负责设计和绘制界面上的数字和运算符号按钮，<code>Controller</code>层响应点击事件，处理视图层传递的数据，并将数据传递给<code>Model</code>层，<code>Model</code>层通过控制层得到输入的数字和运算符，并对数据进行计算，最终将计算结果传递给<code>View</code>层进行视图更新。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="6.jpg" alt="计算器" title>                </div>                <div class="image-caption">计算器</div>            </figure><p>当用户点击<code>7</code> <code>*</code> <code>9</code>这三个按钮时，<code>Controller</code>层接收到这三个按钮的点击事件，然后将这三个按钮对应的数字和运算符传递给<code>Model</code>层进行计算，<code>Model</code>层计算得到最终结果为<code>63</code>，随之将<code>63</code>这个数字传递给<code>View</code>层进行展示。</p><p>这就是<code>MVC</code>模式在计算器这个软件中的应用。这样分离之后，整个软件耦合度大大降低，软件修改和功能复用方便了很多。如果对计算器界面不满意，那么只需要修改<code>View</code>重新设计界面；如果想在其他平台如<code>Android</code>平台复用，<code>Model</code>包含了主要的程序逻辑，直接将<code>Model</code>层复用即可，<code>Android</code>端只需要重写<code>View</code>层和<code>Controller</code>层即可，整个软件灵活性大大增强。</p><h3 id="在Android开发中的应用"><a href="#在Android开发中的应用" class="headerlink" title="在Android开发中的应用"></a>在Android开发中的应用</h3><p><code>Android</code>开发其实天生就是<code>MVC</code>模式，如下图所示：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="7.png" alt="Android开发对应各层" title>                </div>                <div class="image-caption">Android开发对应各层</div>            </figure><p>其中，<code>XML</code>层作为<code>View</code>层，定义视图的层级；<code>Activity</code>作为<code>Controller</code>层，接收视图的点击等效果，然后将数据请求等发送给<code>Model</code>层；<code>Model</code>层负责从网络或者数据库中获取数据。以实现下图的效果为例，界面上有一个按钮，点击按钮显示一条<code>Toast</code>，具体显示的消息从远端获取。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="8.jpg" alt="示意图" title>                </div>                <div class="image-caption">示意图</div>            </figure><p>整个流程过程如下图所示，<code>View</code>层控制页面布局，<code>Controller</code>层收到点击事件，处理之后向<code>Model</code>层获取数据，<code>Model</code>层获取数据，获取成功通知<code>View</code>层更新视图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="10.jpg" alt="流程图" title>                </div>                <div class="image-caption">流程图</div>            </figure><p>具体实现中，涉及到通知方式的问题，<code>Android</code>中有很多方法可以解决这个问题，这里使用接口回调。</p><p>首先定义回调接口<code>StringCallback</code>，里面有一个回调方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="11.jpg" alt="回调接口代码" title>                </div>                <div class="image-caption">回调接口代码</div>            </figure><p><code>XML</code>定义按钮等页面布局。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="9.jpg" alt="XML布局代码" title>                </div>                <div class="image-caption">XML布局代码</div>            </figure><p><code>Activity</code>实现了回调接口<code>StringCallbcak</code>，显示<code>Toast</code>消息，同时监听按钮的点击事件，当按钮被点击的时候，向<code>Model</code>层获取数据，同时将回调对象传入。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="12.jpg" alt="Activity布局代码" title>                </div>                <div class="image-caption">Activity布局代码</div>            </figure><p><code>Model</code>层向远端获取数据，这里为了方便起见，直接使用固定的字符串。数据获取获取成功后，通知<code>View</code>层更新视图，使用传入的回调对象进行操作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="13.jpg" alt="Model层代码" title>                </div>                <div class="image-caption">Model层代码</div>            </figure><p><code>MVC</code>模式在<code>Android</code>中实现大概就是这个框架。不过实现中存在一个问题，<code>Model</code>层实际应该向<code>View</code>通知更新视图，但在这里，通知的接受者实际上是<code>Activity</code>，也就是<code>Controller</code>。这么做的原因在于，<code>XML</code>对视图的控制能力是在太弱，只能写一些静态的视图布局，动态的添加和修改等操作还得<code>Activity</code>完成。因此，这里的框架更像是下图所展示的模式：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="14.png" alt="实际的模式" title>                </div>                <div class="image-caption">实际的模式</div>            </figure><p>这样的话，业务逻辑都放到了<code>Model</code>层，<code>Model</code>层已经解耦，但是<code>Controller</code>层承包了<code>View</code>层的很多工作，耦合性依然存在。因此，出现了<code>MVC</code>模式的演化版本，<code>MVP</code>模式。</p><h2 id="MVP模式"><a href="#MVP模式" class="headerlink" title="MVP模式"></a>MVP模式</h2><h3 id="MVP模式介绍"><a href="#MVP模式介绍" class="headerlink" title="MVP模式介绍"></a>MVP模式介绍</h3><p>与<code>MVC</code>类似，<code>MVP</code>模式也主要分为三个部分，<code>Model</code>、<code>View</code>和<code>Presenter</code>。</p><ul><li>模型持有所有的数据、状态和程序逻辑，一个模型可以有不同的多个视图表现形式，复用性高。</li><li>视图是用户看到并与之交互的页面，一个视图往往有一个相应的表示层，理论上也可以同不同的模型相关联</li><li>表示层位于视图和模型中间，负责接受用户的输入，将输入进行解析并反馈给模型</li></ul><p>下图是<code>MVC</code>模式的一个流程示例。<code>View</code>层有用户点击，<code>Presenter</code>层接收到点击事件，做简单处理之后向<code>Model</code>层发送请求，<code>Model</code>层中主要的程序逻辑对接收到的数据进行计算等操作，得到结果后再通知<code>Presenter</code>层，随后<code>Presenter</code>再通知<code>View</code>层进行视图更新。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="15.png" alt="MVP模式" title>                </div>                <div class="image-caption">MVP模式</div>            </figure><p>以一个计算器为例，如果要用<code>MVP</code>模式设计软件，则<code>View</code>层负责设计和绘制界面上的数字和运算符号按钮，<code>Presenter</code>层响应点击事件，处理视图层传递的数据，并将数据传递给<code>Model</code>层，<code>Model</code>层通过控制层得到输入的数字和运算符，并对数据进行计算，最终将计算结果传递给<code>Presenter</code>层，<code>Presenter</code>层接收到数据后，再通知<code>View</code>层进行视图更新。在某种意义上来说，<code>MVP</code>和代理模式有些类似。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="6.jpg" alt="计算器" title>                </div>                <div class="image-caption">计算器</div>            </figure><p>当用户点击<code>7</code> <code>*</code> <code>9</code>这三个按钮时，<code>Presenter</code>层接收到这三个按钮的点击事件，然后将这三个按钮对应的数字和运算符传递给<code>Model</code>层进行计算，<code>Model</code>层计算得到最终结果为<code>63</code>，随之将<code>63</code>这个数字传递给<code>Presenter</code>层，<code>Presenter</code>层接收到结果，通知<code>View</code>层进行展示。</p><p>这就是<code>MVP</code>模式在计算器这个软件中的应用，这个模式和<code>MVC</code>模式最大的区别在于，<code>Model</code>层和<code>View</code>层不能直接通信，传递数据等操作都需要<code>Presenter</code>层介入才能完成。</p><h3 id="在Android开发中的应用-1"><a href="#在Android开发中的应用-1" class="headerlink" title="在Android开发中的应用"></a>在Android开发中的应用</h3><p>以实现和<code>MVC</code>模式中相同的界面布局为例，界面上有一个按钮，点击按钮显示一条<code>Toast</code>，具体显示的消息从远端获取。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="8.jpg" alt="示意图" title>                </div>                <div class="image-caption">示意图</div>            </figure><p>整个流程过程如下图所示，<code>View</code>层控制页面布局，<code>Controller</code>层收到点击事件，处理之后向<code>Model</code>层获取数据，<code>Model</code>层获取数据，获取成功通知<code>View</code>层更新视图。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="16.jpg" alt="流程图" title>                </div>                <div class="image-caption">流程图</div>            </figure><p>具体实现中，涉及到通知方式的问题，<code>Android</code>中有很多方法可以解决这个问题，这里使用接口回调。在<code>MVP</code>模式的实现中，一共有两次回调用以通知，分别是<code>Model</code>层通知<code>Presenter</code>层和<code>Presenter</code>层通知<code>View</code>层。因此，一共需要定义两个回调接口，分别由<code>Presenter</code>层和<code>View</code>层来实现。</p><p>首先定义两个回调接口，里面有两个方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="18.jpg" alt="View层接口](17.jpg) ![Presenter层接口" title>                </div>                <div class="image-caption">View层接口](17.jpg) ![Presenter层接口</div>            </figure><p><code>XML</code>部分代码与<code>MVC</code>中一致，在这个实现中，<code>Activity</code>和<code>XML</code>共称为<code>View</code>层，<code>XML</code>负责静态，<code>Activity</code>负责动态，同时需要实现<code>View</code>层接口，并在接收到按钮点击事件时调用<code>Presenter</code>层的功能。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="19.jpg" alt="Activity代码" title>                </div>                <div class="image-caption">Activity代码</div>            </figure><p><code>Presenter</code>层实现了一个通过<code>Model</code>层获取数据的方法，同时需要实现<code>Presenter</code>层接口，供<code>Model</code>层回调。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="20.jpg" alt="Presenter代码" title>                </div>                <div class="image-caption">Presenter代码</div>            </figure><p><code>Model</code>层向远端获取数据，这里为了方便起见，直接使用固定的字符串。数据获取获取成功后，通知<code>Presenter</code>层更新数据，使用传入的回调对象进行操作。<code>Presenter</code>层接收到通知后，也通过传入的<code>View</code>层回调对象进行操作。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="21.jpg" alt="Model层代码" title>                </div>                <div class="image-caption">Model层代码</div>            </figure><p>示例所实现的功能太少，所以现在看来代码略显繁琐，但是代码层次分明，便于扩展。</p><p>其实，无论是<code>MVC</code>还是<code>MVP</code>模式，都有一个很重要的功能实现是将新的数据（<code>Presenter</code>或<code>Controller</code>层）更新到视图（<code>View</code>层）上。如果有框架能够自动完成这个工作，那么能节省很大一部分工作，开发者可以专注于数据更新和逻辑处理。因此，出现了<code>MVVM</code>模式。</p><h2 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h2><h3 id="MVVM模式介绍"><a href="#MVVM模式介绍" class="headerlink" title="MVVM模式介绍"></a>MVVM模式介绍</h3><p><code>MVVM</code>模式则是将<code>MVP</code>模式中的<code>Presenter</code>改成了<code>ViewModel</code>层，负责的功能类似，区别在于与<code>View</code>层的双向绑定。</p><p>下图是<code>MVVM</code>模式的一个流程示例。<code>View</code>层有用户点击，<code>VM</code>层通过双向绑定得知，做简单处理之后向<code>Model</code>层发送请求，<code>Model</code>层中主要的程序逻辑对接收到的数据进行计算等操作，得到结果后再通知<code>VM</code>层。<code>VM</code>数据更改之后，<code>View</code>层通过双向绑定，从而得知数据更新，并进行视图更新。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="22.jpg" alt="MVVM模式" title>                </div>                <div class="image-caption">MVVM模式</div>            </figure><p><code>MVVM</code>模式一般很少会自己实现，有现成的框架。前端有<code>Vue.js</code>，是一个提供了<code>MVVM</code>模式中数据双向绑定的<code>Javascript</code>库。<code>Android</code>方面，<code>Google</code>提供了<code>Databinding</code>库。</p><h3 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h3><p><code>DataBinding</code>是谷歌官方发布的一个框架，顾名思义即为数据绑定，是<code>MVVM</code>模式在<code>Android</code>上的一种实现，用于降低布局和逻辑的耦合性，使代码逻辑更加清晰。</p><p><code>DataBinding</code>其实并没有实现新的<code>API</code>来完成双向绑定，只是对原有<code>API</code>的封装，如<code>findViewById()</code>和<code>setText()</code>，亦或是<code>click</code>事件，这些都被框架隐藏起来了。</p><p>至于这些事件的触发，例如<code>View</code>层接收到点击事件并通知<code>ViewModel</code>层，则是使用发布订阅模式实现的，如下图：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="23.jpg" alt="DataBinding实现" title>                </div>                <div class="image-caption">DataBinding实现</div>            </figure><p>每当<code>View</code>层更改时，<code>ViewModel</code>层通过订阅收到通知；每当<code>ViewModel</code>层更改时，<code>View</code>层也会通过订阅收到通知，这样就实现了双向绑定。</p><p>这里可能会出现一个循环问题，假设其中某一层<code>A</code>改变，那么另外一层<code>B</code>得到通知随之改变，这会导致<code>A</code>层得到通知，<code>A</code>层也改变，循环往复出现问题。</p><p><code>DataBinding</code>通过前后数据对比来决定是否更新，假设<code>View</code>层需要更新文本信息（如<code>TextView</code>），则<code>DataBinding</code>会对比当前的文本和更新的文本，如果不一致则进行更新操作；如果相同，则不做任何操作。其他的控件也有类似的判定操作，这样就解决了数据双向绑定中的循环问题。</p><h3 id="在Android开发中的应用-2"><a href="#在Android开发中的应用-2" class="headerlink" title="在Android开发中的应用"></a>在Android开发中的应用</h3><p>以实现和<code>MVP</code>模式中相同的界面布局为例，界面上有一个按钮，点击按钮显示一条<code>Toast</code>，具体显示的消息从远端获取。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="8.jpg" alt="示意图" title>                </div>                <div class="image-caption">示意图</div>            </figure><p>整个流程过程如下图所示。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="24.jpg" alt="流程图" title>                </div>                <div class="image-caption">流程图</div>            </figure><p><code>DataBinding</code>因为有现成的框架，因此这里就不贴具体实现的代码了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>安卓开发中<code>MVC</code>模式存在的耦合问题在其他开发中可能不存在，各个模式之间也没有什么优劣之分，只有适合与否的问题。整体而言，在不考虑框架的前提下，安卓开发中个人使用<code>MVP</code>模式较多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在实验室内部做了一次分享，主要内容是&lt;code&gt;Android&lt;/code&gt;开发中常使用的三种软件框架模式，&lt;code&gt;MVC&lt;/code&gt;、&lt;code&gt;MVP&lt;/code&gt;和&lt;code&gt;MVVM&lt;/code&gt;，另外写了一个小&lt;code&gt;Demo&lt;/code&gt;来演示这几
      
    
    </summary>
    
      <category term="Android" scheme="https://KingsFish.github.io/categories/Android/"/>
    
    
      <category term="Android" scheme="https://KingsFish.github.io/tags/Android/"/>
    
      <category term="MVC" scheme="https://KingsFish.github.io/tags/MVC/"/>
    
      <category term="MVP" scheme="https://KingsFish.github.io/tags/MVP/"/>
    
      <category term="MVVM" scheme="https://KingsFish.github.io/tags/MVVM/"/>
    
  </entry>
  
  <entry>
    <title>近况</title>
    <link href="https://KingsFish.github.io/2019/01/23/%E8%BF%91%E5%86%B5/"/>
    <id>https://KingsFish.github.io/2019/01/23/近况/</id>
    <published>2019-01-23T09:22:13.000Z</published>
    <updated>2019-06-14T14:54:55.010Z</updated>
    
    <content type="html"><![CDATA[<p>距离上一篇博客更新已经一个月了，聊聊最近做了些什么，也算是个一月总结吧。</p><p>如果没有在印象笔记里记录每天的生活，我现在怕是又会觉得自己荒废了这个月。</p><center>一</center><p>离交论文的时候越来越近，一月份终于下定决心开始写专利。跟老师讨论了大的框架，没想到他的想法和我的有一些类似的地方，都是分成了两个部分。可能他也觉得直接一步到位难度太大，根本没法做出来，因为训练集的数据也不好采集。</p><p>花了大概一个礼拜写完，包括大框架和具体的细节，包括网络的结构和特征的选取，当然这两个都不是什么很难的问题。改完老师给了我一些修改意见，明年还得去专利办「挨骂」。</p><p>有点想不明白的是，明明是自己掏钱去专利办改专利，到了那里却要被改专利的老师说这说那。怪不得现在越来越多的实验室选择走校外代理改专利，写好之后直接发给代理，自己就不用操心了。</p><center>二</center><p>闲着没事处理了一下<code>vps</code>对外开放的端口，之前基本所有端口都是对外开放的，我很惊讶自己居然没有受攻击。其实之前给北京那边做项目的时候就已经意识到<code>vps</code>大部分端口是对外开放的，只是自己比较懒没动。</p><p>当然这件事情的起因是赵乐需要一个扩展视野的工具。最近资金紧张，没想到合租的哥们经济比我更紧张。这几个月一直都是我自己一个人在承担费用，有点扛不住。有人帮忙负担轻松了很多，不过还是遏制住了自己想要大力推广多找人合租的想法，还是找信得过的人比较好，不然出事了那才是真麻烦。</p><p>在运维的道路上又进了一步。</p><center>三</center><p>在星球看见别人推荐了「网易蜗牛读书」这个<code>app</code>，下载试用了一下，发现还不错。</p><p>「网易蜗牛读书」每天只有一个小时的免费读书时长，看起来很短，但是正如他的<code>slogan</code>所述，「时间出新知」，只要坚持下去，你会发现阅读量会越来越多。</p><p>另外，对于大多数人来说，每天一个小时的阅读时间已经足够。就我自己的体验而言，这两周每天的 1 小时基本足够，中间也有几天没用完的情况。</p><p>「网易蜗牛读书」里面的很多书都是免费的，排版也不错，比起之前需要自己到处搜索<code>mobi</code>电子书然后放到手机用<code>kindle</code>看体验好太多。不过还是有一些书需要开通会员才能看，当然这也有免费的方法。</p><p>阅读时长每增加一个小时能得到一个蜗牛壳，每本书都可以用一定的蜗牛壳换，包括会员才能看的书，不过这方法对于我这种阅读速度较快的人来说就有点亏了。</p><p>最近在读「明朝那些事儿」。这本书之前看过一点，但是后来没时间看就放弃了。不得不说感觉在蜗牛阅读要比在<code>kindle</code>上看书要好，目前已经看到了第三册。历史还是挺有趣的，并不是流水账一般某年某月某日，某人于某地打败某人，或者说某年某月某日某皇帝登位，称眀某宗，年号某某，历史上的人和现在的人没有什么区别，他们也有喜怒哀乐，他们的生活也过得多姿多彩。</p><center>四</center><p>临近过年，最后这一周无心学习，忙着收拾东西回家，看到「网易蜗牛读书」上推了一本书叫「斯通纳」，说是适合回家路上或者春节期间阅读。这本书在豆瓣上超过两万个人评分，却依然拿到了<code>8.8</code>分。</p><p>这本书主要内容是作者「斯通纳」的一生经历，可以理解为自传。「斯通纳」初次出版的时间是<code>1965</code>年，但直到近<code>50</code>年后，它才登上多国图书畅销榜榜首。</p><p>他的经历和现在很多人相似，讲述的关于「寒门贵子」的故事。斯通纳是一个从农村进入大学，从而逃脱了祖辈世代务农命运的人。巨大的身份转变，给他带来了深刻的孤独——他接受的教育让他逐渐疏远土地和父母，他的出身又使他无法与娇贵的妻子达成真正的关于生活的共识，孤独以及阶级鸿沟。</p><p>不过斯通纳很幸运，最后还是找到了自己生活的意义，坚持自己的原则，并为之付出了一生。</p><p>但愿自己也能找自己的方向。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;距离上一篇博客更新已经一个月了，聊聊最近做了些什么，也算是个一月总结吧。&lt;/p&gt;
&lt;p&gt;如果没有在印象笔记里记录每天的生活，我现在怕是又会觉得自己荒废了这个月。&lt;/p&gt;
&lt;center&gt;一&lt;/center&gt;

&lt;p&gt;离交论文的时候越来越近，一月份终于下定决心开始写专利。跟老
      
    
    </summary>
    
      <category term="生活琐事" scheme="https://KingsFish.github.io/categories/%E7%94%9F%E6%B4%BB%E7%90%90%E4%BA%8B/"/>
    
    
  </entry>
  
  <entry>
    <title>2018 这一年</title>
    <link href="https://KingsFish.github.io/2018/12/31/2018-%E8%BF%99%E4%B8%80%E5%B9%B4/"/>
    <id>https://KingsFish.github.io/2018/12/31/2018-这一年/</id>
    <published>2018-12-31T02:42:56.000Z</published>
    <updated>2019-06-14T14:54:54.839Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>公历和农历的差别总是让我很困惑。春节这个仪式还没有过去，农历总让我以为还有一阵子才是新的一年。公历却用冷冰冰的数字告诉我<code>2019</code>年的余额已经不足一个礼拜了，忙忙碌碌又一年。</p><p>不知道是什么时候开始养成的写总结的习惯，可能是不再写日记的时候。没有了每天对生活的记录，时间的概念变得很模糊，总得有个总结，才能让自己的记忆不显得那么空白。</p><center>一</center><p>年中曾写过一篇总结，现在看来当时的展望唯一完成的只有找到好工作这一项，其他诸如“坚持健身计划”、“学习经济学知识”的目标都消失在了我的记忆里。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>为了找工作做的准备还挺多的，参加华为的大赛，刷算法题，做项目等等。找工作其实没什么，回报取决于你付出的多少，我也很惊讶自己今年能找到的工作。可能之前的基础太差了，打实基础之后更容易获得更大的成就，当然更大的因素还是今年客户端岗位的供求状况。</p><p><strong>一个人的命运啊，当然要靠自我奋斗，但是也要考虑到历史的行程。</strong></p><p>明年是工作的第一年，希望自己能够一如既往继续加油。</p><center>二</center><p>目前为止，博客运营已经一年半了。大部分内容是为了工作准备的算法，比如<code>Leetcode</code>以及”剑指<code>offer</code>“，剩下的就是自己的生活琐事和总结类的文章。整体来说，感觉博客内容有些偏。其实可以把这个博客当作一个<strong>产品</strong>来运营。考虑“竞品”也即别人的博客相对于自己的博客有哪些更能吸引用户的地方，想想自己博客有什么特色，而不是普普通通的一个个人博客。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="blog.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>之前建立博客的本意是为了自己有一个记录的地方，并不考虑浏览量以及知名度类似的数据，而现在却觉得这可能会是一个提升自己“名气”、积攒流量的地方。就像别人运营微信公众号一样，有了关注用户之后就可以做一些导流，再之后变现或者其他的动作才会有基础，另外也可以实践如何去运营一个产品，拓宽知识面的广度。</p><p>说到博客，本来在博客添加收钱码只是为了好玩，没想到却收到了打赏。虽然金额不多，但是非常高兴。</p><center>三</center><p>今年<strong>互联网寒冬</strong>严重，招聘冻结，很多公司都传出了裁员的新闻。了解的越多就越会发现光有技术远远不够。也需要懂业务，懂产品。有之前实习的同事说身边有人砍掉了，其实他们技术都还不错，只是业务做的不好。除非自己在公司的技术地位到了不可或缺的地步，否则都有可能被裁。</p><p>这阵子在知识星球看了“<strong>钱钰</strong>”写的一篇文章，大概说程序员有四种出路：</p><ol><li>技术专家，技术有深有广</li><li>转管理，坑位不多</li><li>转产品，结合技术和业务</li><li>创业，难度大，所需能力非常多</li></ol><p>考虑到现在的大环境以及以上四种出路所需的知识面和技能，自己最适合的是“<strong>技术专家</strong>”和“<strong>产品</strong>”，有时间的时候需要了解一下相关的知识。</p><center>四</center><p>这一年基本忙于工作准备以及找工作，中间因为实验室项目的事情出差了几次。期间有差补，出去长长见识。回了趟家，看了看装修的老房子。去了趟杭州，没怎么逛就回来了。杭州、南京和北京都是第一次去，相比于往年，出去的机会多了很多。</p><p>遗憾的是之前想找完工作要带父母去趟北京，到现在也还没实现。不过以后在北京工作，应该会方便很多。对于很多上一辈的人来说，去一趟天安门是他们一生的夙愿。但是不管自己父母是不是这么想，带他们来北京旅游一次也是应该的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="7.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><center>五</center><p>老校区附近吉祥村新开了一个大商场——<code>MOMOPARK</code>，这里成了我和婷婷今年最青睐的地方。吃的很丰富，以往在老城根的“甘食记肥肠粉”，凯德的“阿甘锅盔”还有益田的“守艺人”都在这里开了新店。另外，这里离“博纳影城”很近，这家电影院也是刚成为新欢，价格合适，离的也近，在<code>MOMOPARK</code> 吃完饭之后溜达一下就过去了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="3.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>临近年末，前几天西安下了场大雪。市区没有什么感觉，郊区比南二环冷很多，雪积的很厚。下雪那天正好给老师办事情，要去一趟新校区。顺便和一个刚考完研的学弟吃了顿饭，学弟考完研在图书馆自学<code>office</code>。记忆里熟的饭店不多，去了川湘会馆。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="4.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>吃饭的时候谈到了女朋友这类话题，学弟说最近有点失落。考完研好不容易鼓起勇气跟妹子要了联系方式，却发现妹子对他不感兴趣。与此同时却有一两个妹子跟学弟要了联系方式，我一时不知道该恭喜他还是安慰他。</p><p>毕业之后学校变化很大，即将盖起来的网信院大楼，以往的工训中心几根大柱子也被围起来修整了一番，更不用说东门已经拆完，北门也只剩一点点。以前和婷婷经常去吃的北门<strong>鸡王爷</strong>，小店还在，老板也还是那个人，但是味道不复以前，只能说声可惜，新校区最后想念的滋味也没了。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="5.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>热腾腾和下雪最为搭伴。去年的这几天正是节气“大雪”，飘着一层辣椒油的粉汤羊血和外面的大雪相得益彰。不过婷婷对粉汤羊血好像不怎么感兴趣，新校区回来就叫上婷婷去了另外一家店，<strong>澄城水盆羊肉</strong>。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="6.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>婷婷很喜欢他家的月牙饼，刚烤出来，冒着热气，咬一口齿唇留香，配上熬烂的的羊肉，再喝上一口汤，简直是享受。店里坐的很满，熙熙攘攘的，大概都是些下雪天溜出来享受生活的人。</p><center>六</center><blockquote><p> <strong>口红效应</strong>是一种经济学理论，即当面对金融危机时，消费者将更愿意购买成本较低的奢侈品，而不是皮毛大衣。例如，人们会购买昂贵的口红。</p></blockquote><p>根据相关数据显示，<code>2018</code>年口红销售额增长了<code>97%</code>。</p><p>经济形势不好，连累股市，今年亏损有点惨。作为非经济学专业的人不会去深究根本原因是什么，但是股市大跌是从中美贸易站开始的，打了大半年也不见好，很多人把这次大跌看成人生中大赚一笔的少数机会。明年会怎么样谁也不知道，低头捡点便宜的筹码，保持好现金流，耐心等待反弹的时候。</p><center>七</center><p>年中的时候被婷婷强行凑单养了一盆文竹，寄过来的是懒人浇水盆，也就是自吸水的那种。后来花店老板告诉我才发现这样对文竹不好，文竹喜湿但根不能长期放在湿润的土壤里，容易烂根。另外，文竹需要散射光，但不能直射。文竹一直被我放在实验室没有晒过太阳，缺少光合作用的文竹一直保持嫩绿色。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="8.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>趁着刚汇报完有时间，搞了点土改装了一下花盆，买了个底座。晒了两天太阳之后文竹迅速长出了新叶子，虽然老的叶子还是有一些黄，但是新生的力量已经成长起来了。</p><p><strong>愿我的 2019 也能像文竹一样向上生长。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
      <category term="复盘" scheme="https://KingsFish.github.io/categories/%E5%A4%8D%E7%9B%98/"/>
    
    
      <category term="总结" scheme="https://KingsFish.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
      <category term="2018" scheme="https://KingsFish.github.io/tags/2018/"/>
    
      <category term="复盘" scheme="https://KingsFish.github.io/tags/%E5%A4%8D%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode 962 Maximum Width Ramp</title>
    <link href="https://KingsFish.github.io/2018/12/23/Leetcode-962-Maximum-Width-Ramp/"/>
    <id>https://KingsFish.github.io/2018/12/23/Leetcode-962-Maximum-Width-Ramp/</id>
    <published>2018-12-23T03:31:52.000Z</published>
    <updated>2019-06-14T14:54:54.901Z</updated>
    
    <content type="html"><![CDATA[<p>今天有时间参加了一下<code>Leetcode Weekly Contest 116</code>，参加的比较晚，完成两题之后没时间做其他的了，在这里写一下完成的两题中的一题。题目如下：</p><blockquote><p>Given an array A of integers, a ramp is a tuple (i, j) for which i &lt; j and A[i] &lt;= A[j].  The width of such a ramp is j - i. Find the maximum width of a ramp in A.  If one doesn’t exist, return 0.</p></blockquote><p>题目意思是这样，给定一个数组<code>A</code>，将符合如下条件数字对<code>(i, j)</code>定义为<code>ramp</code>：</p><ol><li><code>i</code>, <code>j</code> 是数组<code>A</code>中的下标</li><li><code>A[i] &lt;= A[j]</code></li></ol><p>并定义<code>ramp</code>的距离是<code>j - i</code>，求数组中最大的<code>ramp</code>距离，如果不存在则返回 0。</p><p>这题思路其实很简单，直接遍历即可。对于每一个固定的下标<code>i</code>，从数组的右边开始遍历，直到找到一个比<code>A[i]</code>大的数字<code>A[j]</code>即可，同时记录距离<code>j - i</code>。另外，如果最大距离已经超过了下标<code>i</code>可能的最大距离，也即<code>n - 1 - i</code>，则直接退出循环，因为这个时候不可能找到比当前距离更大的数字了。</p><p>举例：给定数组<code>[6,0,8,2,1,5]</code>，当<code>i = 2</code>时，之前记录的最大距离是<code>5 - 1（i = 1的时候）</code>，而<code>i &gt;=2</code>的情况下，可能出现的最大<code>ramp</code>也不会超过<code>4</code>，所以这个时候可以直接退出循环，<code>4</code>即为最大<code>ramp</code>距离。</p><p>具体实现的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxWidthRamp</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = A.length;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(max &gt;= n - <span class="number">1</span> - i)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt; i; j --) &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[j] &gt;= A[i]) &#123;</span><br><span class="line">                    max = Math.max(max, j - i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种思路的最差时间复杂度是<code>O(n^2)</code>，最优时间复杂度是<code>O(1)</code>，空间复杂度是<code>O(1)</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天有时间参加了一下&lt;code&gt;Leetcode Weekly Contest 116&lt;/code&gt;，参加的比较晚，完成两题之后没时间做其他的了，在这里写一下完成的两题中的一题。题目如下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Given an array A of in
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://KingsFish.github.io/categories/Leetcode/"/>
    
    
      <category term="Algorithm" scheme="https://KingsFish.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 11 数值的整数次方</title>
    <link href="https://KingsFish.github.io/2018/12/21/%E5%89%91%E6%8C%87offer-11-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/"/>
    <id>https://KingsFish.github.io/2018/12/21/剑指offer-11-数值的整数次方/</id>
    <published>2018-12-21T03:34:48.000Z</published>
    <updated>2019-06-14T14:54:54.964Z</updated>
    
    <content type="html"><![CDATA[<p>题目：</p><blockquote><p>实现函数<code>double power(double base, int exponent)</code>，求 base 的 exponent 次方。不得使用库函数，同时不需要考虑大数问题。</p></blockquote><p>这个问题最简单的方法是暴力求解，循环<code>exponent</code>次，每次乘于<code>base</code>，最终结果即为所求。注意负数，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (base == <span class="number">0.0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> minus = exponent &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        exponent = exponent &gt; <span class="number">0</span> ? exponent : -exponent;</span><br><span class="line">        <span class="keyword">while</span> (exponent &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            res *= base;</span><br><span class="line">            exponent --;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minus &gt; <span class="number">0</span> ? res : <span class="number">1</span> / res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度是<code>O(n)</code>。当然这种思路并不高效，做了很多重复工作。比如<code>a^32</code>完全可以由<code>a^16</code>平方得到，<code>a^16</code>可以由<code>a^8</code>平方得到，以此类推直到<code>a^1</code>；而奇数情况下则只需要再乘一次<code>a</code>即可。而由这个思路则可以得到如下打码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">Power</span><span class="params">(<span class="keyword">double</span> base, <span class="keyword">int</span> exponent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (base == <span class="number">0.0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exponent == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">double</span> res = base;</span><br><span class="line">        <span class="keyword">int</span> minus = exponent &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        exponent = exponent &gt; <span class="number">0</span> ? exponent : -exponent;</span><br><span class="line">        <span class="keyword">int</span> ex = exponent;</span><br><span class="line">        <span class="keyword">while</span> (ex = ex &gt;&gt; <span class="number">1</span>) &#123;</span><br><span class="line">            res *= res</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exponent &amp; <span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            res *= base;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minus &gt; <span class="number">0</span> ? res : <span class="number">1</span> / res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种思路的时间复杂度是<code>O(logn)</code>，相比第一种解法简单了很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;实现函数&lt;code&gt;double power(double base, int exponent)&lt;/code&gt;，求 base 的 exponent 次方。不得使用库函数，同时不需要考虑大数问题。&lt;/p&gt;
&lt;/blockquo
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://KingsFish.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="Algorithm" scheme="https://KingsFish.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 10 二进制中1的个数</title>
    <link href="https://KingsFish.github.io/2018/12/09/%E5%89%91%E6%8C%87offer-10-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
    <id>https://KingsFish.github.io/2018/12/09/剑指offer-10-二进制中1的个数/</id>
    <published>2018-12-09T02:33:53.000Z</published>
    <updated>2019-06-14T14:54:54.964Z</updated>
    
    <content type="html"><![CDATA[<p>题目：</p><blockquote><p>请实现一个函数，输入一个整数，输出该数字二进制表示中 1 的个数。例如把 9 表示成二进制是 1001，有 2 位 是1。因此如果输入 9，该函数输出 2。</p></blockquote><p>常规思路很清晰，将该数字和 1 按位与，如果结果是 1 则表明该数字最右一位是 1，如果结果是 0 则表明该数字最右一位是 0。不断将该数字右移，最终即可得到结果。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((n &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                res ++;</span><br><span class="line">            &#125;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按照<code>Java</code>的结构，一个<code>int</code>型数字最长<code>32</code>位，所以只需要循环<code>32</code>次即可求得结果。</p><p>当然有一个更简单的解法，把一个整数减去 1，再和原整数做按位与运算，会把该整数最右边一个 1 变成 0。那么一个整数的二进制表示中有多少个 1，就可以进行多少次这样的操作。 例如数字 9（1001）：</p><ol><li>1001 &amp; (1001 - 1) = 1000</li><li>1000 &amp; (1000 - 1) = 0</li></ol><p>一共进行两次，运算进行的次数就是最后的结果，代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">NumberOf1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (n != <span class="number">0</span>) &#123;</span><br><span class="line">            res ++;</span><br><span class="line">            n = (n - <span class="number">1</span>) &amp; n；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;请实现一个函数，输入一个整数，输出该数字二进制表示中 1 的个数。例如把 9 表示成二进制是 1001，有 2 位 是1。因此如果输入 9，该函数输出 2。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;常规思路很清晰，将该数字和
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://KingsFish.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="Algorithm" scheme="https://KingsFish.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 09 斐波那契数列</title>
    <link href="https://KingsFish.github.io/2018/11/26/%E5%89%91%E6%8C%87offer-09-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
    <id>https://KingsFish.github.io/2018/11/26/剑指offer-09-斐波那契数列/</id>
    <published>2018-11-26T14:16:01.000Z</published>
    <updated>2019-06-14T14:54:54.964Z</updated>
    
    <content type="html"><![CDATA[<p>题目：</p><blockquote><p>写出一个函数，输入 n，求斐波那契数列的第 n 项。斐波那契数列的定义如下：<br>f(n) = </p><ol><li>0, n = 0</li><li>1, n = 1</li><li>f(n - 1) + f(n - 2), n &gt; １</li></ol></blockquote><p>斐波那契数列相对来说是比较熟悉的一个概念，主要思路是当前项的值为前两项的值之和，所以只需要一步一步保存并计算之前的值即可，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">0</span>, second = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n)&#123;</span><br><span class="line">            second = first + second;</span><br><span class="line">            first = second - first;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为<code>O(n)</code>，空间复杂度为<code>O(1)</code></p><h5 id="问题扩展"><a href="#问题扩展" class="headerlink" title="问题扩展"></a>问题扩展</h5><blockquote><p>一只青蛙一次可以跳上一级台阶，也可以跳上两级。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p></blockquote><p>这个问题可以逐步分解，考察第 i 级台阶，明显第 i 级台阶有两种跳法，分别是从第 i - 1 和 i  - 2 级台阶跳上来，所以跳上 i 级台阶的跳法应该是 i - 1 级和 i - 2 级台阶跳法的总和，于是有<code>f(i) = f(i - 1) + f(i - 2）</code>，其实就是斐波那契数列。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">JumpFloor</span><span class="params">(<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first = <span class="number">1</span>, second = <span class="number">1</span>, i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; target)&#123;</span><br><span class="line">            second = first + second;</span><br><span class="line">            first = second - first;</span><br><span class="line">            i ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这个题目有一点动态规划的意思，不过是简化的版本，不需要存储所有状态，只需要前两个即可。动态规划则可能需要存储所有状态的数据，用以计算之后的状态。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;写出一个函数，输入 n，求斐波那契数列的第 n 项。斐波那契数列的定义如下：&lt;br&gt;f(n) = &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;0, n = 0&lt;/li&gt;
&lt;li&gt;1, n = 1&lt;/li&gt;
&lt;li&gt;f(n - 1) + f(n
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://KingsFish.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="Algorithm" scheme="https://KingsFish.github.io/tags/Algorithm/"/>
    
      <category term="递归" scheme="https://KingsFish.github.io/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer 08 旋转数组的最小数字</title>
    <link href="https://KingsFish.github.io/2018/11/06/%E5%89%91%E6%8C%87offer-08-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>https://KingsFish.github.io/2018/11/06/剑指offer-08-旋转数组的最小数字/</id>
    <published>2018-11-06T04:21:04.000Z</published>
    <updated>2019-06-14T14:54:54.964Z</updated>
    
    <content type="html"><![CDATA[<p>题目：</p><blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之外数组的旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组｛3,4,5,1,2｝为｛1,2,3,4,5｝的一个旋转，该数组的最小值为1。</p></blockquote><p>这道题最简单的方法当然是直接遍历，然后找出最小的即可，时间复杂度是O(n)。但是这种方法并没有利用到旋转数组的特性，更好的方法是用类似于“二分查找”的方法。</p><p>旋转数组是有原先的有序数组做一定处理得到的，所以旋转数组以最小元素分割，两边都具有有序性，根据这个特性可以不断缩小查找的范围。</p><p>类似于二分查找，不断比较中间的值<code>mid</code>和最右边的值<code>hi</code>，如果<code>mid</code>大于<code>hi</code>，说明最小元素肯定在这两个数之间，也即右边；如果<code>mid</code>等于<code>hi</code>，那么我们无法判断最小元素在哪一边，只能按照顺序查找，将<code>hi</code>减一；如果<code>mid</code>小于<code>hi</code>，说明最小元素肯定在另外一边，也即左边，这个时候只需要更新一下<code>hi</code>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(<span class="keyword">int</span> [] array)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>, hi= array.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(lo &lt; hi) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[mid] &gt; array[hi]) &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(array[mid] == array[hi]) &#123;</span><br><span class="line">                hi = hi - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                hi = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[lo];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述思路最佳的时间复杂度是<code>O(logn)</code>，最坏复杂度是<code>O(n)</code>，这道题算是二分查找的一个变形。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;把一个数组最开始的若干个元素搬到数组的末尾，我们称之外数组的旋转。输入一个非减排序的数组的一个旋转，输出旋转数组的最小元素。例如数组｛3,4,5,1,2｝为｛1,2,3,4,5｝的一个旋转，该数组的最小值为1。&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://KingsFish.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="Algorithm" scheme="https://KingsFish.github.io/tags/Algorithm/"/>
    
      <category term="数组" scheme="https://KingsFish.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode-146-LRUCache</title>
    <link href="https://KingsFish.github.io/2018/10/16/Leetcode-146-LRUCache/"/>
    <id>https://KingsFish.github.io/2018/10/16/Leetcode-146-LRUCache/</id>
    <published>2018-10-16T07:13:57.000Z</published>
    <updated>2019-06-14T14:54:54.885Z</updated>
    
    <content type="html"><![CDATA[<p>题目：</p><blockquote><p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.<br>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.<br>Follow up:<br>Could you do both operations in O(1) time complexity?</p></blockquote><blockquote><p>Example:<br>LRUCache cache = new LRUCache( 2 /* capacity */ );<br>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // returns 1<br>cache.put(3, 3);    // evicts key 2<br>cache.get(2);       // returns -1 (not found)<br>cache.put(4, 4);    // evicts key 1<br>cache.get(1);       // returns -1 (not found)<br>cache.get(3);       // returns 3<br>cache.get(4);       // returns 4</p></blockquote><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>这是一个经典的题目，设计一个<code>LRUCache</code>。<a href="https://en.wikipedia.org/wiki/Cache_replacement_policies#LRU" target="_blank" rel="noopener">LRU</a> 是一个缓存算法， 在实际编程中使用的很广泛，比如页面置换算法和图片缓存。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>思路其实就是理解<code>LRU</code>这个算法，然后按照思路去实现就好。</p><p><code>Java</code>其实已经实现了这个算法，重写<code>LinkedHashMap</code>的<code>removeEldestEntry</code>方法，给定删除元素的触发条件即可。至于<code>LinkedHashMap</code>内部是如何实现的这里不再赘述，有兴趣的可以去看看源码。这里我使用了另外一种实现方式，<code>HashMap</code>加双向链表。</p><p>对外的<code>API</code>主要有两个，<code>put</code>和<code>get</code>，其实应该还有一个<code>clear</code>方法，用于清空整个缓存，这个方法实现较为简单，只需要把双向链表首尾置空，然后初始化<code>HashMap</code>即可。</p><p>其实<code>LRUCache</code>里还有两个很重要的内部方法<code>moveToFirst</code>和<code>trimToSize</code>，<code>moveToFirst</code>主要完成将元素放到队首的操作，<code>trimToSize</code>则将缓存数量恢复到额定大小。</p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>按照<code>LRU</code>的原理，每次执行<code>get</code>方法先检查缓存里是否存在，不存在则直接返回空，存在则将该元素放到双向链表的队首并返回。</p><p>如果没有<code>HashMap</code>的话，检查缓存是否存在是一个比较消耗时间的操作，需要从队首开始遍历一直到队尾，用<code>HashMap</code>能加速访问。</p><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><p><code>put</code>方法比较复杂，要做的操作很多。</p><p>首先检查缓存里是否存在，如果存在则更新<code>value</code>值将其放到队首；如果不存在则新建一个<code>key-value</code>对象，将这个新建的对象放到<code>HashMap</code>和双向链表的队首，之后还需要检查当前数据数量是否超过缓存大小，如果超过了则需要去除队尾的数据。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>这里按照<code>Leetcode</code>上的要求完成，<code>key</code>和<code>value</code>都是<code>Integer</code>类型，但实际使用编写的时候最好使用泛型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;Integer, Node&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> capacity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    Node head, tail;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;(capacity);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node tmp = map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 该元素不存在</span></span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 该元素存在，放到队首并返回</span></span><br><span class="line">            addToHead(key);</span><br><span class="line">            <span class="keyword">return</span> tmp.val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        Node tmp = map.get(key);</span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 元素不存在，新建键值对，并更新缓存数量</span></span><br><span class="line">            tmp = <span class="keyword">new</span> Node(key, value);</span><br><span class="line">            map.put(key, tmp);</span><br><span class="line">            size ++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp.val = value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 无论元素是否存在，都需要将其放到队首</span></span><br><span class="line">        addToHead(key);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 检查缓存数量是否超过容量</span></span><br><span class="line">        <span class="keyword">if</span>(size &gt; capacity) &#123;</span><br><span class="line">            trimToSize();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将元素放入队首操作，情况较多</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addToHead</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        Node tmp = map.get(key);</span><br><span class="line">        <span class="comment">// 元素本来就在队首</span></span><br><span class="line">        <span class="keyword">if</span>(tmp == head) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素在队尾，更新队尾指针</span></span><br><span class="line">        <span class="keyword">if</span> (tmp == tail) &#123;</span><br><span class="line">            tail = tail.pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重新建立双向链接</span></span><br><span class="line">        <span class="keyword">if</span>(tmp.pre != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tmp.pre.next = tmp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            tmp.next.pre = tmp.pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 放队首操作</span></span><br><span class="line">        tmp.pre = <span class="keyword">null</span>;</span><br><span class="line">        tmp.next = head;</span><br><span class="line">        <span class="keyword">if</span>(head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            head.pre = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        head = tmp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 特殊情况，第一次添加数据，需要更新队尾</span></span><br><span class="line">        <span class="keyword">if</span>(tail == <span class="keyword">null</span>) &#123;</span><br><span class="line">            tail = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除队尾数据</span></span><br><span class="line">        size --;</span><br><span class="line">        map.remove(tail.key);</span><br><span class="line">        tail = tail.pre;</span><br><span class="line">        tail.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line">        <span class="comment">// 数据实体</span></span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> key = <span class="number">0</span>;</span><br><span class="line">        Node next;</span><br><span class="line">        Node pre;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            next = <span class="keyword">null</span>;</span><br><span class="line">            pre = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.get(key);</span></span><br><span class="line"><span class="comment"> * obj.put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><code>Leetcode</code>运行时间不稳定，一样的代码两次提交运行时间一样，这里放一张时间更短的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="time.jpg" alt="运行时间" title>                </div>                <div class="image-caption">运行时间</div>            </figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operat
      
    
    </summary>
    
      <category term="Leetcode" scheme="https://KingsFish.github.io/categories/Leetcode/"/>
    
    
      <category term="LRU" scheme="https://KingsFish.github.io/tags/LRU/"/>
    
      <category term="Algorithm" scheme="https://KingsFish.github.io/tags/Algorithm/"/>
    
      <category term="HashMap" scheme="https://KingsFish.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-07-用两个栈实现队列</title>
    <link href="https://KingsFish.github.io/2018/10/13/%E5%89%91%E6%8C%87offer-07-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://KingsFish.github.io/2018/10/13/剑指offer-07-用两个栈实现队列/</id>
    <published>2018-10-13T02:28:26.000Z</published>
    <updated>2019-06-14T14:54:54.964Z</updated>
    
    <content type="html"><![CDATA[<p>题目：</p><blockquote><p>用两个栈实现一个队列，队列的声明如下，请实现它的两个函数 <code>appendTail</code> 和 <code>deleteHead</code>，分别完成在队列尾部插入结点和队列头部删除结点的功能。</p></blockquote><p>栈和队列相信大家都用得很熟了。栈是一种<code>FILO</code>的数据结构，而队列则是一种<code>FIFO</code>的数据结构，这个题目要求使用两个<code>FILO</code>的数据结构来实现<code>FIFO</code>。</p><p>思路其实并不难，主要需要实现两个<code>API</code>，一个是入队，一个是出队。主要思路是用栈 A 保存倒序的数据，而栈 B 保存正序的数据。入队时将数据放入栈 A 中，出队时将栈 B 弹栈即可。那么问题就在于如何将倒序的数据转换成正序的数据，其实只需要将栈 A 中的数据不断弹栈并压入栈 B 即可。入队时将数据不断压入栈 A，此时栈 A 存储的是倒序，当碰到出队请求时，先检查栈 B 是否为空，不为空则直接输出栈 B 的栈顶。若为空则将栈 A 里面的数据不断弹栈，然后在压入栈 B，这个时候栈 B 里面的顺序就是正确的了，这个时候只需要将栈 B 的栈顶输出即可，如下图所示。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="stack.jpg" alt="入队和出队" title>                </div>                <div class="image-caption">入队和出队</div>            </figure><p>有了思路之后代码实现就比较简单了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    Stack&lt;T&gt; a;</span><br><span class="line">    Stack&lt;T&gt; b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        a = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        b = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 入队操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        a.push(t);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 出队操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">deleteHead</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(b.empty()) &#123;</span><br><span class="line">            <span class="comment">// 栈 B 为空，将 A 中的数据都放入 B中</span></span><br><span class="line">            <span class="keyword">while</span>(!a.empty())&#123;</span><br><span class="line">                b.push(a.pop());           </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b.empty()) &#123;</span><br><span class="line">            <span class="comment">// 这个时候如果 B 仍为空，说明队列里没有任何数据，此时出队是错误操作</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"队列无数据"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回 B 的栈顶数据</span></span><br><span class="line">        <span class="keyword">return</span> b.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题其实可以拓展延伸，比如如何用两个队列实现栈，思路都差不多，有兴趣可以自己去实现一下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;用两个栈实现一个队列，队列的声明如下，请实现它的两个函数 &lt;code&gt;appendTail&lt;/code&gt; 和 &lt;code&gt;deleteHead&lt;/code&gt;，分别完成在队列尾部插入结点和队列头部删除结点的功能。&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://KingsFish.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="Algorithm" scheme="https://KingsFish.github.io/tags/Algorithm/"/>
    
      <category term="栈" scheme="https://KingsFish.github.io/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://KingsFish.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer-06-重建二叉树</title>
    <link href="https://KingsFish.github.io/2018/10/12/%E5%89%91%E6%8C%87offer-06-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://KingsFish.github.io/2018/10/12/剑指offer-06-重建二叉树/</id>
    <published>2018-10-12T07:19:02.000Z</published>
    <updated>2019-06-14T14:54:54.964Z</updated>
    
    <content type="html"><![CDATA[<p>题目：</p><blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果都不含重复的数字。</p></blockquote><p>前序遍历指的是先遍历根节点再分别遍历左右子节点；中序遍历指的是先遍历左子结点，其次根节点，最后右子节点。</p><p>思路很简单，先根据前序遍历的结果确定根节点，再在中序遍历的结果中查找到该节点，这样就可以切分出左右子树序列，在得到的左右子树序列中递归使用上面的方法即可构建出原来的树。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="tree.jpg" alt="遍历序列" title>                </div>                <div class="image-caption">遍历序列</div>            </figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span> [] pre,<span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> build(pre, in);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">build</span><span class="params">(<span class="keyword">int</span> [] pre, <span class="keyword">int</span> [] in)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pre.length == <span class="number">0</span> || in.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode root = <span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 寻找根节点</span></span><br><span class="line">    <span class="keyword">int</span> pos = findRoot(in, root.val);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> [] pre_tmp = copy(pre, <span class="number">1</span>, pos);</span><br><span class="line">    <span class="keyword">int</span> [] in_tmp = copy(in, <span class="number">0</span>, pos - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 递归完成左子树的建立</span></span><br><span class="line">    root.left = build(pre_tmp, in_tmp);</span><br><span class="line">    </span><br><span class="line">    pre_tmp = copy(pre, pos + <span class="number">1</span>, pre.length - <span class="number">1</span>);</span><br><span class="line">    in_tmp = copy(in, pos + <span class="number">1</span>, in.length - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 递归完成右子树的建立</span></span><br><span class="line">    root.right = build(pre_tmp, in_tmp);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历中序遍历序列寻找根节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">findRoot</span><span class="params">(<span class="keyword">int</span> [] in, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; in.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (in[i] == val) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 复制数组用于下一步操作</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] copy(<span class="keyword">int</span> [] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)&#123;</span><br><span class="line">    <span class="keyword">int</span> length = end - start + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> [] res = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i ++)&#123;</span><br><span class="line">        res[i] = array[i + start];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整体而言，算法使用了<code>O(nlogn)</code>的辅助空间，时间复杂度是<code>O(nlogn)</code>。其实空间复杂度可以进一步优化，没必要使用新的数组来保存子树，只需要传递子树序列的开始和结束位置即可，不过这里我就不写了。</p><blockquote><p>本来说话秋招准备之前写完大部分剑指 offer 题目的，结果发现 9 月份忙得很，现在找完了工作来填坑。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;题目：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果都不含重复的数字。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;前序遍历指的是先遍历根节点再分别遍历左右子节点；中序遍历指的是先遍历左子
      
    
    </summary>
    
      <category term="剑指offer" scheme="https://KingsFish.github.io/categories/%E5%89%91%E6%8C%87offer/"/>
    
    
      <category term="Algorithm" scheme="https://KingsFish.github.io/tags/Algorithm/"/>
    
      <category term="链表" scheme="https://KingsFish.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>我的 2019 Android 秋招经历</title>
    <link href="https://KingsFish.github.io/2018/10/10/%E6%88%91%E7%9A%84%202019%20Android%20%E7%A7%8B%E6%8B%9B%E7%BB%8F%E5%8E%86/"/>
    <id>https://KingsFish.github.io/2018/10/10/我的 2019 Android 秋招经历/</id>
    <published>2018-10-10T02:20:03.000Z</published>
    <updated>2019-06-14T14:54:54.995Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>经过几个月的努力，基本上拿到了满意的<code>offer</code>，一直奔波在求职路上，现在终于能好好的停下来总结这段经历。</p><p>找工作确实很累，无论从生理上还是心理上，我一天最多的时候赶了 3 场面试，分布在西安的各个地方，当天回来根本不想学习；面试被虐的时候会各种怀疑自己，怀疑人生。无论如何，保持好心态最重要。</p><p>求职期间其实看了很多前人的经历，现在总结也算是给后来秋招的师弟师妹一点参考和建议，希望师弟师妹早作准备，未来拿到心仪的<code>offer</code>。</p><p><strong>以下均为个人经验，可能不适用与所有人，另外鉴于个人水平有限，难免出现失误的地方，如果有欢迎提出，非常感谢。</strong></p><hr><h2 id="秋招战绩"><a href="#秋招战绩" class="headerlink" title="秋招战绩"></a>秋招战绩</h2><p>先总结一下秋招战绩，岗位都是安卓开发。大部分拒笔试和面试的原因都是自己手里头已经有了更好的<code>offer</code>，就不去浪费人家的时间和精力了。</p><table><thead><tr><th align="center">公司</th><th align="center">地点</th><th align="center">批次</th><th align="center">结果</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">vivo</td><td align="center">深圳</td><td align="center">提前批</td><td align="center">offer</td><td align="center">第一个 offer</td></tr><tr><td align="center">老虎证券</td><td align="center">北京</td><td align="center">正常批</td><td align="center">offer</td><td align="center">个人很看好的公司</td></tr><tr><td align="center">大疆</td><td align="center">深圳</td><td align="center">正常批</td><td align="center">offer</td><td align="center">土豪公司</td></tr><tr><td align="center">华为</td><td align="center">西安</td><td align="center">优招</td><td align="center">offer</td><td align="center">薪资给了个惊喜</td></tr><tr><td align="center">招银网络</td><td align="center">杭州</td><td align="center">正常批</td><td align="center">offer</td><td align="center"></td></tr><tr><td align="center">百度</td><td align="center">北京</td><td align="center">正常批</td><td align="center">offer</td><td align="center"></td></tr><tr><td align="center">中国银联</td><td align="center">上海</td><td align="center">提前批</td><td align="center">offer</td><td align="center">薪资今年大爆发</td></tr><tr><td align="center">字节跳动</td><td align="center">北京</td><td align="center">正常批</td><td align="center">offer</td><td align="center">准备签</td></tr><tr><td align="center">美团</td><td align="center">北京</td><td align="center">正常批</td><td align="center">offer</td><td align="center">薪资略失望</td></tr><tr><td align="center">罗辑思维</td><td align="center">北京</td><td align="center">正常批</td><td align="center">offer</td><td align="center">个人很看好的公司，薪资也给力，以后会考虑</td></tr><tr><td align="center">360</td><td align="center">北京</td><td align="center">正常批</td><td align="center">offer 池</td><td align="center"></td></tr><tr><td align="center">京东</td><td align="center">北京</td><td align="center">正常批</td><td align="center">笔试挂</td><td align="center"></td></tr><tr><td align="center">网易互娱</td><td align="center">深圳</td><td align="center">正常批</td><td align="center">笔试挂</td><td align="center"></td></tr><tr><td align="center">拼多多</td><td align="center">上海</td><td align="center">提前批</td><td align="center">笔试挂</td><td align="center"></td></tr><tr><td align="center">阿里巴巴</td><td align="center">杭州</td><td align="center">正常批</td><td align="center">笔试挂</td><td align="center">凑齐 4 个已回绝</td></tr><tr><td align="center">深信服</td><td align="center">深圳</td><td align="center">提前批</td><td align="center">笔试挂</td><td align="center"></td></tr><tr><td align="center">英语流利说</td><td align="center">北京</td><td align="center">提前批</td><td align="center">拒笔试</td><td align="center">已有其他offer</td></tr><tr><td align="center">海康威视</td><td align="center">杭州</td><td align="center">正常批</td><td align="center">拒笔试</td><td align="center">已有其他offer</td></tr><tr><td align="center">去哪儿</td><td align="center">北京</td><td align="center">正常批</td><td align="center">拒笔试</td><td align="center">已有其他offer</td></tr><tr><td align="center">爱奇艺</td><td align="center">北京</td><td align="center">提前批</td><td align="center">拒面试</td><td align="center">已有其他offer</td></tr><tr><td align="center">好未来</td><td align="center">成都</td><td align="center">正常批</td><td align="center">拒面试</td><td align="center">面试地点是成都，已有其他offer</td></tr><tr><td align="center">微众银行</td><td align="center">广州</td><td align="center">正常批</td><td align="center">拒面试</td><td align="center">面试地点是广州，已有其他offer</td></tr><tr><td align="center">oppo</td><td align="center">深圳</td><td align="center">正常批</td><td align="center">拒面试</td><td align="center">已有其他offer</td></tr><tr><td align="center">百词斩</td><td align="center">成都</td><td align="center">正常批</td><td align="center">拒面试</td><td align="center">已有其他offer</td></tr><tr><td align="center">腾讯</td><td align="center">深圳</td><td align="center">正常批</td><td align="center">拒面试</td><td align="center">与华为签约冲突，已有其他offer</td></tr><tr><td align="center">科大讯飞</td><td align="center">杭州</td><td align="center">正常批</td><td align="center">拒面试</td><td align="center">已有其他offer</td></tr><tr><td align="center">网易</td><td align="center">杭州</td><td align="center">正常批</td><td align="center">拒面试</td><td align="center">来了西安没叫我去面试，结果要去杭州面试</td></tr><tr><td align="center">keep</td><td align="center">北京</td><td align="center">正常批</td><td align="center">没消息</td><td align="center">现场投递简历，后来没消息</td></tr><tr><td align="center">搜狗</td><td align="center">北京</td><td align="center">提前批</td><td align="center">没消息</td><td align="center"></td></tr><tr><td align="center">贝壳</td><td align="center">北京</td><td align="center">正常批</td><td align="center">一面挂</td><td align="center">霸面</td></tr><tr><td align="center">百度</td><td align="center">北京</td><td align="center">提前批</td><td align="center">一面挂</td><td align="center">手机百度，难度很大</td></tr><tr><td align="center">oppo</td><td align="center">深圳</td><td align="center">提前批</td><td align="center">一面挂</td><td align="center">第一个挂的公司</td></tr><tr><td align="center">阿里巴巴</td><td align="center">杭州</td><td align="center">提前批</td><td align="center">一面挂</td><td align="center">国际事业部</td></tr><tr><td align="center">百度</td><td align="center">深圳</td><td align="center">提前批</td><td align="center">一面挂</td><td align="center">系统部，完全不是一个方向</td></tr><tr><td align="center">网易</td><td align="center">杭州</td><td align="center">提前批</td><td align="center">三面挂</td><td align="center">去杭州面试</td></tr></tbody></table><p>今年秋招提前了很多，基本上 8 月份很多大公司已经开始了，但其实最早的是大疆，4 月份有“技术分享会”，就是所谓的提前批，但是那时候基本没有人关注，也没有消息，之后就是<code>vivo</code>提前批，5 月底截止投递简历，然后 6 月份就面试完发了<code>offer</code>。我有幸参加了这个面试，拿到第一个<code>offer</code>，对我之后的求职信心有了很大的帮助。</p><hr><h2 id="我的个人情况"><a href="#我的个人情况" class="headerlink" title="我的个人情况"></a>我的个人情况</h2><p>先说一下我的个人情况，双西电通信工程专业硕士，个人感觉跟以往不一样的事是，现在找工作很多都是硕士，3 年前很多都是本科生。大三的时候，也就是 15 年移动客户端最火的时候学的安卓开发，信心满满准备找工作，被两家公司虐了之后发现自己技术是个渣，然后放弃找工作准备考研，研究生好好学技术， 3 年后再战。当然实际研究生阶段也没有按照自己当初的方向走，杂七杂八的学了很多其他的知识，比如深度学习和后端相关知识，最后还是决定选择最为熟悉的安卓开发作为求职的方向。</p><hr><h2 id="就业形势的个人看法"><a href="#就业形势的个人看法" class="headerlink" title="就业形势的个人看法"></a>就业形势的个人看法</h2><p>今年延续去年人工智能大潮，很多人涌向了算法岗位，人多竞争也激烈，因此今年算法算是一个小年。而开发学的人相对少了人多，尤其移动客户端。</p><p>以字节跳动（今日头条）为例，官方出了一个公告，说算法相关岗位投递简历特别多，而移动客户端方向很少，因此针对这个形势出了一个政策，每个移动客户端岗位的人工作满一年之后能拿到三个月的签字费，并且不要求有移动客户端开发经验，移动客户端今年应该算是个大年。</p><p>另外我听到过小道消息说美团也很缺，基本上没得挑，面试差不多的就给<code>offer</code>，后来跟我谈<code>offer</code>的<code>HR</code>感觉也基本证实了这个消息，她问我能不能提前去实习，一般回答了之后就不会再往下问了，但是她问得很细，能去几个月，大概什么时候，老师态度如何等等。</p><p>总之，今年移动客户端就业形势感觉还不错，另外今年互联网企业大部分都涨了工资，不过就业形势这个东西每一年都不一样，去年是算法大年，今年就是移动客户端大年，明年谁也说不好，不过万变不离其宗，只要基础扎实，并有一两个自己非常熟悉的项目找工作肯定没问题，无需害怕竞争。</p><hr><h2 id="我的工作准备"><a href="#我的工作准备" class="headerlink" title="我的工作准备"></a>我的工作准备</h2><p>前文提到了我上研究生的目的，自己计划在研究生阶段好好夯实基础学习技术，因此我准备的比较早。主要分几个方面：</p><ul><li>数据结构和算法</li><li>Java 基础，包括虚拟机相关</li><li>Android 基础和进阶</li><li>操作系统、网络等其他知识</li><li>实际项目</li><li>其他准备</li></ul><h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><p>我升研一的暑假开始系统性的学习数据结构和算法，刚开始花了很多时间看清华大学“邓俊辉”教授的《数据结构和算法》视频课程。这里推荐一下这个视频课程，给了我很大的帮助，讲的通俗易懂，学习期间我认真的做了笔记，同时看完视频之后还会自己用<code>Java</code>实现（视频课程是用<code>C++</code>实现的），不过对于一些很难的知识点理解起来较难，我就跳过了，比如“红黑树”、<code>KMP</code>和<code>BM</code>字符串搜索算法等，不过还是建议不要丢弃这些知识，因为这些坑在我笔试的时候就出现了。</p><p>看完这个视频之后数据结构算法的基础框架搭建起来了，后来买了一本《算法（第四版）》，这本书是《算法导论》作者的弟子<code>Robert Sedgewick</code>写的，浅显易懂，对于基础知识而言完全足够了，并且这本书是用<code>Java</code>实现的，这是我买这本书的一个很重要原因。</p><p>其实数据结构和算法无论怎么看书都是不够的，因为这些知识本来就是人类在实践中不断总结出来的经验，因此仍然需要在实践中去不断使用。</p><p>大体看完了《算法（第四版）》之后我就开始刷题。我选择的<code>OJ</code>平台是<code>Leetcode</code>，这上面的题目实践性较强，很多都是<code>Google</code>、<code>Facebook</code>和<code>Apple</code>等大公司的题目，更适合于找工作的方向。另外，这上面<code>discuss</code>系统做的很不错，除了题目的典型解法之外还可以在上面找到很多很<code>tricky</code>的解题方法，我每次看完别人的解法都会萌生出“还有这种操作？”的想法。</p><p>另外《剑指offer》这本书也是面试必备，里面有很多经典的题目，在秋招面试的时候碰到了好几次原题。这本书大概是 4 月底去北京出差的时候开始看，之后在牛客上在线刷题做完了大概<code>40+</code>题，后面的题目就是看了但是没有自己写过。不得不说<code>vivo</code>提前批<code>offer</code>真的给了我很大的动力，逼着我好好复习。</p><p>还有要提一下的地方是面试常有的手撕代码环节。为了解决这个大问题，我后期刷<code>OJ</code>的时候开始尝试不借助<code>IDE</code>而在网页上直接编程。写得多了会发现其实手撕代码并不是一个难以攻克的难关，之前多刷一些题，其实手撕代码和普通在线编程差不多。</p><h3 id="Java-amp-Android"><a href="#Java-amp-Android" class="headerlink" title="Java &amp; Android"></a>Java &amp; Android</h3><p><code>Java</code>基础知识主要是一些语言特性和内置的数据结构，比如<code>List</code>、<code>Map</code>、<code>Set</code>和反射等，相对而言这些比较简单，大概挑重点看了一下《Java 编程思想》这本书，其他的还看了一下线程池和并发相关，因为之后的项目用到了，所以着重看了一点。</p><p><code>Java</code>虚拟机部分主要看的是<strong>周志明</strong>的《深入 Java 虚拟机》这本书，不得不说这是市面上为数不多讲<code>Java</code>虚拟机讲的不错的书，我本科的时候大概浏览了一次，但是隔的时间久了很多知识都不记得了。另外本科的时候对于这本书的知识点并没有相关涉及，只是知道面试的时候会用上所以学一学。现在编程经验多了才知道这是个重点，现在很多技术都需要用到这些底层知识，比如“插件化”和“热修复”就需要对<strong>双亲加载模型</strong>有一定了解。</p><p><code>Android</code>基础相关主要回顾了一下<strong>郭霖</strong>大神的《第一行代码（第二版）》这本书，这本书很适合入门，第一版是我的安卓入门书。</p><p>当然<code>Android</code>只靠这些基础肯定是不够的，我另外也看了<strong>徐宜生</strong>的《Android 群英传》，这本书里有很多实际开发中使用的技巧，很适合于面试中的场景题，另外也有一些进阶的知识如“事件分发机制”和“View 的绘制过程”等。我大概花了 3 周的时间看完，当然只实践了其中少部分的内容，因为实践起来需要大量时间，而我还需要对其他的知识查缺补漏。另外，我后来发现<strong>任玉刚</strong>的《Android 开发艺术探索》简直是面试宝典，面试时候碰上的很多进阶问题都可以在这本书里看到相关阐述，可惜这个发现有点晚，面试晚期才开始读这本书，直到现在还没有看完。</p><h3 id="操作系统和网络"><a href="#操作系统和网络" class="headerlink" title="操作系统和网络"></a>操作系统和网络</h3><p>这部分知识准备如果要算的话得追溯到本科了，那时候特意选了“操作系统”这门课，至于网络方面则基本没怎么担心过，因为我是通信工程专业出身的，本身学科就是网络相关。不过准备肯定还是要有的，主要是看别人的总结，这里要感谢一下一本<code>Gitbook</code>的几个作者，链接在此<a href="https://legacy.gitbook.com/book/lrh1993/android_interview_guide/details" target="_blank" rel="noopener">Android 校招面试指南</a> 。这本书主要是面试问题集合，除了上述的操作系统知识之外还有很多设计模式和数据库相关，靠这本书我扛过了秋招，再次对几位作者表示感谢。</p><h3 id="实际项目"><a href="#实际项目" class="headerlink" title="实际项目"></a>实际项目</h3><p>对于研究生而言，项目是一个非常重要的因素。本科生接触项目的机会较少可以理解，但研究生就实验室而言就有项目可以做。但是我的情况很尴尬，实验室的项目和我的工作方向并不对口，因此我只能想想其他的项目。</p><p>其实手里头对口的项目不多，4 月份在校时期和别人一起做了一个<code>App</code>，好好复习了一下项目里用的东西，也大概看了一下另外一个同伴的代码，理出项目的大体框架还有大概的实现流程等。另外项目里用的知识点一定要熟悉，不然面试会被问的很惨。</p><h3 id="其他准备"><a href="#其他准备" class="headerlink" title="其他准备"></a>其他准备</h3><h4 id="简历"><a href="#简历" class="headerlink" title="简历"></a>简历</h4><p>我的简历前前后后修改了六七个版本，综合我自己的想法和很多人的建议。个人更喜欢简洁风，所以最后做出来的简历纯黑白，连照片都没有放上去。主要分为 5 各部分，包括个人信息、教育经历、技能清单、项目经历和获得奖励，我没有把我本科的实习经历放上去所以没有实习经历那一项。</p><p>但是简洁 ≠ 简单，我简历上一些着重点如获得的奖励会加粗，标题和内容大小等都有区别，校招简历该有的内容也没少，比如教育经历、技能清单、获得奖励等，当然大头还得是项目经历。项目经历使用<code>STAR</code>法则来描述</p><ul><li><code>S - situation</code>，事情在什么情况下发生的，也即项目背景</li><li><code>T - task</code>，有哪些任务，也即项目所承担的内容</li><li><code>A - action</code>，有哪些行动，也即如何完成任务的，碰到了什么困难，如何解决的</li><li><code>R - result</code>，结果如何，也即项目最终取得了什么成果</li></ul><p>我的简历项目经历部分一共写了三个项目，包括实验室的项目、比赛和校内<code>App</code>。其实我之前也很犹豫要不要放不相关的项目，咨询了一些前辈之后觉得这些项目其实也可以展示你的编程和学习能力，所以我也把他们写上去了。</p><p>简历建议的话不超过一页纸，贵精不在多，写上去的东西自己一定要熟悉，很多公司都是对着简历问的，另外简历一定要有粗有细，对于重点内容可以加粗，比如<code>App</code>的下载量或者拿到的奖项，对于自己很熟悉的东西也可以加粗以引导面试官进入对我们有利的情景中。这个技巧其实是女朋友教我的，在此感谢她一直的陪伴。</p><h4 id="个人独立博客"><a href="#个人独立博客" class="headerlink" title="个人独立博客"></a>个人独立博客</h4><p>个人独立博客算是我误打误撞做的准备。以前都觉得有博客的都是大神，会往上写一些高深的技术文章，现在想想其实是当时的眼界不够开放，把自己限制的很死，很多未知的事情不敢去尝试，后来在一位博士好友的催促下做了一个简陋的首页。万事开头难，做好了第一个页面之后就一直在弄博客的事情，到现在一年多时间一共有 <code>45</code>篇原创文章，平均一周多发一篇，数量不多，还需要继续加油。</p><p>个人认为独立博客内容是学习能力的一个体现，<code>I hear and I forget. I see and I remember. I do and I understand.</code>，只有输入没有输出的话很容易淡忘，多写写文章，无论是知识总结还是自己的新想法，这些都可以帮助对知识的进一步理解。同时博客也算是一个“日记”，可以记录平时开发中碰到的困难以及解决方法，以后职业生涯帮助也很大。</p><hr><h2 id="面试经历"><a href="#面试经历" class="headerlink" title="面试经历"></a>面试经历</h2><p>个人觉得，面试这个东西就是要多练，多去面试两家就不会怕了。看别人的面经用处最大在于了解这个岗位会问什么样的问题，别人碰到的面试官和面试体验给不了多大的参考价值。不如话虽如此，我还是写一点面试相关的经历，给自己留做纪念也好。</p><p>其实对于面经方面我也做了准备，秋招开始之前自己写了一个<code>markdown</code>文档用来记录各家公司的相关面试情况，包括投递进度和面试问题等等。另外我也自己在日历上会写计划好的日程，有序的整理给我省下了不少功夫。下面我大概写一下印象深刻的几家公司面试经历，至于面试问题我会在最后整理。</p><h3 id="vivo-提前批"><a href="#vivo-提前批" class="headerlink" title="vivo 提前批"></a>vivo 提前批</h3><p>这是我秋招参加的第一场面试，6 月 1 号笔试，6 月 8 号<code>vivo</code>就有人来了西安面试。一共两面，一轮技术 + 一轮 HR 面。第一次面试很紧张，不过<code>vivo</code>提前批居然出奇的简单，我身边的人基本都拿到了<code>offer</code>。</p><h4 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h4><p>技术面没有怎么具体问基础，大概问了问项目。感觉面试官应该是<code>leader</code>级别的人，以项目为入口，先是问了<code>Android</code>网络相关知识，比如有哪些网络请求库，各有什么优缺点，然后问了一些场景题，比如图片加载优化，网络请求优化。印象最深刻的一个问题是，假如<code>App</code>需要定时更新某一个文件，你会如何设计具体的实现？我最初给出的方法是选择半夜服务器压力较小的时候如凌晨 1 点进行更新，但是这样带来了一个新问题， 如果大量的客户端向服务器端发送网络请求，服务器必然会宕机，相当于一次<code>DDOS</code>攻击，针对这个新问题我给出的解决方法是某一个时间短随机某一个时间点发送请求，感觉这个回答面试官也不是很满意。总之<code>vivo</code>第一面考察的重点不是理论基础，而是项目经验和实际的解决问题能力。</p><p>本来觉得自己一面答的很烂，因为之前从来没有考虑过那种问题，都是临场想出来的解决方法，没想到居然通过了一面。面试完之后有个小姐姐把我带到了一个房间里等二面，房间里有一些人已经在等了，过了不到 10 分钟刚才那个小姐姐就带我去了二面。</p><h4 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h4><p>二面是<code>HR</code>面，第一次经历这种面试，不过问的问题都是很常规的问题，比如家庭情况，意向城市，爱好等等。提问环节我大概问了一下岗位和业务相关情况，一共聊了不到 20 分钟就结束了这次面试。</p><p>8 号现场面试，10 号去了线下答疑会，<code>vivo</code>提前批很有效率，给的薪资对于校招初期还没有见过世面的我来说还是挺多的，不过拒掉这个<code>offer</code>就是后话了。</p><p><code>vivo</code>提前批的<code>offer</code>对于我来说帮助确实很大，一方面提升了我秋招的自信心，另外一方面也逼迫我尽早复习和投递简历，因为它一开始要求我 8 月 15 号（后来改成了 8 月 30 号）之前要给答复，违约金 5000，大小周，我不是特别想签，而当时来看，只有疯狂投各大公司的提前批才能给自己留条后路。</p><h3 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h3><p>华为面试一般为两面，如果是<code>sp</code>的话会有三面以上不等。我今年参加了华为今年的软件精英挑战赛拿了奖，所以免去了笔试和第一轮技术面试，直接就是第二轮综合面试。</p><p>二面面试官是一个有点岁数的大佬，年龄目测 40+，一上来就给我巨大压力，这个岁数还呆在华为的，绝对是真·大佬级别的人，说不定一眼就看出来我是个渣。面试的问题基本没有基础，想来这种大佬应该很久没有做过一线了，整体而言有一点偏<code>HR</code>面，问的问题大概以下这些。</p><ul><li>家庭情况，经济情况</li><li>有没有碰到压力很大的时候，如何排解</li><li>有没有什么有趣或者难忘的经历</li><li>有什么技术方面的东西想跟我说一下</li><li>工作地点，实习经历，论文以及专利情况</li><li>谈了一下华为工作相关的东西</li></ul><p>感觉华为真的是玄学面试，就没怎么问过技术上的东西，都是让我自己介绍项目的东西，然后就是谈人生。面试完我估计<code>offer</code>应该没问题，因为我参加了华为的比赛还得了奖，另外宣讲会的时候华为说了今年会扩招，这都拿不到<code>offer</code>有点说不过去。但鉴于二面面试官给我很大压力，我的评分应该不会很高，没想到最后居然拿到了华为的<code>sp</code>，果然是玄学面试。</p><h3 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h3><p>头条今年简直秀，每周无间断的笔试和面试，任何时间参加都可以，笔试不过一直都有笔试的机会。投递头条的时间比较早，8 月 13 号我就在官网搞定了，不过笔试被安排在了 8 月 25 号。头条的笔试是真的很难，一共 5 道题，我才 A 了 0.7 道，可能是因为客户端比较缺，所以幸运的进入了面试。</p><p>之后面试被安排在了 9 月份，第一次面试的时候和网易的笔试冲突了，推到了下一周也就是 15 号。现在想想头条的面试其实中规中矩，没有问到特别难的东西，当然也有可能是面试官看出来我技术水平不高，没有问我很难的东西。</p><h4 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h4><p>因为我把面试日期推到了 15 号，而上一次的笔试相对于以前简单了很多，很多人都进入了面试，因此等了挺长的时间，约定的时间是 3 点，但实际上到 3 点半才开始一面。</p><p>一面相对而言问的很基础，但是因为忘了记录，所以问题很多都不记得了。一开始先问的一些<code>Java</code>基础，然后看我有安卓开发经验，所以也问了一下安卓相关的技术知识点，都不是很深。我本以为这样就完了，但毕竟是宇宙条，算法还是少不了的。面试官出的问题不难，实现两个字符串表示的大数相加。很快就写完了，但是我写太急出了点<code>bug</code>，把除数和余数弄反了，不过问题不是特别大，一面大概 30 分钟结束了。几分钟后收到 <code>HR</code>电话说一面过了等待二面。</p><h4 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h4><p>二面前面排了两个人，等了一个小时才轮到我面试。二面面试官看起来挺年轻的，技术实力感觉也挺强。问了以下这些问题：</p><ul><li>什么时候开始学 Android</li><li>TCP 三次握手和四次挥手，拥塞控制，校验</li><li>Linux 进程间通信方式有哪些，哪种最快</li><li>Https 流程相关</li><li>线程状态</li><li>抽象类和接口区别</li><li>深拷贝和浅拷贝区别</li><li>图片优化</li><li>RecyclerView 和 ListView 优化</li><li>电量优化，布局优化</li><li>图片加载库用的什么？如果自己设计图片加载库会考虑哪些东西？</li><li>LRU 原理</li><li>设计一个类微信首页的界面，如何实现（ViewPager + Fragement）</li><li>算法：剑指 offer 原题，每一行每一列都是升序，找数字</li></ul><p>最后算法题写的有点久，我一上来直接把剑指<code>offer</code>上的解法写出来了，面试官觉得还可以在优化，让我想想有什么其他的方法，最后在面试官提示下才想出来的方法，时间复杂度大概是<code>O(nlogm)</code>，也就是先找到目标所在行或者列，然后二分查找，最后面试了一个多小时才结束，面试官跟我说休息一下准备接下来的第三面。</p><p>面试完之后仔细想想才觉得面试官提供的方法好像有问题，貌似是面试官套路我？瞬间感觉自己要凉，但是面试官又说让我准备三面，迷迷糊糊的过了二面，面试完已经是晚上 6 点了。</p><p>等了几分钟<code>HR</code>打电话跟我说二面通过，我问她能不能先去吃个饭，帮我把面试时间推到 7 点。结果我刚到食堂买好晚饭就接到了另外一个<code>HR</code>的电话说让回去面试，面试官在线上等我，跟他说我已经出来吃饭了，约了 6 点 40 面试，但是考虑到面试官已经在线上了，我也就打包了饭菜回了宿舍，结果发现面试官也去吃晚饭了。。。</p><h4 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h4><p>7 点左右三面面试官终于出现，感觉是个<code>leader</code>级别的人，也很年轻。三面总体而言也是综合面，不怎么问技术细节，说个大概就可以。面试问题记录如下：<br>睿思项目分工</p><ul><li>网络，HTTP 相关</li><li>网络库区别</li><li>数据库（开源）有没有了解过</li><li>项目<code>crash</code>率有没有检测过</li><li>项目如何实现登陆</li><li>RecyclerView ListView 优化</li><li>华为比赛项目相关</li><li><code>FreeSwitch</code>项目相关</li><li>专业偏嵌入式，为什么选择安卓</li><li><code>JNI</code>了解么</li><li><code>Binder</code>机制`</li><li><code>Android</code>各版本特性</li><li>最近有了解过什么新开源库</li><li><code>MVP</code>和<code>MVC</code>模式的区别</li><li>项目如何使用<code>MVP</code>模式优化</li></ul><p>权力反转环节大概问了一下头条的部门大概情况，聊天还算愉快。之后<code>HR</code>给我打电话说两周内给结果。成功结束头条面试，一下午怼了三面，头昏脑胀。</p><p>头条拿到<code>offer</code>确实是意外，毕竟宇宙条那么难进，给的钱又多。</p><h3 id="大疆"><a href="#大疆" class="headerlink" title="大疆"></a>大疆</h3><p>大疆应该算是最让我纠结的公司了，给钱多，平台还行，未来发展也不错，大疆确实是一个不错的选择，唯一的缺点就是一个非互联网公司，有点可惜，以后有机会可以再试试。言归正传，大疆整体面试偏重于基础一些，会从项目里某一个知识点不断深入。大疆的<code>HR</code>和面试官给我的印象都很不错，一面和二面都是远程面试，三面是现场面。</p><h4 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h4><p>大疆的笔试难度太大了，整个实验室只有我收到了面试机会。一面是电话面试，听声音应该是两个面试官一起面试，问的东西特别广，从<code>Java``Android</code>到网络再到数据结构算法，甚至还问了未来三年的规划，面试完感觉大脑被掏空了。问题有这些：</p><ul><li>View 事件分发，三个方法，onIntercept方法true 和 false 返回的结果(true拦截，false继续传递)</li><li>自定义 View，获取自定义属性在哪里(构造方法里)，onLayout，onMeasure，onDraw作用</li><li>Looper和Handler关系(1:N)</li><li>图片不同目录下(drawble-hdpi,drawble-dpi)的区别</li><li>Activity 启动方式(standard,singleTask,singleTop,singleInstance)</li><li>Activity onStart和onResume方法区别，什么时候会出现onResume()-&gt;onPause()-&gt;onResume()（可见但不可交互，如有一个对话框），弹Toast会不会，切换到任务管理器是否会执行onStop()</li><li>单例模式有几种方式（饿汉式，懒汉式(多线程情况下需要注意双重判定加锁)）</li><li>synchronized修饰对象和方法有什么区别（锁不同）</li><li>Java里Map有哪些(HashTable，LinkedHashMap，ConcurrentHashMap，HashMap，TreeMap)，哪些是线程安全(concurreentHashMap,HashTable)，那些不是，HashMap底层实现（数组+链表，链表过长-&gt;红黑树）</li><li>IP和掩码关系</li><li>网络滑动窗口概念(TCP)</li><li>单向链表判环（双指针），如何找环入口，如果不用双指针该怎么判定（HashSet）</li><li>是否了解B+树</li><li>内存调度和换页算法概念，调度方式有哪些（FIFO,LRU,最佳替换OPT，时钟替换算法）</li><li>http了解么</li><li>项目如何实现登陆功能，具体细节等</li><li>深拷贝和浅拷贝，如何实现深拷贝(clone(),序列化等)</li><li>最近再看什么书，有什么收获，哪些方面短缺？</li><li>是否碰到OOM问题？哪些情况会出现OOM（图片和泄漏之外）</li><li>未来三年规划</li><li>其他offer</li><li>是否出来实习</li><li>大疆有了解么</li></ul><h4 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h4><p>对于一面而言还是比较有信心的，虽然有一些问题回答的很惨，但是大体应该还可以。大概等了一个多礼拜收到了二面通知，二面是视频面试，依旧是两个面试官，二面我就比较虚了，被问了很多不熟悉的地方，视频面试所以记录的问题不是很清楚了。</p><ul><li>数据库设计，比如书城，如何设计订单，图书，作者等</li><li>设计模式，在 Android 代码里应用</li><li>智力题，1001个人比赛，决出最终获胜者，需要比赛多少次（1000次）</li><li>给定两个排序数组，如何选出相等的 ID</li><li>画一个正方形，在每个手机上用尺子量长度一样，怎么设计。</li><li>了解大疆么，有哪些飞机，那些产品等等</li></ul><p>智力题居然没有答上来，明明很简单的。。。二面感觉答的不好，一上来怼了一题数据库的设计题，一脸蒙，数据库是我的弱项，基本没怎么看过，最后还是面试官放过了我，跳了这一题。另外对大疆的了解部分确实了解的不多，只知道大概的产品线。总体而言面试感觉很差，感觉应该挂了，没想到最后还是收到了三面的面试通知。</p><h4 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h4><p>三面面试在一个咖啡馆里，<code>HR</code>小姐姐还给面试者点了饮料，面试体验很棒。三面面试官应该是大佬级别的人，感觉一般三面这种技术面都不会问很深，更注重于综合能力。现场面试，问题都不是很记得了。</p><ul><li>自我介绍</li><li>手撕代码环节，一个无序数组，要求找出其中的最大或者最小 k 个数字。其实就是<code>top k</code>问题，可以用大顶堆或者小顶堆来实现，具体可以看<a href="https://kingsfish.github.io/2018/09/24/%E5%A0%86%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/">堆排序问题</a></li><li>项目大概的模块划分，大体的实现方式等等，这个聊了很久</li><li>未来的职业规划，想做的方向等</li></ul><p>手撕代码侥幸过关，回学校的时候跟别人讨论发现自己刚好把大顶堆和小顶堆弄反了，貌似面试官也没有在意，有这种思路就可以。</p><p>校招面试每个人体验都会不一样，不同的面试官，不同的<code>HR</code>都会是不一样的感受，这部分参考价值不大，重要的还是面试问题总结，这部分这本书<a href="https://legacy.gitbook.com/book/lrh1993/android_interview_guide/details" target="_blank" rel="noopener">Android 校招面试指南</a>总结的已经很全面了，在此我不再赘述。</p><hr><h2 id="书单"><a href="#书单" class="headerlink" title="书单"></a>书单</h2><p>在此也跟风列一下书单吧，里面大部分书我看过，有一部分是经典书籍，值得一看。</p><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul><li>Head First Java</li><li>Java 核心技术（卷 1 / 卷 2）</li><li>阿里巴巴 Java 开发手册（电子书，2017 年 2 月 9 号发布，主要内容是 Java 开发规范）</li></ul><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><ul><li>Java 编程思想</li><li>Effective Java</li><li>深入理解 Java 虚拟机</li><li>码出高效：Java 开发手册（2018 年 9 月 22 号阿里巴巴云栖大会正式发布）</li></ul><h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><ul><li>第一行代码（第二版）</li></ul><h4 id="进阶-1"><a href="#进阶-1" class="headerlink" title="进阶"></a>进阶</h4><ul><li>Android 群英传</li><li>Android 开发艺术探索</li><li>Android 系统源代码情景分析（这本我还没看）</li><li>高性能 Android 应用开发（很多优化的知识点和实践，值得一看）</li><li>打造高质量 Android 应用（内容主要是优化和实用技巧，不过有点老了）</li></ul><h3 id="数据结构和算法-1"><a href="#数据结构和算法-1" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><ul><li>数据结构 475 讲（清华大学邓俊辉）</li><li>算法（第 4 版）</li><li>Leetcode</li><li>剑指 offer</li><li>牛客网</li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>大话设计模式</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>编程珠玑</li><li>重构 - 改善既有代码的设计</li><li>编程之美</li><li><a href="https://legacy.gitbook.com/book/lrh1993/android_interview_guide/details" target="_blank" rel="noopener">Android 校招面试指南</a>（一本非常全的面经，在我求职过程中发挥了巨大作用，再次感谢几位作者）</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="个人感想"><a href="#个人感想" class="headerlink" title="个人感想"></a>个人感想</h3><p>秋招如果从<code>vivo</code>提前批开始算起进行了几个月，现在终于落下了帷幕。现在看来其实自己已经很幸运了，前期拿了<code>offer</code>稳定心态，后期几个有意向的<code>offer</code>都差不多同一时间出来薪资，并且<code>offer</code>给的薪资都很不错，虽然最后选择的时候很苦恼，尤其是大疆的<code>offer</code>，找了我好几次，但是没办法，只能优中选合适，最后还是选择了头条。</p><p>秋招其实有点像备考，基础知识点就那些，好好复习肯定面试不会差，感觉大厂很多都重视基础。项目部分如果没有项目的话可以看看网上的项目实战课程，比如慕课网，把项目吃透也可以。其实在面试官看来如果不是大厂项目都差不多，主要看你在项目中体现的综合能力，比如碰到了难题如何解决，整体框架等等。</p><p>秋招的时候心态最重要，保持一个好心态，无论面试成功或者失败。比如贝壳面试面试的时候，当时已经有大疆的<code>offer</code>了，然而一面直接挂，搞得我差点怀疑人生，瞬间想签了大疆完事，下午的百度一面不去了。但是最后还是好好想了想，面试除了实力之外也有运气，运气不好的时候挂了也很正常，所幸没有放弃，最后百度还拿到了<code>offer</code>。另外一定要放松心态，9 月份电话不断，我差点都有电话恐惧症了，一震动就神经紧张。</p><p>面试其实也是一个查缺补漏的过程，在面试中不断发现之前没有了解的知识，总结经验迎接下一次面试。美团曾经问过我某一个项目里的不足点如何改进，我当时没有什么特别好的想法，最后面试官给了他的建议，我自己面试完也好好思考了一下，后来头条面试的时候也问到了同样的问题，我就能自信满满的给出答案。</p><p>秋招是一个艰难抉择的过程，笔试冲突了、面试冲突了、<code>offer</code>如何选择都会让人很痛苦。所以个人建议一开始就想好自己的方向，能不海投尽量不要海投，海投非常消耗精力，另外万一拿到<code>offer</code>，选择更是一个艰难的问题。我就纠结于是否选择大疆 10 多天，期间<code>HR</code>小姐姐几次找我，我未来的大疆导师跟我也聊了很久，大疆的平台和薪资都很不错，让我不忍心拒绝，但是最终还是放弃了大疆，做选择的时候实在是太痛苦了。</p><p>总的来说，秋招还是很充实的，每天面试笔试，经过秋招也学到了挺多东西，不枉花了那么多时间，很特别的一段经历。</p><h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><p>这里根据我个人的经历给一点建议吧，一家之言，大家看看就好。</p><ol><li>早作准备，优势很大。很多提前批免笔试，直接面试能省很多力气，另外提前批<code>hc</code>数量较多，岗位和部门选择空间也更大。同时也要关注各大公司校招网申笔试等时间点，提前批次挂的话一般还会有正式批次，不过也要注意，提前批次肯定会有面试记录，因此会对正式批次有一定参考价值。</li><li>如果有时间实习一定要去实习，大厂的最好。其实这也是早作准备的原因之一，实习生招聘一般研二或者大三下学期开始，这就意味着这个时候就需要有一定的基础实力，有实习经历能给秋招非常大的助力。</li><li>投简历之前好好想想自己想要从事的行业，不要乱投，到时候不仅浪费自己时间也浪费别人时间。不过面试经验还是要攒的，可以先投一些小公司试试，之后再来面大厂，千万不要把自己的第一次献给大厂。</li><li>面试一定做好规划，做好总结。我用<code>markdown</code>文件记录了我整个秋招的经历，每次面试回来都会回顾一下没有回答上来的问题或者是自己不是很理解的地方，每一次面试都是为下一次做准备。</li></ol><p>祝师弟师妹们未来拿到好<code>offer</code>。</p><hr><p>秋招终于结束，接下来就是好好写专利和论文了。不过<code>offer</code>不是结束只是一个新的开始，新的征程即将拉开帷幕，还是要继续加油。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;经过几个月的努力，基本上拿到了满意的&lt;code&gt;offer&lt;/code&gt;，一直奔波在求职路上，现在终于能好好的停下来总结这段经历。&lt;/p&gt;

      
    
    </summary>
    
      <category term="求职路上" scheme="https://KingsFish.github.io/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A/"/>
    
    
      <category term="面经" scheme="https://KingsFish.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="Android" scheme="https://KingsFish.github.io/tags/Android/"/>
    
      <category term="秋招" scheme="https://KingsFish.github.io/tags/%E7%A7%8B%E6%8B%9B/"/>
    
  </entry>
  
  <entry>
    <title>堆排序问题</title>
    <link href="https://KingsFish.github.io/2018/09/24/%E5%A0%86%E6%8E%92%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
    <id>https://KingsFish.github.io/2018/09/24/堆排序问题/</id>
    <published>2018-09-24T01:20:03.000Z</published>
    <updated>2019-06-14T14:54:54.979Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>中秋了也要发博客，写完我就出去浪，祝大家中秋快乐~</p></blockquote><p>堆排序问题算是面试中的高频问题了，这个知识点作为基础排序算法会被问，另外还可以继续延伸，比如<code>Top K</code>问题和实现优先队列。百度面试的时候就让实现优先队列，然而当时紧张没有写出来，其实还是很简单的。</p><h3 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h3><p>堆是一种数据结构，类似于完全二叉树，但一般使用数组作为堆的实现。堆分为大顶堆和小顶堆，大顶堆指父节点的值大于两个孩子节点的值，这样根节点的值必定为整个堆的最大值，因此称为大顶堆；与此相反，小顶堆指父节点的值小于两个孩子节点的值，这样根节点的值必定为整个堆的最小值，因此称为小顶堆。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="heap.jpg" alt="大顶堆和小顶堆" title>                </div>                <div class="image-caption">大顶堆和小顶堆</div>            </figure><h3 id="主要操作"><a href="#主要操作" class="headerlink" title="主要操作"></a>主要操作</h3><table><thead><tr><th align="center">方法</th><th align="center">作用</th><th align="center">时间复杂度</th></tr></thead><tbody><tr><td align="center">get</td><td align="center">取得堆顶值</td><td align="center">O(1)</td></tr><tr><td align="center">sink</td><td align="center">将元素下沉，恢复堆有序性</td><td align="center">O(logn)</td></tr><tr><td align="center">delete</td><td align="center">删除并取得顶堆值</td><td align="center">O(logn)</td></tr><tr><td align="center">build</td><td align="center">建堆</td><td align="center">O(n)</td></tr></tbody></table><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>这里以大顶堆作为例子，小顶堆其实类似，只不过下沉操作的时候比较大小时更换一下即可。</p><h4 id="下沉操作"><a href="#下沉操作" class="headerlink" title="下沉操作"></a>下沉操作</h4><p>这是堆排序中最重要的操作，它保证了堆的有序性，建堆和删除堆顶值的时候都需要调用这个操作。</p><p>下沉操作主要是让当前节点和两个子节点进行比较，如果父节点比子节点小，则将这两个节点互换，重复这个操作直至父节点比子节点大。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下沉操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> [] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; end) &#123;</span><br><span class="line">        <span class="comment">// 得到子节点位置</span></span><br><span class="line">        <span class="keyword">int</span> child = child(i); </span><br><span class="line">        <span class="keyword">if</span> (child &lt; end) &#123;</span><br><span class="line">            <span class="comment">// 如果左节点的值小于有节点，则替换右节点的值</span></span><br><span class="line">            <span class="keyword">if</span> ((child + <span class="number">1</span> &lt; end) &amp;&amp; nums[child] &lt; nums[child + <span class="number">1</span>]) &#123;</span><br><span class="line">                child ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[child]) &#123;</span><br><span class="line">                swap(nums, i, child);</span><br><span class="line">                i = child;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取子节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">child</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个节点值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> [] nums, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="建堆过程"><a href="#建堆过程" class="headerlink" title="建堆过程"></a>建堆过程</h4><p>建堆其实就是不断调用<code>sink</code>下沉的过程，给定初始的数组，只需要从最后一个数字开始往前不断进行下沉操作即可，类似于一个递推的过程，不断的将新元素插入到原先已经建好堆的后方数组中。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(<span class="keyword">int</span> [] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">        <span class="comment">// 从后面开始不断进行下沉操作</span></span><br><span class="line">        sink(nums, i, nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取堆顶值"><a href="#获取堆顶值" class="headerlink" title="获取堆顶值"></a>获取堆顶值</h4><p>此时数组第一位为堆顶值，最大，直接返回即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 堆顶值最大</span></span><br><span class="line">    <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="移除堆顶值"><a href="#移除堆顶值" class="headerlink" title="移除堆顶值"></a>移除堆顶值</h4><p>移除数组第一位，并将数组最后一个数移到堆顶，并执行下沉操作即可保持堆有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">delMax</span><span class="params">(<span class="keyword">int</span> [] nums, <span class="keyword">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = nums[<span class="number">0</span>];</span><br><span class="line">    swap(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    sink(nums, <span class="number">0</span>, len - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题扩展"><a href="#问题扩展" class="headerlink" title="问题扩展"></a>问题扩展</h3><h4 id="Top-K-问题"><a href="#Top-K-问题" class="headerlink" title="Top K 问题"></a>Top K 问题</h4><p><code>Top K</code>问题是堆排序的扩展，一般问题描述如下：</p><blockquote><p>给定一个数组，求出最小/最大的 K 个数</p></blockquote><p>这个问题最简单的解决方法就是排序，时间复杂度最优是<code>O(nlogn)</code>，此法不是本文重点，不在此详细说明。这个问题用堆可以很容易的解决，最小 K 个数可以使用大顶堆，最大 K 个数可以使用小顶堆，本文示例使用大顶堆解决最小 K 个数问题。</p><p>解法思路如下 ：</p><ol><li>创建一个大小为 K 的数组 B，并初始化数值为<code>Integer.MAX_VALUE</code>（小顶堆则初始化为<code>Integer.MIN_VALUE</code>）</li><li>遍历给定的数组 A，对于每一个数 C，将其跟 B 的堆顶进行比较，如果比堆顶小，则将 B 的堆顶值替换成 C，然后执行下沉操作。遍历完成之后 B 数组即为所求的数字。</li></ol><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> [] topK(<span class="keyword">int</span> [] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &gt; nums.length) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"k:"</span> + k + <span class="string">", length:"</span> + nums.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// min k</span></span><br><span class="line">    <span class="keyword">int</span> [] top = <span class="keyword">new</span> <span class="keyword">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; top.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 初始化值</span></span><br><span class="line">        top[i] = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; top[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="comment">// 如果比堆顶值小，则替换堆顶并执行下沉操作</span></span><br><span class="line">            top[<span class="number">0</span>] = nums[i];</span><br><span class="line">            sink(top, <span class="number">0</span>, top.length);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>优先队列在队列调度的时候用的很多，主要实现一个需求，往优先队列中无序放入优先级不同的任务，要求随时能取出优先级最高的任务。使用大顶堆堆可以很好的满足这个要求。大顶堆能维持顶堆的优先级最高，随时能够取出该任务。</p><p>主要<code>API</code>如下：</p><table><thead><tr><th align="center">方法</th><th align="center">作用</th><th align="center">时间复杂度</th></tr></thead><tbody><tr><td align="center">poll</td><td align="center">取出优先级最高的任务</td><td align="center">O(logn)</td></tr><tr><td align="center">offer</td><td align="center">增加一个任务</td><td align="center">O(logn)</td></tr><tr><td align="center">isEmpty</td><td align="center">查询队列是否为空</td><td align="center">O(1)</td></tr><tr><td align="center">getSize</td><td align="center">查询队列大小</td><td align="center">O(1)</td></tr><tr><td align="center">clear</td><td align="center">清空队列</td><td align="center">O(1)</td></tr></tbody></table><p>与上述<code>Top K</code>问题不同的是，优先队列需要增加一个上浮操作。对于新加入的任务，需要执行该操作来维持堆的有序性。</p><p>解决思路如下：</p><ol><li><code>poll</code>的实现堆已经实现过了，参考上文</li><li><code>offer</code>的实现需要使用上浮操作，将新元素增加到队尾，然后执行上浮操作即可保持堆有序性</li><li><code>isEmpty</code>的实现可以通过保存队列当前元素数量来实现</li></ol><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span>&lt;<span class="title">T</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_COMPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> compacity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> T [] ts;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 默认容量10</span></span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_COMPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> com)</span></span>&#123;</span><br><span class="line">        compacity = com;</span><br><span class="line">        ts = <span class="keyword">new</span> T[compacity];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 取数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">poll</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">// 交换队首以及最后的数据，然后执行下沉操作保证堆有序</span></span><br><span class="line">        T t = ts[<span class="number">0</span>];</span><br><span class="line">        swap(ts, <span class="number">0</span>, size - <span class="number">1</span>);</span><br><span class="line">        size --;</span><br><span class="line">        sink(ts, <span class="number">0</span>, size + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 增加数据</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size &gt;= compacity) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将新数据添加到队尾，并执行上浮操作保证堆有序</span></span><br><span class="line">        size ++;</span><br><span class="line">        ts[size - <span class="number">1</span>] = t;</span><br><span class="line">        up(size - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sink</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 见上方</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">up</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 不断将当前节点与父节点对比直到比父节点小</span></span><br><span class="line">            <span class="keyword">int</span> parent = i / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(ts[i].compareTo(ts[parent] &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">                swap(ts, i, parent);</span><br><span class="line">                i = i / <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        ts = <span class="keyword">new</span> T[compacity];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>堆排序问题终于写完，该出去浪了~</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;中秋了也要发博客，写完我就出去浪，祝大家中秋快乐~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;堆排序问题算是面试中的高频问题了，这个知识点作为基础排序算法会被问，另外还可以继续延伸，比如&lt;code&gt;Top K&lt;/code&gt;问题和实现优先队列。百度面
      
    
    </summary>
    
      <category term="数据结构和算法" scheme="https://KingsFish.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="Algorithm" scheme="https://KingsFish.github.io/tags/Algorithm/"/>
    
      <category term="Heap" scheme="https://KingsFish.github.io/tags/Heap/"/>
    
  </entry>
  
  <entry>
    <title>大疆Android面经</title>
    <link href="https://KingsFish.github.io/2018/08/17/%E5%A4%A7%E7%96%86Android%E9%9D%A2%E7%BB%8F/"/>
    <id>https://KingsFish.github.io/2018/08/17/大疆Android面经/</id>
    <published>2018-08-17T01:20:03.000Z</published>
    <updated>2019-06-14T14:54:54.995Z</updated>
    
    <content type="html"><![CDATA[<p>大疆是我正儿八经面试的第二家公司，第一家是 <code>oppo</code> 提前批，一面就被刷了，惨不忍睹。。。</p><p>大疆今年实在是太早了，6 月末截至投递简历，战线拉得很长，这一个多月都在忙活面试和笔试。笔试是 7 月 5 号做的，之后一直等消息，等了 20 多天，7 月 24 号收到了一面通知。</p><p>一面是个电话面试，悄悄的录了音，问了这些问题：</p><ul><li><code>View</code> 事件分发，三个方法，<code>onIntercept</code>方法<code>true</code> 和 <code>false</code> 返回的结果(true拦截，false继续传递)</li><li>自定义 <code>View</code>，获取自定义属性在哪里(构造方法里)，<code>onLayout</code>，<code>onMeasure</code>，<code>onDraw</code>作用</li><li><code>Looper</code>和<code>Handler</code>关系(<code>1:N</code>)</li><li>图片不同目录下(<code>drawble-hdpi</code>,<code>drawble-ldpi</code>)的区别</li><li><code>Activity</code> 启动方式(<code>standard</code>,<code>singleTask</code>,<code>singleTop</code>,<code>singleInstance</code>)</li><li><code>Activity</code> 中<code>onStart</code>和<code>onResume</code>方法区别，什么时候会出现<code>onResume()-&gt;onPause()-&gt;onResume()</code>（可见但不可交互，如有一个对话框），弹<code>Toast</code>会不会，切换到任务管理器是否会执行<code>onStop()</code></li><li>单例模式有几种方式（饿汉式，懒汉式(多线程情况下需要注意双重判定加锁)）</li><li><code>synchronized</code>修饰对象和方法有什么区别（锁不同）</li><li><code>Java</code>里<code>Map</code>有哪些(<code>HashTable</code>，<code>LinkedHashMap</code>，<code>ConcurrentHashMap</code>，<code>HashMap</code>，<code>TreeMap</code>)，哪些是线程安全(<code>ConcurrentHashMap</code>,<code>HashTable</code>)，那些不是，<code>HashMap</code>底层实现（数组+链表，链表过长-&gt;红黑树）</li><li><code>IP</code>和掩码关系</li><li>网络滑动窗口概念(<code>TCP</code>)</li><li>单向链表判环（双指针），如何找环入口，如果不用双指针该怎么判定（<code>HashSet</code>）</li><li>是否了解<code>B+</code>树</li><li>内存调度和换页算法概念，调度方式有哪些（<code>FIFO</code>,<code>LRU</code>,最佳替换<code>OPT</code>，时钟替换算法）</li><li><code>http</code>了解么</li><li>论坛项目登陆保存的 <code>formhash</code>，有效期等</li><li>深拷贝和浅拷贝，如何实现深拷贝(<code>clone()</code>,序列化等)</li><li>最近再看什么书，有什么收获，哪些方面短缺？</li><li>是否碰到<code>OOM</code>问题？哪些情况会出现<code>OOM</code>（图片和泄漏之外）</li><li>未来三年规划</li><li>其他<code>offer</code></li><li>是否出来实习</li><li>大疆有了解么</li><li>有什么想问我的么</li></ul><p>一面问的实在是太广了，<code>Java</code>，<code>Android</code>，<code>TCP/IP</code>，算法，操作系统、网络等都有涉猎。听声音大概有两个面试官一起面试，车轮战，问的很多都是基础，考察广度比较多一些。</p><p>侥幸通过一面，7 月 31 号约了视频二面，发现二面又是两个面试官轮番上阵，大疆这么流行压力面的么？主要问了这些问题：</p><ul><li>数据库设计，比如书城，如何设计订单，图书，作者等</li><li>设计模式，在<code>Android</code> 代码里有哪些应用</li><li>智力题，<code>1001</code>个人比赛，决出最终获胜者，需要比赛多少次（<code>1000</code>次）</li><li>给定两个排序数组，如何选出相等的 <code>ID</code></li><li>画一个正方形，在每个手机上用尺子量长度一样，怎么设计。</li><li>了解大疆么，有哪些无人机，那些产品，等等</li><li>有什么想问我的么</li></ul><p>二面面试官有一个应该是做后台的，一上来直接怼我数据库，给定场景问我数据库设计的问题，一下子问到了我知识的盲点。。。</p><p>总的来说，二面还是问的基础，感觉对项目并不感兴趣，有一些细节的东西还需要注意。</p><p>本来感觉二面已凉，很多问题都没回答上来，结果居然给了终面通知，去某一个交流群里问了一下发现二面通过率很高，捡了个便宜，尽管这也意味着终面竞争压力很大。</p><p>终面是个现场面，8 月 16 号约在一个咖啡馆里面试，HR 小姐姐还给每一个面试者点了喝的，面了 30 分钟左右，体验良好。大概问了这些问题：</p><ul><li>一堆无序数组，求最大10个数，用小顶堆蒙混过关了</li><li>项目有哪些模块，具体怎么做。问的不深</li><li>大概问了一下以后想要做的方向</li><li>有什么想问我的么</li></ul><p>面试官感觉是个主管 <code>leader</code> 之类的，性子很急，一上来就让我手撕代码，最后蒙混过关，面试基本都是技术问题，没有谈人生，也没有谈理想。中途居然看见两个做 <code>Android</code> 的妹子来面试，少见的很。</p><p>终面除了手撕代码有难度之外，其他的都还好。</p><p>大疆的面试终于告一段落，战线拉了两个月，耗时耗心力，但愿能有个好结果。秋招之路刚刚开始，继续加油！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;大疆是我正儿八经面试的第二家公司，第一家是 &lt;code&gt;oppo&lt;/code&gt; 提前批，一面就被刷了，惨不忍睹。。。&lt;/p&gt;
&lt;p&gt;大疆今年实在是太早了，6 月末截至投递简历，战线拉得很长，这一个多月都在忙活面试和笔试。笔试是 7 月 5 号做的，之后一直等消息，等了 20
      
    
    </summary>
    
      <category term="求职路上" scheme="https://KingsFish.github.io/categories/%E6%B1%82%E8%81%8C%E8%B7%AF%E4%B8%8A/"/>
    
    
      <category term="面经" scheme="https://KingsFish.github.io/tags/%E9%9D%A2%E7%BB%8F/"/>
    
      <category term="Android" scheme="https://KingsFish.github.io/tags/Android/"/>
    
      <category term="大疆" scheme="https://KingsFish.github.io/tags/%E5%A4%A7%E7%96%86/"/>
    
  </entry>
  
  <entry>
    <title>Android 事件分发机制</title>
    <link href="https://KingsFish.github.io/2018/07/28/Android-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6/"/>
    <id>https://KingsFish.github.io/2018/07/28/Android-事件分发机制/</id>
    <published>2018-07-28T10:14:04.000Z</published>
    <updated>2019-06-14T14:54:54.854Z</updated>
    
    <content type="html"><![CDATA[<p><code>Android</code> 事件分发机制一直来说都是一个比较难理解的知识内容，恰逢秋招，花了几天时间学习了一下，终于弄懂了是怎么回事，总结如下：</p><h3 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h3><p>事件分发机制主要有三个方法：</p><ul><li><code>dispatchTouchEvent()</code>，主要用于事件分发给子控件</li><li><code>onIntercptTouchEvent()</code>，主要用于是否拦截事件，<code>ViewGroup</code> 独有</li><li><code>onTouchEvent()</code>方法，主要用于处理触摸事件</li></ul><h3 id="分发机制"><a href="#分发机制" class="headerlink" title="分发机制"></a>分发机制</h3><p>当屏幕某一个控件被点击时，首先触发顶层布局的<code>dispatchTouchEvent()</code>方法，将事件进行向下传递，如果该布局是<code>ViewGroup</code>，则会先调用<code>onInterceptTouchEvent()</code>方法确定是否拦截该事件，如果返回<code>true</code>，则表示拦截该事件，不再往下传递，并调用自己的<code>onTouch()</code>方法进行事件处理，否则分发给子控件如此循环。直至有子控件消费此事件。流程图如下，假设目前有三层布局，<code>Activity -&gt; LinearLayout -&gt; Button</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="3.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>下图是分发业务流程图</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="1.png" alt title>                </div>                <div class="image-caption"></div>            </figure><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>上图我刚开始看的时候也看不懂，下面从代码层面分析，根据具体情况分为多种情况，整个调用过程存在递归，先由上层往下分发事件，然后根据上层根据下层返回的数据进行处理，直至分发过程结束：</p><ol><li><p><code>Activity</code> 接收到点击事件，首先进行分发，调用<code>dispatchTouchEvent()</code>，在这个函数里面，会进行事件的分发，调用子控件也即<code>LinearLayout</code>的<code>dispatchTouchEvent()</code>方法，根据<code>LinearLayout</code>的<code>dispatchTouchEvent()</code>的返回值进行判定，会有两种结果:</p><ol><li><p>如果返回<code>true</code>，则表示子控件已经把事件消费掉了，则<code>Activity</code>的 <code>dispatchTouchEvent</code> 方法也返回 <code>true</code>，代表已经处理了这个点击事件，事件分发过程结束。</p></li><li><p>如果返回<code>false</code>，则表示子控件并没有把事件消费掉，则 <code>Activity</code>会调用自己的 <code>onTouchEvent()</code>方法进行时间处理，一般来说我们不会覆写修改<code>Activity</code> 的 <code>onTouchEvent()</code> 方法，该方法默认返回<code>false</code>，事件分发结束。</p></li></ol></li><li><p>那么在 <code>LinearLayout</code> 的<code>dispatchTouchEvent()</code> 方法里什么时候会返回<code>true</code>，什么时候会返回 <code>false</code> 呢？与 <code>Activity</code> 有所不同的的是，<code>LinearLayout</code> 是一个 <code>ViewGroup</code>，多了一个 <code>onInterceptTouchEvent()</code> 方法，<code>LinearLayout</code> 会先调用 <code>onInterceptTouchEvent()</code> 方法决定是否直接拦截事件，会有两种情况：</p><ol><li><code>onInterceptTouchEvent()</code> 返回 <code>true</code>。那么 <code>LinearLayout</code>不会像<code>Activity</code> 一样无条件向下传递事件，而是直接拦截触摸事件，然后调用自己的 <code>onTouchEvent()</code> 方法，<code>LinearLayout</code> 的<code>dispatchTouchEvent()</code> 方法返回值取决于 <code>onTouchEvent()</code> 的返回值</li><li><code>onInterceptTouchEvent()</code> 返回<code>false</code>，表示 <code>LinearLayout</code> 不拦截事件，会正常往下传递事件，在此例子中将会调用 <code>Button</code> 的 <code>dispatchTouchEvent()</code> 方法。<code>Button</code> 的 <code>dispatchTouchEvent()</code> 方法返回值也有两种：<ol><li>返回<code>true</code>。那么 <code>LinearLayout</code> 的 <code>dispatchTouchEvent()</code> 将直接结束，返回<code>true</code>，继续走<code>Acticty</code> 的 <code>1.1</code> 流程。</li><li>返回<code>false</code>。那么<code>LinearLayout</code> 会调用自己的<code>onTouchEvent()</code> 方法。和 <code>Activity</code> 类似，一般我们不会覆写这个方法，这个方法默认返回 <code>false</code>，那么接下来继续走 <code>Activity</code> 的<code>1.2</code>流程。</li></ol></li></ol></li><li><p>那么<code>Button</code> 的<code>dispatchTouchEvent()</code> 方法里什么时候会返回<code>true</code>，什么时候会返回<code>false</code> 呢？与<code>LinearLayout</code> 不同，<code>Button</code> 不是<code>ViewGroup</code> 而是 <code>View</code>，只有<code>dispatchTouchEvent()</code> 和 <code>onTouchEvent</code> 方法，但是<code>Button</code> 作为 <code>View</code> 比较特殊，还拥有一个方法<code>onTouch()</code>，<code>Button</code> 的<code>dispatchTouchEvent()</code>方法流程如下。首先检查<code>Button</code> 是否设定了触摸事件，也即<code>onTouchListener</code> 是否为空，结果有两种：</p><ol><li>设定了触摸事件，则执行 <code>onToucheListener</code> 的<code>onTouch</code> 方法，<code>Button</code> 的 <code>dispatchTouchEvent</code> 方法直接返回 <code>true</code>，走<code>LinearLayout</code> 的<code>2.2.1</code> 流程</li><li>未设定触摸事件，则执行<code>Button</code>的<code>onTouchEvent</code> 方法，根据 <code>onTouch</code> 方法返回值返回，如果是<code>true</code>，则 <code>Button</code> 的 <code>dispatchTouchEvent</code> 方法结束，走 <code>LinearLayout</code> 的 <code>2.2.2</code> 流程</li></ol></li></ol><p>使用伪代码的流程图如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="2.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>当然，这个伪代码只是一个非常简略的版本，在实际的源码中，还有很多判定等条件和函数的具体实现，但是大体的流程就这以上这些。</p><h3 id="额外知识"><a href="#额外知识" class="headerlink" title="额外知识"></a>额外知识</h3><p>此外还有一些其他的知识：</p><ol><li><code>onTouch</code>方法调用时间先于<code>onTouchEvent</code></li><li>如果子 <code>View</code>不想让父控件拦截事件怎么办？可以在子类中调用<code>requestDisallowInterceptTouchEvent</code>方法来请求事件的直接下发</li><li>如果某控件<code>onTouchEvent</code>方法对<code>DOWN</code>事件返回了 <code>false</code>，也即不对<code>DOWN</code>事件进行处理，那么之后的<code>UP</code>和<code>MOVE</code>事件都不会下发给该控件。这也符合一般常识，如果一个控件对于手指触摸屏幕事件没有反应，那么对于接下来的手指移动和手指抬起的事件也应当无反应。</li><li>从 3 的另一个方向思考，如果某控件的<code>onTouchEvent</code>对于<code>DOWN</code>事件返回了<code>true</code>，也即消费了该事件，那么接下来的事件都会自己处理，不会下发给子控件。</li><li>如果上一次 <code>Button</code> 消费了<code>DOWN</code>事件，而之后来了一个<code>MOVE</code>事件被<code>LinearLayout</code>拦截了，那么会给<code>Button</code>传递一个<code>CANCEL</code>事件</li></ol><hr><p>最近秋招大潮来临，各种公司内推电话面，每一次都感觉自己还是个渣，被问了很多不知道的东西，每一次面试都是查缺补漏，加油！预祝自己能找个好工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;Android&lt;/code&gt; 事件分发机制一直来说都是一个比较难理解的知识内容，恰逢秋招，花了几天时间学习了一下，终于弄懂了是怎么回事，总结如下：&lt;/p&gt;
&lt;h3 id=&quot;核心方法&quot;&gt;&lt;a href=&quot;#核心方法&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Android" scheme="https://KingsFish.github.io/categories/Android/"/>
    
    
      <category term="事件分发" scheme="https://KingsFish.github.io/tags/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>一周年生日快乐</title>
    <link href="https://KingsFish.github.io/2018/07/13/%E4%B8%80%E5%91%A8%E5%B9%B4%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/"/>
    <id>https://KingsFish.github.io/2018/07/13/一周年生日快乐/</id>
    <published>2018-07-13T02:41:07.000Z</published>
    <updated>2019-06-14T14:54:54.948Z</updated>
    
    <content type="html"><![CDATA[<p>兜兜转转又是一年，去年这个时候看到糊涂博士在骑行群里分享他的博客，觉得很高大上，于是夸下海口，跟糊涂博士说等我期末考试完了也搞个自己的博客，互设友链。</p><p>结果还是自己懒，考完试根本没动静，那时候觉得有个自己的博客是一个技术水平特别高的事情，自己做不来。最后在糊涂博士的催促下才用 <code>Github Pages</code> 匆忙做了个博客，刚开始只有一个页面，还是抄袭别人的，什么内容都没有，大笔一书，网站建设中，留下了一个联系方式和友链。不过好歹也有了个样子，万事开头难，开头做好了，剩下的只剩坚持了。</p><p>其实之前还想自己做个站，刚好手里有一个 <code>vps</code>，但后来一看搭 <code>LNMP</code> 环境太麻烦了，自己懂的前端后端知识又不是很多，只是想安安静静写博客而已，最后选择了 <code>Github Pages</code>，省心省力。</p><p>我记得「宽带无线通信」老师说过这么一句话，*<em><code>I hear and I forget. I see and I remember. I do and I understand.</code> *</em>没有输出，学的容易忘。多写博客，多总结，知识理解的更深，以后找工作复习的时候也能用上。</p><p>这一年来虽然不怎么勤奋，也写了不少博客，没有荒废自己的学习。虽然一年前定的目标现在没有实现多少，但做了总比不做好。马上就要研三了，现在已经拿到了 <code>vivo</code> 的 <code>offer</code>。虽然不是 <code>sp</code>，但是画的大饼还是不错的（大雾）。秋招也才刚刚开始，还有大把机会。</p><p>最近出差两次，已经很久没去健身了，也许找到工作之后会继续天天去吧。</p><p>逝者如斯夫，不舍昼夜。时间过得飞快，且看明年会变成什么样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;兜兜转转又是一年，去年这个时候看到糊涂博士在骑行群里分享他的博客，觉得很高大上，于是夸下海口，跟糊涂博士说等我期末考试完了也搞个自己的博客，互设友链。&lt;/p&gt;
&lt;p&gt;结果还是自己懒，考完试根本没动静，那时候觉得有个自己的博客是一个技术水平特别高的事情，自己做不来。最后在糊涂
      
    
    </summary>
    
      <category term="博客" scheme="https://KingsFish.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="生日" scheme="https://KingsFish.github.io/tags/%E7%94%9F%E6%97%A5/"/>
    
  </entry>
  
</feed>
